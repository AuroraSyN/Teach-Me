{
  "items": [
    {
      "title": "Adaptive Software Development",
      "content": [
        {
          "tag_line": "Waterfall Model",
          "details": [
            "<p>The Waterfall model is a classic SDLC model that is widely known, understood and commonly used. It was introduced by Royce in 1970 and is still being followed as a common approach for software development in various organizations across the industry.</p>\n<p>In Waterfall model, each lifecycle phase can start only after the earlier lifecycle phase is complete. Thus, it is a linear model with no feedback loops.</p>\n<p><img src=\"https://www.tutorialspoint.com/adaptive_software_development/images/waterfall_lifecycle.jpg\" alt=\"Waterfall Lifecycle\" /></p>\n<h2>Waterfall Model &ndash; Strengths</h2>\n<p>The strengths of the Waterfall model are &minus;</p>\n<ul class=\"list\">\n<li>Easy to understand, easy to use.</li>\n<li>Provides structure to inexperienced development team.</li>\n<li>Milestones are well understood.</li>\n<li>Sets requirements stability.</li>\n<li>Ideal for management control (planning, monitoring, reporting).</li>\n<li>Works well when quality is more important than cost or schedule.</li>\n</ul>\n<h2>Waterfall Model &ndash; Weaknesses</h2>\n<p>The weaknesses or the disadvantages of the Waterfall model are &minus;</p>\n<ul class=\"list\">\n<li>\n<p>Idealised &minus; It does not match reality well.</p>\n</li>\n<li>\n<p>Unrealistic &minus; cannot expect accurate requirements early in the project.</p>\n</li>\n<li>\n<p>Does not reflect iterative nature of exploratory development that is more common.</p>\n</li>\n<li>\n<p>Difficult and expensive to make changes.</p>\n</li>\n<li>\n<p>Software is delivered only at the end of the project. Due to this &minus;</p>\n<ul class=\"list\">\n<li>\n<p>Delays discovery of serious defects.</p>\n</li>\n<li>\n<p>Possibility of delivery of obsolete requirements.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Significant management overhead, which can be costly for small teams and projects.</p>\n</li>\n<li>\n<p>Requires experienced resources at every phase &minus; analysts, designers, developers, testers.</p>\n</li>\n<li>\n<p>Testing starts only after the development is complete and the testers are not involved in any of the earlier phases.</p>\n</li>\n<li>\n<p>The expertize of the cross-functional teams is not shared as each phase is executed in silos.</p>\n</li>\n</ul>\n<h2>When to Use Waterfall Model?</h2>\n<p>You can use the Waterfall model if &minus;</p>\n<ul class=\"list\">\n<li>\n<p>Requirements are very well known.</p>\n</li>\n<li>\n<p>Product definition is stable.</p>\n</li>\n<li>\n<p>Technology is well understood.</p>\n</li>\n<li>\n<p>New version of an existing product.</p>\n</li>\n<li>\n<p>Porting an existing product to a new platform.</p>\n</li>\n<li>\n<p>Large organization with structured cross-functional teams.</p>\n</li>\n<li>\n<p>Communication channels are well established within the organization and with the customer as well.</p>\n</li>\n</ul>\n<h2>Evolutionary Prototyping Model</h2>\n<p>In software development using Evolutionary Prototyping model, the developers build a prototype during the requirements phase. The end users then evaluate the prototype and give feedback. The feedback can be corrections to the prototype or additional functionality. Based on the feedback, the developers further refine the prototype.</p>\n<p>Thus, the product evolves through the Prototype &rarr; Feedback &rarr; Refined Prototype Cycles and hence the name Evolutionary Prototyping. When the user is satisfied with the functionality, and working of the product, the prototype code is brought up to the required standards for the final product delivery.</p>\n<p><img src=\"https://www.tutorialspoint.com/adaptive_software_development/images/final_product_delivery.jpg\" alt=\"Final Product Delivery\" /></p>\n<h2>Evolutionary Prototyping Model &ndash; Strengths</h2>\n<p>The strengths or the advantages of an Evolutionary Prototyping model are &minus;</p>\n<ul class=\"list\">\n<li>\n<p>Customers/end users can visualize the system requirements as they are gathered looking at the prototype.</p>\n</li>\n<li>\n<p>Developers learn from customers and hence no ambiguities regarding domain or production environment.</p>\n</li>\n<li>\n<p>Allows flexible design and development.</p>\n</li>\n<li>\n<p>Interaction with the prototype stimulates the awareness of additionally needed functionality.</p>\n</li>\n<li>\n<p>Unexpected requirements and requirements changes are easily accommodated.</p>\n</li>\n<li>\n<p>Steady and visible signs of progress are produced.</p>\n</li>\n<li>\n<p>Delivery of an accurate and maintainable end-product.</p>\n</li>\n</ul>\n<h2>Evolutionary Prototyping Model &ndash; Weaknesses</h2>\n<p>The weaknesses or disadvantages of the Evolutionary Prototyping model are as follows &minus;</p>\n<ul class=\"list\">\n<li>\n<p>Tendency to abandon structured development in the code-and-fix development, though it is not what is prescribed by the model.</p>\n</li>\n<li>\n<p>This model received bad reputation for the quick-and-dirty methods.</p>\n</li>\n<li>\n<p>Overall maintainability can possibly be overlooked.</p>\n</li>\n<li>\n<p>The customer can possibly ask for the delivery of the prototype as the final, not giving the opportunity for the developers to execute the final step i.e. standardization of the end-product.</p>\n</li>\n<li>\n<p>Project can continue forever (with continuous scope creep) and the management may not appreciate it.</p>\n</li>\n</ul>\n<h2>When to Use Evolutionary Prototyping Model?</h2>\n<p>You can use the Evolutionary Prototyping model &minus;</p>\n<ul class=\"list\">\n<li>When requirements are unstable or have to be clarified</li>\n<li>As the requirements clarification stage of a waterfall model</li>\n<li>To develop user interfaces</li>\n<li>For short-lived demonstrations</li>\n<li>For new or original development</li>\n<li>For implementing a new technology</li>\n</ul>"
          ]
        },
        {
          "tag_line": "Template 2 ",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "Template 3 ",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Agile Methodology",
      "content": [
        {
          "tag_line": "Template 111 ",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "Template 222 ",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "Template 333 ",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "Template 444 ",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Agile Data Science",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Computer Programming",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Inter Process Communication",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Basics of Computers",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Basics of Computer Science",
      "content": [
        {
          "tag_line": "Template lo",
          "details": [
            ""
          ]
        }
      ]
    }
  ]
}