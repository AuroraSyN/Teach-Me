{
  "items": [
    {
      "title": "Linguistics DEUTSCH",
      "qType": "BIG_de_1",
      "content": [
        {
          "tag_line": "Objekte",
          "qType": "SMALL_de_1",
          "details": [
            "<h2>Objekte</h2>\n\n<p>Java ist eine objektorientierte Sprache. Das verlangt vom Entwickler neben dem Erlernen neuer Sprachelemente auch eine neue &laquo;objektorientierte&raquo; Denkweise. In Form eines Tutorials soll hier mit dieser Denkweise vertraut gemacht werden. Die folgenden Ausf&uuml;hrungen sind dabei im wesentlichen eine Adaption des Tutorials <a href=\"https://www.kompf.de/cplus/tutor.html\">Objektorientiertes Programmieren mit C++</a> auf die Programmiersprache Java.</p>\n\n<p>Herk&ouml;mmliche Softwareentwicklung bestand oftmals darin, zur L&ouml;sung eines vorgegebenen Problems Algorithmen zu entwerfen und diese in Prozeduren zu gie&szlig;en, die in einer Programmiersprache - wie zum Beispiel C - formuliert sind. Man spricht daher auch von prozeduraler Programmierung.</p>\n\n<p>Betrachtet man jedoch die reale Welt, so stellt man fest, dass die Dinge sich hier nicht in einer abstrakten prozeduralen Weise bewegen. Diesen Bruch zwischen realer Welt und Softwareentwicklung versucht der objektorientierte Ansatz zu &uuml;berwinden. Analysiert man seine materielle Umgebung, so stellt man fest, dass diese im wesentlichen aus Objekten besteht, die in verschiedener Art und Weise miteinander agieren. So k&ouml;nnte es hier zum Beispiel gerade ein Objekt Fahrrad geben.</p>\n\n<p><img align=\"left\" alt=\"Objekt\" height=\"160\" src=\"https://www.kompf.de/java/images/java-tutor-1.gif\" width=\"165\" /> Nimmt man das Fahrrad noch weiter unter die Lupe, erkennt man, dass dieses Fahrrad bestimmte <em>Eigenschaften</em> bzw. <em>Attribute</em> (wie Farbe, Gr&ouml;&szlig;e, momentane Geschwindigkeit) besitzt und dass es <em>Methoden</em> gibt, diese Eigenschaften zu ver&auml;ndern (z.B. die Methode &quot;Tritt schneller&quot;, die zu einer Erh&ouml;hung der Geschwindigkeit f&uuml;hren wird oder die Methode &quot;Bremse&quot;, die das Gegenteil bewirken sollte).</p>\n\n<p>Transformiert man diese Erkenntnis aus der realen in die Software Welt, so kann man formulieren:</p>\n\n<p class=\"definition\">Ein Software Objekt ist ein B&uuml;ndel aus Attributen und darauf bezogenen Methoden.</p>\n"
          ]
        },
        {
          "tag_line": "Klassen",
          "qType": "SMALL_de_2",
          "details": [
            "<h2>Klassen</h2>\n\n<h3 id=\"klassen_als_bauplan\">Klassen als Bauplan</h3>\n\n<p>Wenn man verschiedene Fahrr&auml;der der realen Welt genauer betrachtet, so ist festzustellen, dass alle diese Fahrrad Objekte &auml;hnlich sind: Alle besitzen Bremsen, alle haben irgendeine Farbe usw. Es muss also einen <em>Bauplan</em> geben, der beschreibt, wie ein Fahrrad grunds&auml;tzlich auszusehen hat. Alle Fahrrad Objekte sind nach diesem Bauplan erstellt worden - deswegen ist es auch m&ouml;glich, ein beliebiges Fahrrad zu fahren, wenn man einmal das Fahrradfahren gelernt hat!</p>\n\n<p class=\"definition\">Eine Klasse ist ein Bauplan, welcher die Attribute und Methoden definiert, die alle Objekte einer bestimmten Art besitzen.</p>\n\n<p><img align=\"left\" alt=\"class StockItem\" height=\"134\" src=\"https://www.kompf.de/java/images/java-tutor-2.png\" style=\"margin-right:15px;\" width=\"158\" /> Die Abbildung zeigt eine Klasse <tt>StockItem</tt> in der sogenannten UML (unified modelling language) Notation. Diese Klasse k&ouml;nnte in einem Programm zur Aktienanalyse verwendet werden. Ein solches Programm muss viele verschiedene Aktien Objekte verwalten k&ouml;nnen. Damit dies effektiv geschehen kann, sollten alle diese verschiedenen Objekte jedoch nach einem einheitlichen Bauplan - der Klassendefinition - erstellt werden.</p>\n\n<p>Der Name der Klasse steht in der UML-Notation im oberen Drittel des Rechtecks. Im mittleren Drittel stehen die Attribute. Die Beispielklasse <tt>StockItem</tt> definiert die zwei Attribute m_name und m_value, d.h. den Namen der Aktie und den momentanen Kurswert. Das Minuszeichen vor den Attributen bedeutet, das diese <tt class=\"keyword\">private</tt> Mitglieder der Klasse sind, d.h. von au&szlig;en kann nicht direkt auf sie zugegriffen werden.</p>\n\n<p>Im unteren Drittel stehen die Methoden der Klasse <tt>StockItem</tt>. Das Pluszeichen vor ihnen zeigt, dass sie <tt class=\"keyword\">public</tt> sind, d.h. die Methoden d&uuml;rfen von anderen Objekten aufgerufen werden. Damit zeigt sich das Prinzip der Kapselung: Anstatt auf das Attribut m_value direkt zuzugreifen, <em>m&uuml;ssen</em> andere Objekte die Zugriffsmethoden setValue() und getValue() benutzen! So hat der Entwickler der Klasse die M&ouml;glichkeit, in setValue() noch zus&auml;tzliche Abfragen, z.B. bez&uuml;glich der G&uuml;ltigkeit des Parameters, einzubauen.</p>\n\n<p>Aufmerksamen Lesern wird bei Betrachtung der Abbildung nicht entgangen sein, dass Methoden in Java - wie auch in C++ - nicht nur durch den Namen, sondern durch Namen <em>und</em> Parameteranzahl und -typ unterschieden werden! So kann es die Methode setValue() zweimal geben: Einmal mit einem Parameter vom Typ <tt class=\"keyword\">double</tt> und mit einem vom Typ <tt>String</tt>. Der Compiler erkennt beim Aufruf dieser Methode anhand des Parametertyps selbstt&auml;tig, welche Variante er verwenden muss.</p>\n\n<h3 id=\"klassendefinition_und_implementierung\">Klassendefinition und Implementierung</h3>\n\n<p>In Java gibt es keine Trennung zwischen Definition und Implementierung einer Klasse. Beides erfolgt in einer Textdatei mit der Extension <b>.java</b>, die den Namen der Klasse tr&auml;gt. Eine Unterteilung in Header- und Implementierungsdatei wie bei C++ gibt es nicht.</p>\n\n<p>Die Definition und Implementierung der Java Klasse f&uuml;r StockItem wird also in der Datei mit dem Namen <b>StockItem.java</b> vorgenommen:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">package</span> de.kompf.tutor;\n\n<span class=\"doccomment\">/**\n * Class representing a StockItem.\n */</span>\n<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> StockItem {\n  <span class=\"keyword\">private</span> String m_name;\n  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> m_value;\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItem with empty name and no value.\n   */</span>\n  <span class=\"keyword\">public</span> StockItem() {\n    <span class=\"keyword\">this</span>(<span class=\"quotedstring\">&quot;&quot;</span>, 0.0);\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItem with no value.\n   * \n   * @param name The name of the StockItem.\n   */</span>\n  <span class=\"keyword\">public</span> StockItem(String name) {\n    <span class=\"keyword\">this</span>(name, 0.0);\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItem.\n   * \n   * @param name The name.\n   * @param value The value.\n   */</span>\n  <span class=\"keyword\">public</span> StockItem(String name, <span class=\"keyword\">double</span> value) {\n    m_name = name;\n    m_value = value;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The name.\n   */</span>\n  <span class=\"keyword\">public</span> String getName() {\n    <span class=\"keyword\">return</span> m_name;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param val The value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setValue(<span class=\"keyword\">double</span> val) {\n    m_value = val;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param val The value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setValue(String val) {\n    m_value = Double.parseDouble(val);\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The value.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getValue() {\n    <span class=\"keyword\">return</span> m_value;\n  }\n\n  <span class=\"doccomment\">/**\n   * @see java.lang.Object#toString()\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> String toString() {\n    <span class=\"keyword\">return</span> m_name + <span class=\"quotedstring\">&quot;: &quot;</span> + m_value;\n  }\n}\n</pre>\n\n<p>Die Datei beginnt mit einer Package Deklaration. Dadurch lassen sich auch gro&szlig;e Projekte gut strukturieren. Zum einen dient der Packagename <tt>de.kompf.tutor</tt> als eine Art Namensraum: Klassennamen m&uuml;ssen nur innerhalb einer Package eindeutig sein. Zum anderen werden die Dateien entsprechend ihres Packagenamens auf der Platte abgelegt: Alle zur Package <tt>de.kompf.tutor</tt> geh&ouml;renden Java Dateien befindet sich im Verzeichnis <b>de/kompf/tutor</b> relativ zum Projektverzeichnis.</p>\n\n<p>Die eigentliche Klassendefinition beginnt mit den Schl&uuml;sselw&ouml;rtern <tt class=\"keyword\">public class</tt> gefolgt vom Namen der Klasse. Der Klassenrumpf wird von geschweiften Klammern { } umschlossen. Er enth&auml;lt s&auml;mtliche Methoden und Attribute (&laquo;Member&raquo;) der Klasse. Dabei kennzeichnen die Schl&uuml;sselw&ouml;rter <tt class=\"keyword\">public</tt> und <tt class=\"keyword\">private</tt> vor <em>jeder</em> Deklaration die im letzten Abschnitt besprochene &ouml;ffentliche oder private Sichtbarkeit des Members. Es gibt au&szlig;erdem noch die M&ouml;glichkeit, mittels <tt class=\"keyword\">protected</tt> Variablen und Methoden zu deklarieren, die ausschlie&szlig;lich abgeleiteten Klassen zur Verf&uuml;gung stehen sollen. Dazu mehr sp&auml;ter mehr beim Thema <em>Vererbung</em>. Es ist auch m&ouml;glich, die Sichtbarkeit nicht explizit anzugeben. Dann ist der entsprechende Member in der zugeh&ouml;rigen Package sichtbar.</p>\n\n<p>Jede Klasse ben&ouml;tigt mindestens einen Konstruktor (kurz <em>ctor</em>) zur Erzeugung von Objekten der Klasse. Ein Konstruktor hat den gleichen Namen wie die Klasse und keinen R&uuml;ckgabewert. Eine Angabe der Sichtbarkeit per <tt class=\"keyword\">public</tt>, <tt class=\"keyword\">private</tt> und so weiter ist auch f&uuml;r Konstruktoren m&ouml;glich. Man kann auch auf die explizite Angabe eines Konstruktors verzichten, in diesem Fall hat die Klasse automatisch einen impliziten <tt class=\"keyword\">public</tt> Konstruktor ohne Parameter, den <em>Default Konstruktor</em>.</p>\n\n<p>Die Klasse besitzt drei Konstruktoren, um eine Initialisierung mit verschiedenen Kombinationen von Parametern zu erlauben. Eine Angabe von Defaultwerten direkt in der Parameterliste analog zu C++ ist in Java nicht m&ouml;glich. Die restliche Implementierung besteht aus den Methoden zum Setzen und Auslesen der Membervariablen. Eine Methode zum Setzen des Namens fehlt mit Absicht, es soll nicht m&ouml;glich sein, den Namen eines StockItems im Nachhinein zu &auml;ndern.</p>\n\n<p>Im Gegensatz zur gleichnamigen C++ Klasse aus dem <a href=\"https://www.kompf.de/cplus/tutor.html\">C++ Tutorial</a> ist es in Java nicht notwendig, sich mit Dingen wie Copy-Constructor, Destructor und Assignment Operator herumzuschlagen. Warum dies so ist, wird bei der Betrachtung des <em>Objektlebenszyklus</em> verst&auml;ndlich.</p>\n"
          ]
        },
        {
          "tag_line": "Objektlebenszyklus",
          "qType": "SMALL_de_3",
          "details": [
            "<h2>Objektlebenszyklus</h2>\n\n<p>Der Lebenszyklus eines Java Objektes besteht aus den Abschnitten</p>\n\n<ol>\n\t<li>Erzeugung</li>\n\t<li>Benutzung</li>\n\t<li>Zerst&ouml;rung</li>\n</ol>\n\n<h3 id=\"erzeugen_eines_objektes\">Erzeugen eines Objektes</h3>\n\n<p>Das Erzeugen eines Objektes erfolgt immer dynamisch mittels des <tt class=\"keyword\">new</tt> Operators in Verbindung mit einem <em>Konstruktor</em>. Das Ergebnis kann einer Variablen mit passendem Typ zugewiesen werden:</p>\n\n<pre class=\"java\">\nStockItem bas = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;BAS&quot;</span>, 120.34);\n</pre>\n\n<p>Eine statische Erzeugung ohne <tt class=\"keyword\">new</tt> analog zu C++ ist in Java nicht m&ouml;glich. Eine Objektvariable enth&auml;lt demnach <em>immer</em> eine <em>Referenz</em> auf das Objekt und nicht das Objekt selbst.</p>\n\n<h3 id=\"benutzen_eines_objektes\">Benutzen eines Objektes</h3>\n\n<p>Ein Objekt wird benutzt, indem eine seiner Methoden aufgerufen wird:</p>\n\n<pre class=\"java\">\nbas.setValue(52.80);\n<span class=\"keyword\">double</span> v = bas.getValue();\n<span class=\"slashslashcomment\">// v sollte jetzt den Wert 52.8 haben</span>\n</pre>\n\n<p>Au&szlig;erdem kann ein Objekt als Parameter an eine Methode &uuml;bergeben oder von dieser per <tt class=\"keyword\">return</tt> zur&uuml;ckgeliefert werden. Die Parameter&uuml;bergabe an Methoden erfolgt in Java immer <em>per Value</em>. Da die Objektvariable in Java aber nur die Referenz auf das Objekt und nicht das Objekt selbst enth&auml;lt, erfolgt hierbei kein Kopieren des Objektes. Als Konsequenz sind &Auml;nderungen am Objekt, die eine Methode vornimmt, auch im aufrufenden Kode sichtbar:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">class</span> Converter {\n  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> split(StockItem item, <span class=\"keyword\">double</span> count) {\n    item.setValue(item.getValue() / count);\n  }\n}\n\nbas.setValue(52.80);\nConverter.split(bas, 2);\nSystem.out.println(bas);\n<span class=\"slashslashcomment\">// gibt &#39;BAS: 26.4&#39; aus</span>\n</pre>\n\n<p>Die Zuweisung eines Objektes an eine Variable betrifft dann ebenso nur die Objektreferenz. Es gibt in Java kein Pendant zum Assignment Operator aus C++.</p>\n\n<pre class=\"java\">\nStockItem x = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;XYZ&quot;</span>, 42);\nStockItem y = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;ABC&quot;</span>, 22);\n\nx = y;\n<span class=\"slashslashcomment\">// Die Variable x enth&auml;lt eine Referenz auf das Objekt mit dem Namen &quot;ABC&quot;.</span>\n<span class=\"slashslashcomment\">// Das Objekt namens &quot;XYZ&quot; wird nicht mehr referenziert und irgendwann vom</span>\n<span class=\"slashslashcomment\">// Garbage Collector entsorgt.</span>\n</pre>\n\n<p>Zuweisungen und Parameter&uuml;bergaben betreffen in Java also immer nur die Objektreferenz. Als Konsequenz wird niemals eine automatische Kopie von Objekten erzeugt. Ben&ouml;tigt man aber doch einmal eine Kopie eines Objektes, kann man daf&uuml;r seine <tt>clone()</tt> Methode verwenden. Diese Methode muss vom Entwickler kodiert werden, es gibt hierf&uuml;r keinen Automatismus. Der Fall, das man eine Kopie eines Objektes ben&ouml;tigt, tritt allerdings &auml;u&szlig;erst selten auf. Dieses Einsteigertutorial verzichtet daher auf eine n&auml;here Betrachtung von <tt>clone()</tt>.</p>\n\n<h3 id=\"statische_methoden\">Statische Methoden</h3>\n\n<p>Bei der im vorigen Abschnitt eingef&uuml;hrten Methode <tt>split</tt> handelt es sich um eine <b>statische</b> Methode. Im Programmcode werden statische Methoden durch das Keyword <tt class=\"keyword\">static</tt> bei der Methodendeklaration gekennzeichnet.</p>\n\n<p>Statische Methoden geh&ouml;ren zu einer bestimmtem Klasse und nicht zu einem Objekt. Daher steht beim Aufruf einer solchen Methode vor dem Punkt auch ein Klassenname und keine Variable. Statische Methoden haben logischerweise keinen Zugriff auf die nicht-statischen Variablen und Methoden der Klasse. Oft werden <tt class=\"keyword\">static</tt> Methoden als Utility- und Hilfsfunktionen verwendet, die nicht im Kontext eines bestimmten Objektes ausgef&uuml;hrt werden m&uuml;ssen. Prominentes Beispiel daf&uuml;r sind die mathematischen Funktionen aus <tt>java.lang.Math</tt>.</p>\n\n<h3 id=\"zerst_ren_eines_objektes\">Zerst&ouml;ren eines Objektes</h3>\n\n<p>Der Java Programmierer braucht sich nicht um das Aufr&auml;umen nicht mehr ben&ouml;tigter Objekte zu k&uuml;mmern. Das erledigt der Garbage Collector (GC) f&uuml;r ihn.</p>\n\n<p>Der GC f&uuml;hrt Buch &uuml;ber alle per <tt class=\"keyword\">new</tt> angelegten Objekte. Er pr&uuml;ft in regelm&auml;&szlig;igen Abst&auml;nden, ob es Objekte gibt, die von keiner Variablem mehr referenziert werden. Der von diesen Objekten belegte Speicherplatz wird dann freigegeben.</p>\n\n<p>Es gibt in Java im Unterschied zu C++ daher auch keinen delete Operator und keinen Destruktor. Falls man doch eine M&ouml;glichkeit ben&ouml;tigt, kurz vor dem Entfernen des Objektes noch eigenen Programmcode auszuf&uuml;hren, kann daf&uuml;r die Methode <tt>finalize()</tt> genutzt werden.</p>\n"
          ]
        },
        {
          "tag_line": "Vererbung",
          "qType": "SMALL_de_4",
          "details": [
            "<h2>Vererbung</h2>\n\n<h3 id=\"konzept\">Konzept</h3>\n\n<p>Vererbung erlaubt die Definition neuer Klassen auf der Basis von bestehenden Klassen. Dies ist ein grundlegendes Konzept objektorientierten Designs. <img align=\"left\" alt=\"Vererbung\" height=\"107\" src=\"https://www.kompf.de/java/images/java-tutor-3.gif\" width=\"173\" /> Weiter oben wurde der Begriff der <em>Klasse</em> als eine Art Bauplan f&uuml;r Objekte erkl&auml;rt. Anhand des dort verwendeten Beispiels &quot;Fahrrad&quot; lassen sich weitere Parallelen zur realen Welt ziehen: Es f&auml;llt auf, dass es hier <em>verschiedene Arten</em> von Fahrr&auml;dern gibt: Rennr&auml;der, Montainbikes, Trekkingr&auml;der und das gute alte Hollandrad. Warum sind alle diese verschiedenen R&auml;der als F&auml;hrr&auml;der erkennbar? Weil sie gewisse gemeinsame Eigenschaften haben: Alle haben zwei R&auml;der, einen Lenker und lassen sich durch Tritt auf die Pedale fortbewegen. Zus&auml;tzlich zu diesen Gemeinsamkeiten bringen sie aber auch neue Eigenschaften ein: Montainbikes und Rennr&auml;der haben jeweils eine Gangschaltung, unterscheiden sich aber durch die Art der Bereifung.</p>\n\n<p>In objektorientierter Sprache k&ouml;nnte man also sagen: Die Klassen Montainbikes, Rennr&auml;der und Hollandr&auml;der <em>erben</em> von der Klasse Fahrr&auml;der gemeinsame Eigenschaften und f&uuml;gen zus&auml;tzliche hinzu. Allgemein gilt:</p>\n\n<ul>\n\t<li>Klassen k&ouml;nnen definiert werden in Abh&auml;ngigkeit von anderen Klassen: &quot;A ist eine Art von B&quot;. In diesem Fall ist B die <em>Basisklasse</em> von A.</li>\n\t<li>Eine Klasse kann auch von mehreren Klassen erben: A ist eine Art von B und C (Mehrfachvererbung). Allerdings ist Mehrfachvererbung in Java nicht f&uuml;r Klassen, sondern nur f&uuml;r <a href=\"https://www.kompf.de/java/tutor.html#h2_interfaces\">Interfaces</a> erlaubt.</li>\n\t<li>Jede Klasse erbt die (&ouml;ffentlichen) Attribute und Methoden ihrer Basisklasse(n).</li>\n\t<li>Jedoch kann jede Klasse eigene Variablen und Methoden hinzuf&uuml;gen.</li>\n</ul>\n\n<p>Es ist wichtig zu verstehen, dass Vererbung nur in eine Richtung l&auml;uft: Ein Rennrad ist zwar immer auch ein Fahrrad, aber nicht jedes Fahrrad ist automatisch ein Rennrad.</p>\n\n<h3 id=\"vererbung_in_java\">Vererbung in Java</h3>\n\n<p>Die bereits definierte und benutzte Klasse <em>StockItem</em> erlaubt die Speicherung eines Namens und eines dazugeh&ouml;renden Wertes und ist zur Darstellung von Aktienkursen gedacht. Wer sich mit dieser Materie schon besch&auml;ftigt hat, der wei&szlig;, dass zu einer Aktie noch viele Informationen mehr gespeichert werden k&ouml;nnen. So gibt es neben dem (Tages- oder Wochen-)Schlusskurs (<em>Close</em>) noch Er&ouml;ffnungs- (<em>Open</em>), H&ouml;chst- (<em>High</em>) und Tiefstkurs (<em>Low</em>). StockItem soll daher um die M&ouml;glichkeit erweitert werden, statt nur einem Wert die Er&ouml;ffnungs- und Schlusskurse abfragen und setzen zu k&ouml;nnen.</p>\n\n<p>Diese Erweiterung soll jedoch nicht durch Ver&auml;ndern der existierenden Klasse StockItem erfolgen - diese Klasse wird bereits in vielen Softwareprojekten benutzt und eine &Auml;nderung ihrer Funktionalit&auml;t k&ouml;nnte unter Umst&auml;nden b&ouml;se Auswirkungen haben. Auch will man das Rad nicht v&ouml;llig neu erfinden - vorhandener Code soll so weit wie m&ouml;glich wiederverwendet werden. Das alles l&auml;sst sich dadurch erreichen, indem eine neue Klasse <em>StockItemOC</em> definiert wird, die von der vorhandenen Klasse StockItem <em>abgeleitet</em> ist:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">package</span> de.kompf.tutor;\n\n<span class=\"doccomment\">/**\n * Class representing a StockItem with open and close value.\n */</span>\n<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> StockItemOC <span class=\"keyword\">extends</span> StockItem {\n\n  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> m_open;\n  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> m_close;\n  \n  <span class=\"doccomment\">/**\n   * Construct a new StockItemOC with empty name and no values.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC() {\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItemOC with no values.\n   * \n   * @param name The name.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC(String name) {\n    <span class=\"keyword\">super</span>(name);\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItemOC.\n   * \n   * @param name The name.\n   * @param open The open value.\n   * @param close The close value.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC(String name, <span class=\"keyword\">double</span> open, <span class=\"keyword\">double</span> close) {\n    <span class=\"keyword\">super</span>(name);\n    m_open = open;\n    m_close = close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The value of this item which is identical to the close value.\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getValue() {\n    <span class=\"keyword\">return</span> m_close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param val The value of this item to set.\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setValue(<span class=\"keyword\">double</span> val) {\n    m_close = val;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The open value.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getOpen() {\n    <span class=\"keyword\">return</span> m_open;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param open The open value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setOpen(<span class=\"keyword\">double</span> open) {\n    m_open = open;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The close value.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getClose() {\n    <span class=\"keyword\">return</span> m_close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param close The close value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setClose(<span class=\"keyword\">double</span> close) {\n    m_close = close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @see Object#toString()\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> String toString() {\n    <span class=\"keyword\">return</span> getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + m_open + <span class=\"quotedstring\">&quot;/&quot;</span> + m_close;\n  }\n}\n</pre>\n\n<p>Die einzige syntaktische Erweiterung gegen&uuml;ber der bekannten Klassendefinition ist, dass zu Beginn der Definition nach dem Klassennamen <tt>StockItemOC</tt> das Schl&uuml;sselwort <tt class=\"keyword\">extends</tt> gefolgt vom Namen der Basisklasse angegeben wird.</p>\n\n<p>Welche Auswirkung hat diese Vererbungsbeziehung nun auf das Verhalten der abgeleiteten Klasse StockItemOC? <img align=\"left\" alt=\"class StockItemOC\" height=\"386\" src=\"https://www.kompf.de/java/images/java-tutor-4.png\" style=\"margin:5px 35px 5px 0px;\" width=\"159\" /></p>\n\n<ul>\n\t<li>StockItemOC <em>erbt</em> die Methode getName() von StockItem. Diese Methode braucht also nicht noch einmal implementiert zu werden.</li>\n\t<li>StockItemOC <em>&uuml;berschreibt</em> die Methoden setValue() und getValue() von StockItem. Diese Methoden m&uuml;ssen anders implementiert sein, da StockItemOC ja zwei Kurswerte statt einem zur Auswahl hat.</li>\n\t<li>StockItemOC hat die <em>zus&auml;tzlichen</em> Methoden getOpen(), setOpen(), getClose() und setClose(), um die zus&auml;tzliche gew&uuml;nschte Funktionalit&auml;t abbilden zu k&ouml;nnen.</li>\n\t<li>StockItemOC <em>erbt</em> die Variablen m_name und m_value von StockItem. Da diese Variablen dort aber als <em>private</em> deklariert sind, haben die Methoden von StockItemOC keinen Zugriff auf diese Variable - au&szlig;er nat&uuml;rlich getName(), denn diese ist ja auch von StockItem geerbt.</li>\n\t<li>StockItemOC deklariert die <em>zus&auml;tzlichen</em> privaten Variablen m_open und m_close.</li>\n</ul>\n\n<p>Interessant sind auch die Konstruktoren der Klasse: Da ja kein Zugriff auf die <tt class=\"keyword\">private</tt> Membervariablen der Basisklasse erlaubt ist, erfolgt das Setzen von <tt>m_name</tt> &uuml;ber den Aufruf des Konstruktors der Basisklasse per <tt class=\"keyword\">super</tt><tt>(<i>Parameterliste</i>)</tt>. Der Aufruf von <tt class=\"keyword\">super</tt> muss immer das erste Statement im Konstruktor sein. L&auml;sst man ihn - wie im parameterlosen Defaultkonstruktor des Beispiels - weg, dann f&uuml;gt der Compiler implizit <tt class=\"keyword\">super()</tt> ein.</p>\n\n<h3 id=\"verwendung_abgeleiteter_klassen\">Verwendung abgeleiteter Klassen</h3>\n\n<p>Die Verwendung von abgeleiteten Klassen soll nun anhand der Klasse StockItemOC in einem kleinen Testprogramm demonstriert werden.</p>\n\n<p>Als Eintrittspunkt in ein Java-(Konsolen-)Programm dient die spezielle statische Methode <tt>main</tt> mit genau der im folgenden Beispiel angegebenen Signatur:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) {\n  StockItem a = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;BAY&quot;</span>, 34.9);\n  StockItem b = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;BAS&quot;</span>, 24.2);\n  StockItemOC c = <span class=\"keyword\">new</span> StockItemOC(<span class=\"quotedstring\">&quot;DTE&quot;</span>, 57.0, 59.4);\n\n  System.out.println(a.getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + a.getValue());\n  System.out.println(b.getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + b.getValue());\n  System.out.println(c.getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + c.getValue() \n      + <span class=\"quotedstring\">&quot; (&quot;</span> + c.getOpen() + <span class=\"quotedstring\">&quot;/&quot;</span> + c.getClose() + <span class=\"quotedstring\">&quot;)&quot;</span>);\n</pre>\n\n<p>Dies bietet auf den ersten Blick nichts neues. Beim zweiten Hinsehen erkennen wir, dass in der letzten Anweisung die Methode getName() des Objektes c, welches vom Typ StockItemOC ist, aufgerufen wird. Die Klasse StockItemOC hat aber gar keine Methode getName() definiert! Mit dem neu erworbenen Wissen &uuml;ber Vererbung ist jedoch klar, was passiert: Es wird einfach die von der Klasse StockItem <em>geerbte</em> Methode verwendet!</p>\n\n<p>Interessant ist auch die Verwendung der Methode getValue(). Diese gibt es sowohl in StockItem als auch in StockItemOC. In diesem Beispiel ist jedoch relativ einfach zu verstehen, was passiert: In der letzten Anweisung ruft der Java Compiler StockItemOC.getValue() auf, in den Anweisungen davor jedoch StockItem.getValue(). Das ist eindeutig, weil der Typ der Objekte a, b und c bereits zur &Uuml;bersetzungszeit bekannt ist.</p>\n\n<p>Was passiert jedoch, wenn der Compiler beim &Uuml;bersetzen den genauen Typ des Objektes noch nicht kennt? Hier ist die Fortsetzung des Programms:</p>\n\n<pre class=\"java\">\n  <span class=\"slashslashcomment\">// array with element type StockItem</span>\n  StockItem[] astocks = <span class=\"keyword\">new</span> StockItem[3];\n  astocks[0] = a;\n  astocks[1] = b;\n  astocks[2] = c;\n  \n  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = 0; i &lt; astocks.length; ++i) {\n      System.out.println(astocks[i].getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + astocks[i].getValue());\n  }\n</pre>\n\n<p>Beim Aufruf astocks[i].getValue() muss je nachdem, ob die in astocks stehende Variable ein Objekt vom Typ StockItem (bei Index 0 und 1) oder vom Typ StockItemOC (Index 2) referenziert, eine andere Methode aufgerufen werden. Dies kann erst zur Laufzeit entschieden werden, man spricht daher von <em>dynamischer</em> oder <em>sp&auml;ter Bindung</em>.</p>\n\n<p>Der Java Compiler arbeitet immer mit dynamischer Bindung. C++ dagegen erlaubt hier die Steuerung der Bindungsart (statisch oder dynamisch) per Schl&uuml;sselwort <tt>virtual</tt> - diese Falle gibt es in Java zum Gl&uuml;ck nicht.</p>\n\n<p>Zum Schluss noch eine fortgeschrittene Anwendung. Statt in ein Array werden die Objekte in eine Liste gepackt. Anschlie&szlig;end werden sie nach ihrem Wert (getValue()) sortiert und ausgegeben. Das alles funktioniert auch dann, wenn die Liste sowohl Objekte vom Typ StockItem als auch StockItemOC enth&auml;lt:</p>\n\n<pre class=\"cplus\">\n  <span class=\"slashslashcomment\">// get the stock items ordered by price</span>\n  List&lt;StockItem&gt; stocks = <span class=\"keyword\">new</span> LinkedList&lt;StockItem&gt;();\n    \n  stocks.add(a);\n  stocks.add(b);\n  stocks.add(c);\n  \n  Collections.sort(stocks, <span class=\"keyword\">new</span> Comparator&lt;StockItem&gt;() {\n\n    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> compare(StockItem s1, StockItem s2) {\n      <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) Math.signum(s1.getValue() - s2.getValue());\n    }\n  });\n\n  System.out.println(<span class=\"quotedstring\">&quot;stock items ordered by price&quot;</span>);\n  System.out.println(stocks);\n} \n</pre>\n\n<p>F&uuml;r die Sortierung ist ein Comparator notwendig. Dessen Methode <tt>compare</tt> vergleicht die Werte zweier StockItems. Wie man sieht, reicht es v&ouml;llig aus, <tt>compare</tt> f&uuml;r Parameter des Typs StockItem zu implementieren. Es ist beim Aufruf der Methode dann egal, ob der aktuelle Parameter auf ein Objekt vom Typ StockItem oder StockItemOC zeigt. Dies ist ein Resultat (und Vorteil) der verwendeten Vererbungshierarchie.</p>\n\n<p>Die Ausgabe aller Items erfolgt ganz einfach per &Uuml;bergabe der kompletten Liste an <tt>System.out.println</tt>, was im Beispiel den Text</p>\n\n<pre class=\"code\">\n[BAS: 24.2, BAY: 34.9, DTE: 57.0/59.4]\n</pre>\n\n<p>in die Standardausgabe schreibt.</p>\n\n<p><tt>System.out.println</tt> verlangt als Parameter eine Variable vom Typ <tt>Object</tt>. Im Beispiel wird jedoch eine <tt>List</tt> &uuml;bergeben. Bei der Erkl&auml;rung, warum das funktioniert, kommt man zu einer wichtigen Eigenschaft aller Klassen in Java:</p>\n\n<p class=\"definition\">Alle Java Klassen sind implizit von der Klasse <tt>java.lang.Object</tt> abgeleitet.</p>\n\n<p>Also auch die Klassen StockItem und StockItemOC! <tt>System.out.println</tt> ruft nun die Methode <tt>toString()</tt> des &uuml;bergebenen Objekts auf und schreibt den R&uuml;ckgabewert in die Standardausgabe. Die Klasse LinkedList (die ja auch von Object erbt) implementiert <tt>toString()</tt> in der Form, dass f&uuml;r jedes Element der Liste ebenfalls <tt>toString()</tt> aufgerufen wird. Damit wird jetzt klar, warum in den Klassendefinitionen f&uuml;r StockItem und StockItemOC (siehe oben) jeweils die Methode <tt>toString()</tt> implementiert ist! H&auml;tte man dies nicht getan, dann s&auml;he die Ausgabe etwa so aus:</p>\n\n<pre class=\"code\">\n[de.kompf.tutor.StockItem@11b86e7, de.kompf.tutor.StockItem@35ce36, de.kompf.tutor.StockItemOC@757aef]\n</pre>\n\n<p>Es k&auml;me dann die von <tt>Object</tt> geerbte <tt>toString()</tt> Methode zur Anwendung, die den Klassennamen und eine Adresse ausgibt.</p>\n\n<h3 id=\"abstrakte_klassen\">Abstrakte Klassen</h3>\n\n<p>Bei einigen Vererbungshierarchien kommt man vielleicht zu der Erkenntnis, dass f&uuml;r bestimmte Basisklassen nie Objekte instanziert werden. Im oben eingef&uuml;hrten Fahrradbeispiel w&uuml;rde das dann hei&szlig;en, dass es keine Fahrr&auml;der vom Typ &laquo;Fahrrad&raquo; gibt, sondern jedes Fahrad sich einem speziellen, abgeleiteten Typ, wie Rennrad, Hollandrad und so weiter zuordnen l&auml;sst. Die Basisklasse Fahrrad wird dann als <b>abstrakt</b> bezeichnet.</p>\n"
          ]
        },
        {
          "tag_line": "Interfaces",
          "qType": "SMALL_de_5",
          "details": [
            "<h2>Interfaces</h2>\n\n<p>Wenn eine abstrakte Klasse nur noch Methodensignaturen, aber keine Implementierung mehr enth&auml;lt, wird sie zum <b>interface</b>. Java verwendet daf&uuml;r das reservierte Sch&uuml;sselwort <tt class=\"keyword\">interface</tt>.</p>\n\n<p>Ein <tt class=\"keyword\">interface</tt> verwendet man, um das Verhalten von Objekten festzulegen, bei denen man sich (noch) nicht auf eine bestimmte Implementierung festlegen will. Zum Beispiel k&ouml;nnte man so einen <tt>QuoteService</tt> definieren, der die Abfrage von Aktienkursen erlaubt:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">package</span> de.kompf.tutor;\n\n<span class=\"doccomment\">/**\n * Interface to define a service to get quotes.\n */</span>\n<span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> QuoteService {\n\n  <span class=\"doccomment\">/**\n   * Get the last known price for a stock item.\n   * \n   * @param name The name of the item.\n   * @return The price.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> lastPrice(String name);\n\n  <span class=\"doccomment\">/**\n   * Get a stock item with the open and close at a given date.\n   * \n   * @param name The name of the item.\n   * @param date The date.\n   * @return The StockItemOC.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC openClose(String name, java.util.Date date);\n}\n</pre>\n\n<p>Zu diesem Zeitpunkt gibt es noch keine Implementierung des Interface. Man kann beim Programmieren aber schon so tun, als g&auml;be es eine, indem einfach gegen das Interface programmiert wird:</p>\n\n<pre class=\"java\">\nList&lt;StockItem&gt; myStocks;\nQuoteService quoteService;\n<span class=\"slashslashcomment\">//  ...</span>\n<span class=\"slashslashcomment\">// get actual quotes for my stock</span>\n<span class=\"keyword\">for</span> (StockItem stockItem : myStocks) {\n  <span class=\"keyword\">double</span> lastPrice = quoteService.lastPrice(stockItem.getName());\n  stockItem.setValue(lastPrice);\n}\n</pre>\n\n<p>Um das Programm jetzt schon zu testen, kann man sich einen &laquo;Mock&raquo; Service schreiben, der das Interface QuoteService implementiert und irgendwelche Werte zur&uuml;ckliefert:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> MockQuoteService <span class=\"keyword\">implements</span> QuoteService {\n\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> lastPrice(String name) {\n    <span class=\"keyword\">return</span> 10.0;\n  }\n\n  <span class=\"keyword\">public</span> StockItemOC openClose(String name, Date date) {\n    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StockItemOC(name, 10.0, 11.0);\n  }\n}\n</pre>\n\n<p>Im Code erg&auml;nzt man dann</p>\n\n<pre class=\"java\">\nquoteService = <span class=\"keyword\">new</span> MockQuoteService();\n</pre>\n\n<p>Sp&auml;ter, wenn die richtige Implementierung, zum Beispiel als Klasse <tt>YahooQuoteService</tt> zur Verf&uuml;gung steht, &auml;ndert man diese Zeile einfach in</p>\n\n<pre class=\"java\">\nquoteService = <span class=\"keyword\">new</span> YahooQuoteService();\n</pre>\n\n<p>und benutzt von diesem Zeitpunkt an eine andere Implementierung. Am restlichen Programm d&uuml;rfte sich nichts mehr &auml;ndern, wenn man konsequent gegen das Interface programmiert hat.</p>\n\n<p>Diese M&ouml;glichkeit zur Trennung von Interface und Implementierung ist ein gro&szlig;er Vorteil von Java. Insbesondere unter den Aspekten der Teamarbeit und der Wiederverwendbarkeit von Programmcode sollte man sich die Regel &laquo;Programmiere gegen Interfaces statt gegen Implementierungen&raquo; verinnerlichen.</p>\n"
          ]
        }
      ]
    },
    {
      "title": "MATHE DEUTSCH 2",
      "qType": "BIG_de_2",
      "content": [
        {
          "tag_line": "Objekte",
          "qType": "SMALL_de_6",
          "details": [
            "<h2>Objekte C++</h2>\n\n<p>C++ ist nicht nur das bessere C, sondern bietet dem Entwickler die M&ouml;glichkeit, objektorientiert zu programmieren. Dies verlangt neben dem Erlernen neuer Sprachelemente auch eine neue &quot;objektorientierte&quot; Denkweise. In Form eines Tutorials soll hier mit dieser Denkweise vertraut gemacht werden.</p>\n\n<p>Herk&ouml;mmliche Softwareentwicklung bestand oftmals darin, zur L&ouml;sung eines vorgegebenen Problems Algorithmen zu entwerfen und diese in Prozeduren zu gie&szlig;en, die in einer Programmiersprache - wie zum Beispiel C - formuliert sind. Man spricht daher auch von prozeduraler Programmierung.</p>\n\n<p>Betrachtet man jedoch die reale Welt, so stellt man fest, da&szlig; die Dinge sich hier nicht in einer abstrakten prozeduralen Weise bewegen. Diesen Bruch zwischen realer Welt und Softwareentwicklung versucht der objektorientierte Ansatz zu &uuml;berwinden. Analysiert man seine materielle Umgebung, so stellt man fest, da&szlig; diese im wesentlichen aus Objekten besteht, die in verschiedener Art und Weise miteinander agieren. So k&ouml;nnte es in unserer unmittelbaren Umgebung gerade ein Objekt Fahrrad geben.</p>\n\n<p><img align=\"left\" alt=\"Objekt\" height=\"160\" src=\"https://www.kompf.de/cplus/images/art2s.gif\" width=\"165\" /> Nimmt man das Fahrrad noch weiter unter die Lupe, erkennt man, da&szlig; dieses Fahrrad bestimmte <em>Eigenschaften</em> bzw. <em>Attribute</em> (wie Farbe, Gr&ouml;&szlig;e, momentane Geschwindigkeit) besitzt und da&szlig; es <em>Methoden</em> gibt, diese Eigenschaften zu ver&auml;ndern (z.B. die Methode &quot;Tritt schneller&quot;, die zu einer Erh&ouml;hung der Geschwindigkeit f&uuml;hren wird oder die Methode &quot;Bremse&quot;, die das Gegenteil bewirken sollte).</p>\n\n<p>Transformiert man diese Erkenntnis aus der realen in die Software-Welt, so kann man formulieren:</p>\n\n<p class=\"definition\">Ein Software-Objekt ist ein B&uuml;ndel aus Attributen und darauf bezogenen Methoden.</p>\n"
          ]
        },
        {
          "tag_line": "Klassen",
          "qType": "SMALL_de_7",
          "details": [
            "<h2>Klassen C++</h2>\n\n<h3 id=\"klassen_als_bauplan\">Klassen als Bauplan</h3>\n\n<p>Wenn wir verschiedene Fahrrad-Objekte der realen Welt genauer betrachten, so stellen wir fest, da&szlig; alle diese Fahrrad-Objekte &auml;hnlich sind: Alle besitzen Bremsen, alle haben irgendeine Farbe usw. Es mu&szlig; also einen <em>Bauplan</em> geben, der beschreibt, wie ein Fahrrad grunds&auml;tzlich auszusehen hat. Alle Fahrrad-Objekte sind nach diesem Bauplan erstellt worden - deswegen ist es uns auch m&ouml;glich, ein beliebiges Fahrrad zu fahren, wenn wir einmal das Fahrradfahren gelernt haben! Wieder &uuml;bertragen wir diese Erkenntnis in die Softwarewelt:</p>\n\n<p class=\"definition\">Eine Klasse ist ein Bauplan, welcher die Attribute und Methoden definiert, die alle Objekte einer bestimmten Art besitzen.</p>\n\n<p><img align=\"left\" alt=\"class StockItem\" height=\"127\" src=\"https://www.kompf.de/cplus/images/art4.gif\" width=\"173\" /> Die Abbildung zeigt eine Klasse <tt>StockItem</tt> in der sogenannten UML (unified modelling language) Notation. Diese Klasse k&ouml;nnte in einem Programm zur Aktienanalyse verwendet werden. Ein solches Programm mu&szlig; viele verschiedene Aktien-Objekte verwalten k&ouml;nnen. Damit dies effektiv geschehen kann, sollten alle diese verschiedenen Objekte jedoch nach einem einheitlichen Bauplan - der Klassendefinition - erstellt werden.</p>\n\n<p>Der Name der Klasse steht in der UML-Notation im oberen Drittel des Rechtecks. Im mittleren Drittel stehen die Attribute. Unsere Beispielklasse <tt>StockItem</tt> definiert die zwei Attribute m_name und m_value, d.h. den Namen der Aktie und den momentanen Kurswert. Das Minuszeichen vor den Attributen bedeutet, das diese <tt class=\"keyword\">private</tt> Mitglieder der Klasse sind, d.h. von au&szlig;en kann nicht direkt auf sie zugegriffen werden.</p>\n\n<p>Im unteren Drittel stehen die Methoden der Klasse <tt>StockItem</tt>. Das Pluszeichen vor ihnen zeigt, da&szlig; sie <tt class=\"keyword\">public</tt> sind, d.h. die Methoden d&uuml;rfen von anderen Objekten aufgerufen werden. Damit zeigt sich das Prinzip der Kapselung: Anstatt auf das Attribut m_value direkt zuzugreifen, <em>m&uuml;ssen</em> andere Objekte die Zugriffsmethoden setValue() und getValue() benutzen! So hat der Entwickler der Klasse die M&ouml;glichkeit, in setValue() noch zus&auml;tzliche Abfragen, z.B. bez&uuml;glich der G&uuml;ltigkeit des Parameters, einzubauen.</p>\n\n<p>Aufmerksamen Lesern wird bei Betrachtung der Abbildung eine Erweiterung von C++ gegen&uuml;ber C nicht entgangen sein: Funktionen werden in C++ nicht nur - wie in C - durch den Namen, sondern durch Namen <em>und</em> Parameteranzahl und -typ unterschieden! So kann es die Methode setValue() zweimal geben: Einmal mit einem Parameter vom Typ <tt class=\"keyword\">double</tt> und mit einem vom Typ <tt><span class=\"keyword\">const char</span>*</tt>. Der Compiler erkennt beim Aufruf dieser Methode anhand des Parametertyps selbstt&auml;tig, welche Variante er verwenden mu&szlig;.</p>\n\n<h3 id=\"klassendefinition\">Klassendefinition</h3>\n\n<p>Es ist angebracht, C++-Klassendefinitionen generell in Headerdateien (das sind die mit der Extension .h) vorzunehmen. Guter Programmierstil ist dabei, jeweils eine Headerdatei je Klasse vorzusehen und diese auch wie die Klasse zu benennen.</p>\n\n<p>Die Klassendefinition f&uuml;r StockItem wird also in der Headerdatei mit dem Namen <b>StockItem.h</b> vorgenommen:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#ifndef StockItem_h</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#define StockItem_h 1</span>\n<span class=\"comment\">/*  3 */</span>\n<span class=\"comment\">/*  4 */</span>  <span class=\"keyword\">class</span> StockItem {\n<span class=\"comment\">/*  5 */</span>\n<span class=\"comment\">/*  6 */</span>  <span class=\"keyword\">public</span>:\n<span class=\"comment\">/*  7 */</span>      <span class=\"slashslashcomment\">// ctor</span>\n<span class=\"comment\">/*  8 */</span>      StockItem( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name = <span class=\"quotedstring\">&quot;&quot;</span>, <span class=\"keyword\">double</span> val = 0.0);\n<span class=\"comment\">/*  9 */</span>\n<span class=\"comment\">/* 10 */</span>      <span class=\"slashslashcomment\">// copy ctor</span>\n<span class=\"comment\">/* 11 */</span>      StockItem( <span class=\"keyword\">const</span> StockItem &amp;right);\n<span class=\"comment\">/* 12 */</span>      <span class=\"slashslashcomment\">// dtor</span>\n<span class=\"comment\">/* 13 */</span>      <span class=\"keyword\">virtual</span> ~StockItem();\n<span class=\"comment\">/* 14 */</span>      <span class=\"slashslashcomment\">// assignment operator</span>\n<span class=\"comment\">/* 15 */</span>      <span class=\"keyword\">const</span> StockItem&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItem &amp;right);\n<span class=\"comment\">/* 16 */</span>\n<span class=\"comment\">/* 17 */</span>      <span class=\"slashslashcomment\">// public member functions</span>\n<span class=\"comment\">/* 18 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* getName() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 19 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setValue( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 20 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setValue( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* val);\n<span class=\"comment\">/* 21 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getValue() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 22 */</span>\n<span class=\"comment\">/* 23 */</span>  <span class=\"keyword\">private</span>:\n<span class=\"comment\">/* 24 */</span>      <span class=\"slashslashcomment\">// private member variables</span>\n<span class=\"comment\">/* 25 */</span>      <span class=\"keyword\">char</span> *m_name;\n<span class=\"comment\">/* 26 */</span>      <span class=\"keyword\">double</span> m_value;\n<span class=\"comment\">/* 27 */</span>  };\n<span class=\"comment\">/* 28 */</span>\n<span class=\"comment\">/* 29 */</span>  <span class=\"preprocessor\">#endif </span>\n</pre>\n\n<p>Die Klassendefinition beginnt mit dem Schl&uuml;sselwort <tt class=\"keyword\">class</tt> gefolgt vom Namen der Klasse (Zeile 4). Die eigentliche Definition wird von geschweiften Klammern { } umschlossen. Die Schl&uuml;sselw&ouml;rter <tt class=\"keyword\">public</tt> und <tt class=\"keyword\">private</tt> trennen die im letzten Abschnitt besprochenen &ouml;ffentlichen (Zeilen 7 bis 21) und privaten (Zeilen 24 bis 26) Bereiche der Definition ab. Es gibt au&szlig;erdem noch die M&ouml;glichkeit, mittels <tt class=\"keyword\">protected</tt> Variablen und Methoden zu deklarieren, die ausschlie&szlig;lich abgeleiteten Klassen zur Verf&uuml;gung stehen sollen. Dazu mehr sp&auml;ter mehr beim Thema <em>Vererbung</em>.</p>\n\n<p>Die Deklaration der &ouml;ffentlichen Methoden (Zeilen 18 bis 19) und der privaten Variablen (Zeilen 25 und 26) erfolgt genauso wie eine normale Deklaration von Funktionen bzw. Variablen in C. Bei den Funktionen f&auml;llt die Verwendung der Spezifikation <tt class=\"keyword\">virtual</tt> auf. Dies ist wiederum f&uuml;r das Thema <em>Vererbung</em> wichtig und wird sp&auml;ter besprochen. Man macht jedoch nicht viel verkehrt, wenn man direkt jeder Funktion von vorneherein diese Spezifikation verpa&szlig;t.</p>\n\n<p>Auf den Zeilen 7 bis 15 werden <em>Constructor</em>, <em>Copy-Constructor</em>, <em>Destructor</em> und <em>Assignment Operator</em> deklariert. Um den Sinn dieser Elemente verstehen zu k&ouml;nnen, m&uuml;ssen wir zun&auml;chst auf den <em>Objektlebenszyklus</em> eingehen</p>\n\n<p><em>PS: Noch ein kleiner Tip: Der Compiler produziert die wunderlichsten Fehlermeldungen, wenn der Programmierer das Semikolon am Ende der Klassendefinition (Zeile 27) vergi&szlig;t...</em></p>\n"
          ]
        },
        {
          "tag_line": "Objektlebenszyklus",
          "qType": "SMALL_de_8",
          "details": [
            "<h2>Objektlebenszyklus C++</h2>\n\n<p>Der Lebenszyklus eines C++-Objektes besteht aus den Abschnitten</p>\n\n<ol>\n\t<li>Erzeugung</li>\n\t<li>Benutzung</li>\n\t<li>Zerst&ouml;rung</li>\n</ol>\n\n<h3 id=\"erzeugen_eines_objektes\">Erzeugen eines Objektes</h3>\n\n<p>Das Erzeugen eines Objektes erfogt durch Aufruf des <em>Konstruktors</em> (kurz <em>ctor</em>) des Objektes. Dies kann sowohl statisch durch Variablendeklaration als auch dynamisch mittels des <tt class=\"keyword\">new</tt> Operators geschehen:</p>\n\n<pre class=\"cplus\">\nStockItem bay;\n<span class=\"slashslashcomment\">// default constructor, statisch</span>\n\nStockItem dte( <span class=\"quotedstring\">&quot;Deutsche Telekom AG&quot;</span>, 50.34);\n<span class=\"slashslashcomment\">// spezieller ctor, statisch</span>\n\nStockItem *bas = <span class=\"keyword\">new</span> StockItem( <span class=\"quotedstring\">&quot;BASF&quot;</span>, 120.34);\n<span class=\"slashslashcomment\">// spezieller ctor, dynamisch </span>\n<span class=\"slashslashcomment\">// der f&uuml;r bas n&ouml;tige Speicherplatz wird auf dem Heap alloziert</span>\n</pre>\n\n<h3 id=\"benutzen_eines_objektes\">Benutzen eines Objektes</h3>\n\n<p>Ein Objekt wird benutzt, indem eine seiner Methoden aufgerufen wird:</p>\n\n<pre class=\"cplus\">\ndte.setValue( 52.80);\n<span class=\"slashslashcomment\">// ruft Methode StockItem::setValue() des Objektes dte auf</span>\n\na = bas-&gt;getValue();\n<span class=\"slashslashcomment\">// ruft Methode StockItem::getValue() des Objektes bas auf </span>\n</pre>\n\n<p>Au&szlig;erdem kann das komplette Objekt als Parameter an eine Funktion &uuml;bergeben oder von dieser per <tt class=\"keyword\">return</tt> zur&uuml;ckgegeben werden. Erfolgt die Wert&uuml;bergabe dabei <em>per Value</em>, so wird implizit der <em>Copy Konstruktor</em> des Objektes aufgerufen:</p>\n\n<pre class=\"cplus\">\nStockItem cnv( StockItem x) {\n    <span class=\"slashslashcomment\">// ...</span>\n\n    <span class=\"keyword\">return</span> x2;\n    <span class=\"slashslashcomment\">// return per value: ruft den Copy Constructor von x2 auf</span>\n}\n\nStockItem bas( <span class=\"quotedstring\">&quot;BASF&quot;</span>, 120.34);\ncnv( bas);\n<span class=\"slashslashcomment\">// parameter per value: ruft den Copy Constructor von bas auf</span>\n\nStockItem bas2 = bas;\n<span class=\"slashslashcomment\">// explizite Kopie: ruft den Copy Constructor von bas2 auf </span>\n</pre>\n\n<p>Ebenso kann ein Objekt komplett einem anderen bereits existierenden Objekt zugewiesen werden, wenn dieses den gleichen Typ oder den Typ einer Basisklasse hat. Dann wird der <em>Assignment Operator</em> des Objektes aufgerufen:</p>\n\n<pre class=\"cplus\">\nStockItem x;\nStockItem y( <span class=\"quotedstring\">&quot;ABC&quot;</span>, 22);\n\nx = y;\n<span class=\"slashslashcomment\">// ruft den Assignment Operator von x auf</span>\n</pre>\n\n<h3 id=\"zerst\">Zerst&ouml;ren eines Objektes</h3>\n\n<p>Wird ein Objekt nicht mehr ben&ouml;tigt, so sollte es zerst&ouml;rt werden, damit es keinen Speicherplatz mehr verbraucht. Bei der Zerst&ouml;rung eines Objektes wird automatisch sein <em>Destruktor</em> (kurz <em>dtor</em>) aufgerufen. Im Falle eines dynamisch per <tt class=\"keyword\">new</tt> erzeugten Objektes wird dies mit dem Operator <tt class=\"keyword\">delete</tt> bewerkstelligt. Ein statisch erzeugtes Objekt wird automatisch zerst&ouml;rt, wenn bei der Programmausf&uuml;hrung der G&uuml;ltigkeitsbereich der statischen Deklaration verlassen wird:</p>\n\n<pre class=\"cplus\">\n<span class=\"keyword\">delete</span> bas;\n<span class=\"slashslashcomment\">// der Destructor des Objektes bas wird aufgerufen und anschlie&szlig;end</span>\n<span class=\"slashslashcomment\">// der durch bas belegte Speicherplatz freigegeben</span>\n<span class=\"keyword\">if</span> (x) {\n    StockItem bmw;\n    <span class=\"slashslashcomment\">// ...</span>\n} <span class=\"slashslashcomment\">// der dtor des statisch angelegten Objektes bmw wird hier am Blockende</span>\n<span class=\"slashslashcomment\">// wegen des Verlassens des G&uuml;ltigkeitsbereiches der Deklaration aufgerufen</span>\n</pre>\n\n<p><strong>Beachte:</strong>Der Destruktor eines Objektes wird in der Regel niemals direkt aufgerufen, sondern sein Aufruf erfolgt wie oben dargestellt implizit durch Verwendung von <tt class=\"Keyword\">delete</tt> oder beim Verlassen des G&uuml;ltigkeitsbereiches!</p>\n\n<h2 id=\"objektimplementierung\">Objektimplementierung</h2>\n\n<p>Was uns nun noch zum ersten vollst&auml;ndigen C++-Programm fehlt, ist die Implementierung der einzelnen Methoden des Objektes StockItem.</p>\n\n<p>Die Implementierung wird vorzugsweise in einer Datei mit Namen <b>StockItem.cpp</b> vorgenommen. Zu Beginn wird die Headerdatei <b>StockItem.h</b> inkludiert:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#include &quot;StockItem.h&quot;</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#include &lt;cstdlib&gt;</span>\n<span class=\"comment\">/*  3 */</span>  <span class=\"preprocessor\">#include &lt;cstring&gt;</span>\n<span class=\"comment\">/*  4 */</span> \n<span class=\"comment\">/*  5 */</span>  StockItem::StockItem( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name <span class=\"comment\">/* = &quot;&quot; */</span>, <span class=\"keyword\">double</span> val <span class=\"comment\">/* = 0.0 */</span>)\n<span class=\"comment\">/*  6 */</span>  {\n<span class=\"comment\">/*  7 */</span>      m_name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[strlen(name)+1];\n<span class=\"comment\">/*  8 */</span>      strcpy( m_name, name);\n<span class=\"comment\">/*  9 */</span>      m_value = val;\n<span class=\"comment\">/* 10 */</span>  }\n<span class=\"comment\">/* 11 */</span>\n<span class=\"comment\">/* 12 */</span>  StockItem::StockItem( <span class=\"keyword\">const</span> StockItem &amp;right)\n<span class=\"comment\">/* 13 */</span>\n<span class=\"comment\">/* 14 */</span>  {\n<span class=\"comment\">/* 15 */</span>\n<span class=\"comment\">/* 16 */</span>      m_name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[strlen( right.m_name)+1];\n<span class=\"comment\">/* 17 */</span>      strcpy( m_name, right.m_name);\n<span class=\"comment\">/* 18 */</span>      m_value = right.m_value;\n<span class=\"comment\">/* 19 */</span>  }\n<span class=\"comment\">/* 20 */</span>\n<span class=\"comment\">/* 21 */</span>  StockItem::~StockItem()\n<span class=\"comment\">/* 22 */</span>  {\n<span class=\"comment\">/* 23 */</span>      <span class=\"keyword\">delete</span>[] m_name;\n<span class=\"comment\">/* 24 */</span>  }\n<span class=\"comment\">/* 25 */</span>\n<span class=\"comment\">/* 26 */</span>  <span class=\"keyword\">const</span> StockItem&amp; StockItem::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItem &amp;right)\n<span class=\"comment\">/* 27 */</span>  {\n<span class=\"comment\">/* 28 */</span>      <span class=\"slashslashcomment\">// handle self assignment</span>\n<span class=\"comment\">/* 29 */</span>      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;right) {\n<span class=\"comment\">/* 30 */</span>          <span class=\"keyword\">delete</span>[] m_name;\n<span class=\"comment\">/* 31 */</span>          m_name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[strlen( right.m_name)+1];\n<span class=\"comment\">/* 32 */</span>          strcpy( m_name, right.m_name);\n<span class=\"comment\">/* 33 */</span>          m_value = right.m_value;\n<span class=\"comment\">/* 34 */</span>      }\n<span class=\"comment\">/* 35 */</span>\n<span class=\"comment\">/* 36 */</span>      <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;\n<span class=\"comment\">/* 37 */</span>  }\n<span class=\"comment\">/* 38 */</span>\n<span class=\"comment\">/* 39 */</span>  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* StockItem::getName() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 40 */</span>  {\n<span class=\"comment\">/* 41 */</span>      <span class=\"keyword\">return</span> m_name;\n<span class=\"comment\">/* 42 */</span>  }\n<span class=\"comment\">/* 43 */</span>\n<span class=\"comment\">/* 44 */</span>  <span class=\"keyword\">void</span> StockItem::setValue( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 45 */</span>  {\n<span class=\"comment\">/* 46 */</span>      m_value = val;\n<span class=\"comment\">/* 47 */</span>  }\n<span class=\"comment\">/* 48 */</span>\n<span class=\"comment\">/* 49 */</span>  <span class=\"keyword\">void</span> StockItem::setValue( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* val)\n<span class=\"comment\">/* 50 */</span>  {\n<span class=\"comment\">/* 51 */</span>      m_value = atof( val);\n<span class=\"comment\">/* 52 */</span>  }\n<span class=\"comment\">/* 53 */</span>\n<span class=\"comment\">/* 54 */</span>  <span class=\"keyword\">double</span> StockItem::getValue() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 55 */</span>  {\n<span class=\"comment\">/* 56 */</span>      <span class=\"keyword\">return</span> m_value;\n<span class=\"comment\">/* 57 */</span>  } \n</pre>\n\n<p>Die Implementierung der &ouml;ffentlichen Methoden f&uuml;r das Setzen und Auslesen der Werte der Attribute in den Zeilen 39 bis 57 enth&auml;lt nichts besonderes, der Code d&uuml;rfte f&uuml;r sich sprechen.</p>\n\n<p>Interessanter ist der Konstruktor (Zeilen 5 bis 10): Da wir den Namen des <tt>StockItem</tt> in einer C-Zeichenkette vom Typ <tt><span class=\"keyword\">char</span>*</tt> speichern wollen, mu&szlig; zuerst der hierf&uuml;r notwendige Speicherplatz allokiert werden (Zeile 7). Da wir in C++ programmieren, verwenden wir nicht das aus der C-Welt vertraute <tt>malloc</tt>, sondern den C++-Operator <tt><span class=\"keyword\">new</span>[]</tt>.</p>\n\n<p>&Auml;hnlich verh&auml;lt sich die Sache beim Copy Konstruktor (Zeilen 12 bis 19): Hier ist das einzige Argument immer eine Referenz auf ein Objekt des gleichen Typs. Dessen Membervariablen m&uuml;ssen in die eigenen Variablen <em>kopiert</em> werden, damit eine 1:1 Kopie des Objektes entsteht. Wir erinnern uns: Der Copy Konstruktor wird bei &Uuml;bergabe von Objekten per Value an oder aus Funktionen oder beim expliziten Kopieren verwendet.</p>\n\n<p>Noch interessanter gestaltet sich die Sache beim Assignment Operator (Zeilen 26 bis 37): Hier existiert ja schon ein Objekt x, in das ein zweites Objekt y hineinkopiert wird! Also mu&szlig; <em>zuerst</em> der von x belegte Speicherplatz freigegeben werden (Zeile 30), bevor die Variablen kopiert werden k&ouml;nnen. In der C++-Sprache bezeichnet man &uuml;brigens unser Objekt x als <tt class=\"keyword\">this</tt>. Der Bezug auf das eigene Objekt <tt class=\"keyword\">this</tt> ist so wichtig, da&szlig; <tt class=\"keyword\">this</tt> sogar ein reserviertes Wort in C++ ist und immer innerhalb von Objektfunktionen zur Verf&uuml;gung steht. Der Assignment Operator gibt einen Zeiger auf das Objekt selbst (also auf <tt class=\"keyword\">this</tt>) zur&uuml;ck, schlie&szlig;lich wird er ja in Zuweisungen wie</p>\n\n<pre class=\"cplus\">\nStockItem x;\nStockItem y( <span class=\"quotedstring\">&quot;ABC&quot;</span>, 22);\n\nx = y;\n</pre>\n\n<p>verwendet.</p>\n\n<p>&Uuml;brigens hindert niemand den Programmierer, statt x = y die Zuweisung x = x hinzuschreiben! Dann haben wir den Fall des <em>Self Assignments</em> vorliegen: Ein Objekt wird sich selbst zugewiesen. Dann darf der Assignment Operator auch nichts weiter tun. Die Abfrage, ob Self Assignment vorliegt, findet in Zeile 29 statt.</p>\n\n<p>Der mittels <tt><span class=\"keyword\">new</span>[]</tt> vom Betriebssystem w&auml;hrend der Objektkonstruktion explizit angeforderte Speicherplatz mu&szlig; beim Zerst&ouml;ren des Objektes auch wieder ausdr&uuml;cklich freigegeben werden. Wir erinnern uns: Beim Zerst&ouml;ren des Objektes wird automatisch sein Destruktor ausgef&uuml;hrt. Deswegen wird im Destruktor (Zeilen 21 bis 24) der f&uuml;r m_name angeforderte Speicherbereich mittels <tt><span class=\"keyword\">delete</span>[]</tt> freigegeben.</p>\n"
          ]
        },
        {
          "tag_line": "Vererbung",
          "qType": "SMALL_de_9",
          "details": [
            "<h2>Vererbung C++</h2>\n\n<h3 id=\"konzept\">Konzept</h3>\n\n<p>Vererbung erlaubt die Definition neuer Klassen auf der Basis von bestehenden Klassen. Dies ist ein grundlegendes Konzept objektorientierten Designs. <img align=\"left\" alt=\"Vererbung\" height=\"107\" src=\"https://www.kompf.de/cplus/images/c++-part6.gif\" width=\"173\" /> Weiter oben wurde der Begriff der <em>Klasse</em> als eine Art Bauplan f&uuml;r Objekte erkl&auml;rt. Anhand des dort verwendeten Beispiels &quot;Fahrrad&quot; lassen sich weitere Parallelen zur realen Welt ziehen: Es f&auml;llt auf, da&szlig; es hier <em>verschiedene Arten</em> von Fahrr&auml;dern gibt: Rennr&auml;der, Montainbikes, Treckingr&auml;der und das gute alte Hollandrad. Warum sind alle diese verschiedenen R&auml;der f&uuml;r uns als F&auml;hrr&auml;der erkennbar? Weil sie gewisse gemeinsame Eigenschaften haben: Alle haben zwei R&auml;der, einen Lenker und lassen sich durch Tritt auf die Pedale fortbewegen. Zus&auml;tzlich zu diesen Gemeinsamkeiten bringen sie aber auch neue Eigenschaften ein: Montainbikes und Rennr&auml;der haben jeweils eine Gangschaltung, unterscheiden sich aber durch die Art der Bereifung.</p>\n\n<p>In objektorientierter Sprache k&ouml;nnte man also sagen: Die Klassen Montainbikes, Rennr&auml;der und Hollandr&auml;der <em>erben</em> von der Klasse Fahrr&auml;der gemeinsame Eigenschaften und f&uuml;gen zus&auml;tzliche hinzu. Allgemein gilt:</p>\n\n<ul>\n\t<li>Klassen k&ouml;nnen definiert werden in Abh&auml;ngigkeit von anderen Klassen: &quot;A ist eine Art von B&quot;. In diesem Fall ist B die <em>Basisklasse</em> von A.</li>\n\t<li>Eine Klasse kann auch von mehreren Klassen erben: A ist eine Art von B und C (Mehrfachvererbung).</li>\n\t<li>Jede Klasse erbt die (&ouml;ffentlichen) Attribute und Methoden ihrer Basisklasse(n).</li>\n\t<li>Jedoch kann jede Klasse eigene Variablen und Methoden hinzuf&uuml;gen.</li>\n</ul>\n\n<p>Es ist wichtig zu verstehen, da&szlig; Vererbung nur in eine Richtung l&auml;uft: Ein Rennrad ist zwar immer auch ein Fahrrad, aber nicht jedes Fahrrad ist automatisch ein Rennrad. Wenn in C++ ein Objekt a der Klasse A definiert wird und die Klasse A von B abgeleitet ist, dann kann a jederzeit per Cast in ein Objekt vom Typ B umgewandelt werden. Die Umkehrung gilt nicht: Ein Objekt b der Klasse B kann in diesem Fall nicht in den Typ A umgewandelt werden!</p>\n\n<h3 id=\"vererbung_in_c__\">Vererbung in C++</h3>\n\n<p>Die von uns bereits definierte und benutzte Klasse <em>StockItem</em> erlaubt die Speicherung eines Namens und eines dazugeh&ouml;renden Wertes und ist zur Darstellung von Aktienkursen gedacht. Wer sich mit dieser Materie schon besch&auml;ftigt hat, der wei&szlig;, da&szlig; zu einer Aktie noch viele Informationen mehr gespeichert werden k&ouml;nnen. So gibt es neben dem (Tages- oder Wochen-)Schlusskurs (<em>Close</em>) noch Er&ouml;ffnungs- (<em>Open</em>), H&ouml;chst- (<em>High</em>) und Tiefstkurs (<em>Low</em>). Wir wollen daher nun StockItem um die M&ouml;glichkeit erweitern, zus&auml;tzlich auch den Er&ouml;ffnungskurs abfragen und setzen zu k&ouml;nnen.</p>\n\n<p>Diese Erweiterung soll jedoch nicht durch Ver&auml;ndern der existierenden Klasse StockItem erfolgen - diese Klasse wird bereits in vielen Softwareprojekten benutzt und eine &Auml;nderung ihrer Funktionalit&auml;t k&ouml;nnte unter Umst&auml;nden b&ouml;se Auswirkungen haben. Auch wollen wir das Rad nicht v&ouml;llig neu erfinden - vorhandener Code soll so weit wie m&ouml;glich wiederverwendet werden. Dies alles erreichen wir dadurch, da&szlig; wir eine neue Klasse <em>StockItemOC</em> definieren, die von der vorhandenen Klasse StockItem <em>abgeleitet</em> ist:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#ifndef StockItemOC_h</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#define StockItemOC_h 1</span>\n<span class=\"comment\">/*  3 */</span>\n<span class=\"comment\">/*  4 */</span>  <span class=\"keyword\">class</span> StockItemOC : <span class=\"keyword\">public</span> StockItem {\n<span class=\"comment\">/*  5 */</span>\n<span class=\"comment\">/*  6 */</span>  <span class=\"keyword\">public</span>:\n<span class=\"comment\">/*  7 */</span>      <span class=\"slashslashcomment\">// ctor</span>\n<span class=\"comment\">/*  8 */</span>      StockItemOC( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name = <span class=\"quotedstring\">&quot;&quot;</span>, <span class=\"keyword\">double</span> open = 0.0, <span class=\"keyword\">double</span> close = 0.0);\n<span class=\"comment\">/*  9 */</span>\n<span class=\"comment\">/* 10 */</span>      <span class=\"slashslashcomment\">// copy ctor</span>\n<span class=\"comment\">/* 11 */</span>      StockItemOC( <span class=\"keyword\">const</span> StockItemOC &amp;right);\n<span class=\"comment\">/* 12 */</span>      <span class=\"slashslashcomment\">// dtor</span>\n<span class=\"comment\">/* 13 */</span>      <span class=\"keyword\">virtual</span> ~StockItemOC();\n<span class=\"comment\">/* 14 */</span>      <span class=\"slashslashcomment\">// assignment operator</span>\n<span class=\"comment\">/* 15 */</span>      <span class=\"keyword\">const</span> StockItemOC&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItemOC &amp;right);\n<span class=\"comment\">/* 16 */</span>\n<span class=\"comment\">/* 17 */</span>      <span class=\"slashslashcomment\">// public member functions</span>\n<span class=\"comment\">/* 18 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setValue( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 19 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getValue() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 20 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setOpen( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 21 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getOpen() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 22 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setClose( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 23 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getClose() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 24 */</span>\n<span class=\"comment\">/* 25 */</span>  <span class=\"keyword\">private</span>:\n<span class=\"comment\">/* 26 */</span>      <span class=\"slashslashcomment\">// private member variables</span>\n<span class=\"comment\">/* 27 */</span>      <span class=\"keyword\">double</span> m_open;\n<span class=\"comment\">/* 28 */</span>      <span class=\"keyword\">double</span> m_close;\n<span class=\"comment\">/* 29 */</span>  };\n<span class=\"comment\">/* 30 */</span>\n<span class=\"comment\">/* 31 */</span>  <span class=\"preprocessor\">#endif</span>\n</pre>\n\n<p>Die einzige Erweiterung gegen&uuml;ber der uns bekannten Klassendefinition ist, da&szlig; zu Beginn in Zeile 4 die Basisklasse nach dem Doppelpunkt und dem Schl&uuml;sselwort <tt class=\"keyword\">public</tt> angegeben wird.</p>\n\n<p>Welche Auswirkung hat diese Vererbungsbeziehung nun auf das Verhalten unserer neuen Klasse StockItemOC? Schauen wir uns dazu das UML-Diagramm an: <img align=\"left\" alt=\"class StockItemOC\" height=\"291\" src=\"https://www.kompf.de/cplus/images/c++-part7.gif\" width=\"173\" /></p>\n\n<ul>\n\t<li>StockItemOC <em>erbt</em> die Methode getName() von StockItem. Diese Methode braucht also nicht noch einmal implementiert zu werden.</li>\n\t<li>StockItemOC <em>&uuml;berschreibt</em> die Methoden setValue() und getValue() von StockItem. Diese Methoden m&uuml;ssen anders implementiert sein, da StockItemOC ja zwei Kurswerte statt einem zur Auswahl hat.</li>\n\t<li>StockItemOC hat die <em>zus&auml;tzlichen</em> Methoden getOpen(), setOpen(), getClose() und setClose(), um die zus&auml;tzliche gew&uuml;nschte Funktionalit&auml;t abbilden zu k&ouml;nnen.</li>\n\t<li>StockItemOC <em>erbt</em> die Variablen m_name und m_value von StockItem. Da diese Variablen dort aber als <em>private</em> deklariert sind, haben die Methoden von StockItemOC keinen Zugriff auf diese Variable - au&szlig;er nat&uuml;rlich getName(), denn diese ist ja auch von StockItem geerbt.</li>\n\t<li>StockItemOC deklariert die <em>zus&auml;tzlichen</em> privaten Variablen m_open und m_close.</li>\n</ul>\n\n<h3 id=\"implementierung_der_abgeleiteten_klasse\">Implementierung der abgeleiteten Klasse</h3>\n\n<p>Zun&auml;chst wollen wir einen Blick auf die Implementierung der abgeleiteten Klasse in <b>StockItemOC.cpp</b> werfen:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#include &lt;cstdlib&gt;</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#include &quot;StockItem.h&quot;</span>\n<span class=\"comment\">/*  3 */</span>  <span class=\"preprocessor\">#include &quot;StockItemOC.h&quot;</span>\n<span class=\"comment\">/*  4 */</span>\n<span class=\"comment\">/*  5 */</span>  StockItemOC::StockItemOC( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">double</span> open, <span class=\"keyword\">double</span> close)\n<span class=\"comment\">/*  6 */</span>   : StockItem(name), m_open(open), m_close(close)\n<span class=\"comment\">/*  7 */</span>  { }\n<span class=\"comment\">/*  8 */</span>\n<span class=\"comment\">/*  9 */</span>  StockItemOC::StockItemOC( <span class=\"keyword\">const</span> StockItemOC &amp;right)\n<span class=\"comment\">/* 10 */</span>   : StockItem(right), m_open(right.m_open), m_close(right.m_close)\n<span class=\"comment\">/* 11 */</span>  { }\n<span class=\"comment\">/* 12 */</span>\n<span class=\"comment\">/* 13 */</span>  StockItemOC::~StockItemOC()\n<span class=\"comment\">/* 14 */</span>  { }\n<span class=\"comment\">/* 15 */</span>\n<span class=\"comment\">/* 16 */</span>  <span class=\"keyword\">const</span> StockItemOC&amp; StockItemOC::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItemOC &amp;right)\n<span class=\"comment\">/* 17 */</span>  {\n<span class=\"comment\">/* 18 */</span>      <span class=\"slashslashcomment\">// handle self assignment</span>\n<span class=\"comment\">/* 19 */</span>      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;right) {\n<span class=\"comment\">/* 20 */</span>          StockItem::<span class=\"keyword\">operator</span>=(right);\n<span class=\"comment\">/* 21 */</span>          m_open = right.m_open;\n<span class=\"comment\">/* 22 */</span>          m_close = right.m_close;\n<span class=\"comment\">/* 23 */</span>      }\n<span class=\"comment\">/* 24 */</span>\n<span class=\"comment\">/* 25 */</span>      <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;\n<span class=\"comment\">/* 26 */</span>  }\n<span class=\"comment\">/* 27 */</span>\n<span class=\"comment\">/* 28 */</span>  <span class=\"keyword\">void</span> StockItemOC::setValue( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 29 */</span>  {\n<span class=\"comment\">/* 30 */</span>      m_close = val;\n<span class=\"comment\">/* 31 */</span>  }\n<span class=\"comment\">/* 32 */</span>\n<span class=\"comment\">/* 33 */</span>  <span class=\"keyword\">double</span> StockItemOC::getValue() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 34 */</span>  {\n<span class=\"comment\">/* 35 */</span>      <span class=\"keyword\">return</span> m_close;\n<span class=\"comment\">/* 36 */</span>  }\n<span class=\"comment\">/* 37 */</span>\n<span class=\"comment\">/* 38 */</span>  <span class=\"keyword\">void</span> StockItemOC::setOpen( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 39 */</span>  {\n<span class=\"comment\">/* 40 */</span>      m_open = val;\n<span class=\"comment\">/* 41 */</span>  }\n<span class=\"comment\">/* 42 */</span>\n<span class=\"comment\">/* 43 */</span>  <span class=\"keyword\">double</span> StockItemOC::getOpen() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 44 */</span>  {\n<span class=\"comment\">/* 45 */</span>      <span class=\"keyword\">return</span> m_open;\n<span class=\"comment\">/* 46 */</span>  }\n<span class=\"comment\">/* 47 */</span>\n<span class=\"comment\">/* 48 */</span>  <span class=\"keyword\">void</span> StockItemOC::setClose( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 49 */</span>  {\n<span class=\"comment\">/* 50 */</span>      m_close = val;\n<span class=\"comment\">/* 51 */</span>  }\n<span class=\"comment\">/* 52 */</span>\n<span class=\"comment\">/* 53 */</span>  <span class=\"keyword\">double</span> StockItemOC::getClose() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 54 */</span>  {\n<span class=\"comment\">/* 55 */</span>      <span class=\"keyword\">return</span> m_close;\n<span class=\"comment\">/* 56 */</span>  }\n</pre>\n\n<p>Interessant ist hier zun&auml;chst wieder der Konstruktor (Zeilen 5 bis 7): Im Gegensatz zum Konstruktor von StockItem weiter oben erfolgt die Initialisierung der Variablen (m_open und m_close) hier nicht im Funktionsrumpf, sondern in einer <em>Initialisierungsliste</em>. Dies schafft vor allem Performancevorteile bei der Konstruktion der Objekte. Ferner m&uuml;ssen wir bedenken, da&szlig; die in der Basisklasse als privat deklarierten Variablen (wie m_name) hier nicht direkt angesprochen werden k&ouml;nnen. Um diese trotzdem korrekt zu initialisieren, wird der Konstruktor der Basisklasse in der Initialisierungsliste aufgerufen (Zeile 6).</p>\n\n<p>Gleiches gilt f&uuml;r den Copy Konstruktor (Zeilen 9 bis 11), der den Copy Konstruktor der Basisklasse in seiner Initialisierungsliste auff&uuml;hrt. Und auch der Assignment Operator muss den der Basisklasse explizit aufrufen (Zeile 20). Lediglich beim Destruktor (Zeilen 13 und 14) ist das Verhalten anders. Hier stellt die C++ Laufzeitumgebung sicher, da&szlig; alle Destruktoren voneinander abgeleiteter Klassen in der richtigen Reihenfolge aufgerufen werden. Da in StockItemOC kein dynamisch allozierter Speicher verwendet wird, braucht der Destruktor auch nichts weiter zu tun.</p>\n\n<p>Die restlichen Methoden von StockItemOC dienen dem Setzen und Auslesen der privaten Variablen und bieten nichts Neues.</p>\n\n<h3 id=\"verwendung_abgeleiteter_klassen\">Verwendung abgeleiteter Klassen</h3>\n\n<p>Die Verwendung von abgeleiteten Klassen soll nun anhand der Klasse StockItemOC in einem kleinen Testprogramm demonstriert werden.</p>\n\n<p>Am Anfang der Programmdatei m&uuml;ssen die ben&ouml;tigten Headerfiles inkludiert werden:</p>\n\n<pre class=\"cplus\">\n<span class=\"preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"preprocessor\">#include &lt;vector&gt;</span>\n<span class=\"preprocessor\">#include &lt;algorithm&gt;</span>\n<span class=\"preprocessor\">#include &lt;iterator&gt;</span>\n<span class=\"preprocessor\">#include &quot;StockItem.h&quot;</span>\n<span class=\"preprocessor\">#include &quot;StockItemOC.h&quot;</span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> main( <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)\n{\n</pre>\n\n<p>Als erste &Uuml;bung werden wir zwei StockItem Objekte und ein StockItemOC Objekt statisch anlegen und diese dann zur Ausgabe einiger Werte benutzen:</p>\n\n<pre class=\"cplus\">\n    StockItem a( <span class=\"quotedstring\">&quot;BAY&quot;</span>, 34.9);\n    StockItem b( <span class=\"quotedstring\">&quot;BAS&quot;</span>);\n    StockItemOC c( <span class=\"quotedstring\">&quot;DTE&quot;</span>, 57.0, 59.4);\n\n    b.setValue( 24.2);\n\n    cout &lt;&lt; a.getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; a.getValue() &lt;&lt; endl;\n    cout &lt;&lt; b.getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; b.getValue() &lt;&lt; endl;\n    cout &lt;&lt; c.getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; c.getValue() &lt;&lt; <span class=\"quotedstring\">&quot; (&quot;</span>\n         &lt;&lt; c.getOpen() &lt;&lt; <span class=\"quotedstring\">&quot; -&gt; &quot;</span> &lt;&lt; c.getClose() &lt;&lt; <span class=\"quotedstring\">&quot;)\\n&quot;</span>;\n</pre>\n\n<p>Dies bietet auf den ersten Blick nichts neues. Beim zweiten Hinsehen erkennen wir, da&szlig; in der letzten Zeile die Methode getName() des Objektes c, welches vom Typ StockItemOC ist, aufgerufen wird. Die Klasse StockItemOC hat aber gar keine Methode getName() definiert! Mit dem neu erworbenen Wissen &uuml;ber Vererbung ist jedoch klar, was passiert: Es wird einfach die von der Klasse StockItem <em>geerbte</em> Methode verwendet!</p>\n\n<p>Interessant ist auch die Verwendung der Methode getValue(). Diese gibt es sowohl in StockItem als auch in StockItemOC. In diesem Beispiel ist jedoch relativ einfach zu verstehen, was passiert - sowohl f&uuml;r uns als auch f&uuml;r den C++-Compiler: In der letzten Zeile wird StockItemOC::getValue() aufgerufen, in den beiden Zeilen davor StockItem::getValue(). Das ist deshalb klar, weil der Typ der Objekte a, b und c bereits zur &Uuml;bersetzungszeit bekannt ist und der Compiler entscheiden kann, welchen Methodenaufruf er verwenden mu&szlig;. Dies wird auch als <em>statische</em> oder <em>fr&uuml;he Bindung</em> bezeichnet.</p>\n\n<p>Was passiert jedoch, wenn der Compiler beim &Uuml;bersetzen den genauen Typ des Objektes noch nicht kennt? Sehen wir uns die Fortsetzung des Programmes an:</p>\n\n<pre class=\"cplus\">\n    StockItem *astocks[3];\n    astocks[0] = &amp;a;\n    astocks[1] = &amp;b;\n    astocks[2] = &amp;c;      <span class=\"slashslashcomment\">// cast from StockItemOC* to StockItem*</span>\n    \n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = 0; i &lt; 3; ++i) {\n        cout &lt;&lt; astocks[i]-&gt;getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; astocks[i]-&gt;getValue() &lt;&lt; endl;\n    }\n</pre>\n\n<p>Beim Aufruf astocks[i]-&gt;getValue() mu&szlig; je nachdem, ob der in astocks stehende Pointer auf ein Objekt vom Typ StockItem (bei Index 0 und 1) oder vom Typ StockItemOC (Index 2) zeigt, eine andere Methode aufgerufen werden. Dies kann erst zur Laufzeit entschieden werden, man spricht dann von <em>dynamischer</em> oder <em>sp&auml;ter Bindung</em>. Wie kann nun aber das Laufzeitsystem entscheiden, welchen Typ das Objekt hat? Der Schl&uuml;ssel hierzu ist die sogenannte vtable, in der die spezifischen Funktionssignaturen f&uuml;r jedes Objekt abgelegt sind. Eine Funktionssignatur wird jedoch nur dann richtig in die vtable eingetragen, wenn die Funktionen in der Klassendefinitionen als <tt class=\"keyword\">virtual</tt> deklariert sind. Dies haben wir zum Gl&uuml;ck in unseren Definitionen schon getan, so da&szlig; das Programm wie erwartet arbeitet. Folgende Regel sollte man sich beim Umgang mit C++ jedoch verinnerlichen:</p>\n\n<p class=\"definition\">Deklariere alle Memberfunktionen - inklusive des Destruktors - als virtual, wenn Du die Absicht hast, Vererbungsmechanismen zu verwenden!</p>\n\n<p>Zum Schlu&szlig; noch eine fortgeschrittene Anwendung unserer Objekte. Statt in ein Array werden sie in einen STL-Vektor gepackt. Anschlie&szlig;end werden die Objekte nach ihrem Wert (getValue()) sortiert und ausgegeben. Das alles funktioniert auch dann, wenn der Vektor sowohl Objekte vom Typ StockItem* als auch StockItemOC* enth&auml;lt, weil wieder dynamische Bindung zum Einsatz kommt:</p>\n\n<pre class=\"cplus\">\n    <span class=\"slashslashcomment\">// get the stock items odered by price</span>\n    vector&lt;StockItem*&gt; stocks;\n\n    stocks.push_back(&amp;a);\n    stocks.push_back(&amp;b);\n    stocks.push_back(&amp;c); <span class=\"slashslashcomment\">// cast from StockItemOC* to StockItem*</span>\n\n    sort(stocks.begin(), stocks.end(), CompareStockPrice());\n\n    cout &lt;&lt; endl &lt;&lt; <span class=\"quotedstring\">&quot;stock items odered by price\\n&quot;</span>;\n    reverse_copy( stocks.begin(), stocks.end(), ostream_iterator&lt;StockItem*&gt;(cout));\n}\n</pre>\n\n<p>F&uuml;r die richtige Sortierung und die Ausgabe sind noch zwei Hilfsfunktionen notwendig, die vor main() in die Programmdatei eingef&uuml;gt werden k&ouml;nnen: CompareStockPrice ist ein sogenannter <em>functor</em>. Er wird als Parameter an den Sortieralgorithmus <em>sort</em> &uuml;bergeben und dient zum Vergleich zweier Objekte vom Typ StockItem. Die zweite Funktion ist der Ausgabeoperator f&uuml;r ein StockItem Objekt. Dieser wird im Alorithmus <em>reverse_copy</em> &uuml;ber den <em>ostream_iterator</em> verwendet.</p>\n\n<pre class=\"cplus\">\n<span class=\"slashslashcomment\">// compare two stock prices</span>\n<span class=\"keyword\">class</span> CompareStockPrice {\n<span class=\"keyword\">public</span>:\n    <span class=\"keyword\">int</span> <span class=\"keyword\">operator</span>()( <span class=\"keyword\">const</span> StockItem* s1, <span class=\"keyword\">const</span> StockItem* s2)\n    { <span class=\"keyword\">return</span> s1-&gt;getValue() &lt; s2-&gt;getValue(); }\n};\n\n<span class=\"slashslashcomment\">// operator&lt;&lt; for class StockItem</span>\n<span class=\"slashslashcomment\">// write name and value to output stream ost</span>\nostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;( ostream&amp; ost, <span class=\"keyword\">const</span> StockItem* item) {\n    ost &lt;&lt; item-&gt;getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; item-&gt;getValue() &lt;&lt; endl;\n    <span class=\"keyword\">return</span> ost;\n}\n</pre>\n\n<p>Wie man sieht, reicht es v&ouml;llig aus, die Hilfsfunktionen f&uuml;r die Klasse StockItem zu implementieren. Es ist beim Aufruf der Funktion dann egal, ob der aktuelle Parameter auf ein Objekt vom Typ StockItem oder StockItemOC zeigt. Dies ist ein Resultat (und Vorteil) der von uns implementierten Vererbungshierarchie.</p>\n"
          ]
        }
      ]
    }
  ]
}