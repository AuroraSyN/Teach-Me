{
  "items": [
    {
      "title": "Adaptive Software Development",
      "content": [
        {
          "tag_line": "About Adaptive Software Development",
          "details": [
            "<p>Adaptive Software Development is a move towards adaptive practices, leaving the deterministic practices in the context of complex systems and complex environments. Adaptive Software Development focuses on collaboration and learning as a technique to build complex systems. It is evolved from the best practices of Rapid Application Development (RAD) and Evolutionary Life Cycles.</p>\n<h1>Audience</h1>\n<p>Adaptive Software Development is written for project teams that have been struggling with high-speed, high-change projects and are looking for ways to improve performance and to moderate burnout, especially as the projects they undertake get larger and the teams become more distributed.</p>\n<h1>Prerequisites</h1>\n<p>Before you start proceeding with this tutorial, we are assuming that you are already aware about the basics of Software Development Life Cycle. If you are not well aware of these concepts, then we will suggest you to go through our short tutorials on SDLC.</p>"
          ]
        },
        {
          "tag_line": "Introduction",
          "details": [
            "<h2>What is Agile?</h2>\n<p>In literary terms, the word “agile” means someone who can move quickly and easily or someone who can think and act quickly and clearly. In business, “agile” is used for describing ways of planning and doing work wherein it is understood that making changes as needed is an important part of the job. Business “agility” means that a company is always in a position to take account of the market changes.</p>\n<p>In software development, the term “agile” is adapted to mean “the ability to respond to changes − changes from Requirements, Technology and People.”</p>\n<h2>Agile Manifesto</h2>\n<p>The Agile Manifesto was published by a team of software developers in 2001, highlighting the importance of the development team, accommodating changing requirements and customer involvement.</p>\n<p>The Agile Manifesto is −</p>\n<p>We are uncovering better ways of developing software by doing it and helping others do it. Through this work, we have come to value −</p>\n<ul class=\"list\">\n<li>Individuals and interactions over processes and tools.</li>\n<li>Working software over comprehensive documentation.</li>\n<li>Customer collaboration over contract negotiation.</li>\n<li>Responding to change over following a plan.</li>\n</ul>\n<p>That is, while there is value in the items on the right, we value the items on the left more.</p>\n<h3>Characteristics of Agility</h3>\n<p>Following are the characteristics of Agility −</p>\n<ul class=\"list\">\n<li><p>Agility in Agile Software Development focuses on the culture of the whole team with multi-discipline, cross-functional teams that are empowered and selforganizing.</p></li>\n<li><p>It fosters shared responsibility and accountability.</p></li>\n<li><p>Facilitates effective communication and continuous collaboration.</p></li>\n<li><p>The whole-team approach avoids delays and wait times.</p></li>\n<li><p>Frequent and continuous deliveries ensure quick feedback that in in turn enable the team align to the requirements.</p></li>\n<li><p>Collaboration facilitates combining different perspectives timely in implementation, defect fixes and accommodating changes.</p></li>\n<li><p>Progress is constant, sustainable, and predictable emphasizing transparency.</p></li>\n</ul>\n<h3>Agile Methodologies</h3>\n<p>Early implementations of Agile methods include Rational Unified Process, Scrum, Crystal Clear, Extreme Programming, Adaptive Software Development, Feature Driven Development, and Dynamic Systems Development Method (DSDM). These are now collectively referred to as the Agile methodologies, after the Agile manifesto was published\nin 2001.</p>\n<p>In this tutorial, we will learn the Agile Methodology − <b>Adaptive Software Development</b>.</p>\n<h2>What is Adaptive Software Development?</h2>\n<p>Adaptive Software Development is a move towards adaptive practices, leaving the deterministic practices in the context of complex systems and complex environments. Adaptive Software Development focuses on collaboration and learning as a technique to build complex systems. It is evolved from the best practices of Rapid Application\nDevelopment (RAD) and Evolutionary Life Cycles. Adaptive Software Development was then extended to include adaptive approaches for the management, with speculation replacing Planning.</p>\n<img src=\"/adaptive_software_development/images/asd_lifecycle.jpg\" alt=\"ASD Lifecycle\">\n<p>Jim Highsmith published a book on Adaptive Software Development in 2000. In Highsmith’s words −</p>\n<blockquote>\n<p>“Adaptive Software Development is cyclical like the evolutionary model, with the phase names Speculate, collaborate, learn reflecting the unpredictable realm of increasingly complex systems. Adaptive development goes further than its evolutionary heritage in two key ways. First, it explicitly replaces determinism with emergence. Second, it goes beyond a change in Life Cycle to a deeper change in management style.”</p></blockquote>"
          ]
        },
        {
          "tag_line": "SDLC Models - Evolution",
          "details": [
            "<p>A Software Development Life Cycle (SDLC) model is a framework that describes the activities performed at each stage of a software development project.</p>\n<p>In a Software Development Life Cycle, the activities are performed in five phases −</p>\n<ul class=\"list\">\n<li><p><b>Requirements Gathering</b> − Requirements for a software to be developed are gathered. These requirements will be in a language that is understood by the customer / user. Domain specific terminology is recommended.</p></li>\n<li><p><b>Analysis</b> − The gathered requirements are analyzed from implementation point of view and the software specifications are written to cover both, the functional requirements and the non-functional requirements.</p></li>\n<li><p><b>Design</b> − This phase involves arriving at the software architecture and implementation specifics based on technology chosen for development.</p></li>\n<li><p><b>Construction</b> − In this phase, the code is developed, unit tested, integrated, integration tested and the build is produced.</p></li>\n<li><p><b>Testing</b> − Functional testing of the built software is done in this phase. This also includes the testing of non-functional requirements.</p></li>\n</ul>\n<p>There are two approaches to performing these activities −</p>\n<ul class=\"list\">\n<li><p><b>Prescriptive</b> − The SDLC models that will provide you ways of performing the activities in a prescribed manner as defined by the framework.</p></li>\n<li><p><b>Adaptive</b> − The SDLC models that will give you flexibility in performing the activities, with certain rules that need to be followed. The agile methods mostly follow this approach, with each one having its rules. However, following an adaptive or agile approach does not mean that the software is developed without following any discipline. This would lead to a chaos.</p></li>\n</ul>\n<p>You need to understand that we cannot say that a specific SDLC model is good or bad. Each of them has its own strengths and weaknesses and thus are suitable in certain contexts.</p>\n<p>When you choose an SDLC model for your project, you need to understand −</p>\n<ul class=\"list\">\n<li>Your Organization Context</li>\n<li>Your Technology Context</li>\n<li>Your Team Composition</li>\n<li>Your Customer Context</li>\n</ul>\n<p>For example, if the software development is predictable, you can use a Prescriptive approach. On the other hand, if the software development is unpredictable, i.e. requirements are not entirely known, or the development team does not have prior exposure to the current domain or technology, etc. then Adaptive approach is the best choice.</p>\n<p>In the following sections, you will understand the most prevalent SDLC models that are evolved during the execution of software development projects across the industry. You will also get to know the strengths and weaknesses of each of them and in what contexts they are suitable.</p>"
          ]
        },
        {
          "tag_line": "SDLC - Waterfall Model",
          "details": [
            "<p>The Waterfall model is a classic SDLC model that is widely known, understood and commonly used. It was introduced by Royce in 1970 and is still being followed as a common approach for software development in various organizations across the industry.</p>\n<p>In Waterfall model, each lifecycle phase can start only after the earlier lifecycle phase is complete. Thus, it is a linear model with no feedback loops.</p>\n<img src=\"/adaptive_software_development/images/waterfall_lifecycle.jpg\" alt=\"Waterfall Lifecycle\">\n<h2>Waterfall Model – Strengths</h2>\n<p>The strengths of the Waterfall model are −</p>\n<ul class=\"list\">\n<li>Easy to understand, easy to use.</li>\n<li>Provides structure to inexperienced development team.</li>\n<li>Milestones are well understood.</li>\n<li>Sets requirements stability.</li>\n<li>Ideal for management control (planning, monitoring, reporting).</li>\n<li>Works well when quality is more important than cost or schedule.</li>\n</ul>\n<h2>Waterfall Model – Weaknesses</h2>\n<p>The weaknesses or the disadvantages of the Waterfall model are −</p>\n<ul class=\"list\">\n<li><p>Idealised − It does not match reality well.</p></li>\n<li><p>Unrealistic − cannot expect accurate requirements early in the project.</p></li>\n<li><p>Does not reflect iterative nature of exploratory development that is more common.</p></li>\n<li><p>Difficult and expensive to make changes.</p></li>\n<li><p>Software is delivered only at the end of the project. Due to this −</p>\n<ul class=\"list\">\n<li><p>Delays discovery of serious defects.</p></li>\n<li><p>Possibility of delivery of obsolete requirements.</p></li>\n</ul>\n</li>\n<li><p>Significant management overhead, which can be costly for small teams and projects.</p></li>\n<li><p>Requires experienced resources at every phase − analysts, designers, developers, testers.</p></li>\n<li><p>Testing starts only after the development is complete and the testers are not involved in any of the earlier phases.</p></li>\n<li><p>The expertize of the cross-functional teams is not shared as each phase is executed in silos.</p></li>\n</ul>\n<h2>When to Use Waterfall Model?</h2>\n<p>You can use the Waterfall model if −</p>\n<ul class=\"list\">\n<li><p>Requirements are very well known.</p></li>\n<li><p>Product definition is stable.</p></li>\n<li><p>Technology is well understood.</p></li>\n<li><p>New version of an existing product.</p></li>\n<li><p>Porting an existing product to a new platform.</p></li>\n<li><p>Large organization with structured cross-functional teams.</p></li>\n<li><p>Communication channels are well established within the organization and with the customer as well.</p></li>\n</ul>\n<h2>Evolutionary Prototyping Model</h2>\n<p>In software development using Evolutionary Prototyping model, the developers build a prototype during the requirements phase. The end users then evaluate the prototype and give feedback. The feedback can be corrections to the prototype or additional functionality. Based on the feedback, the developers further refine the prototype.</p>\n<p>Thus, the product evolves through the Prototype → Feedback → Refined Prototype Cycles and hence the name Evolutionary Prototyping. When the user is satisfied with the functionality, and working of the product, the prototype code is brought up to the required standards for the final product delivery.</p>\n<img src=\"/adaptive_software_development/images/final_product_delivery.jpg\" alt=\"Final Product Delivery\">\n<h2>Evolutionary Prototyping Model – Strengths</h2>\n<p>The strengths or the advantages of an Evolutionary Prototyping model are −</p>\n<ul class=\"list\">\n<li><p>Customers/end users can visualize the system requirements as they are gathered looking at the prototype.</p></li>\n<li><p>Developers learn from customers and hence no ambiguities regarding domain or production environment.</p></li>\n<li><p>Allows flexible design and development.</p></li>\n<li><p>Interaction with the prototype stimulates the awareness of additionally needed functionality.</p></li>\n<li><p>Unexpected requirements and requirements changes are easily accommodated.</p></li>\n<li><p>Steady and visible signs of progress are produced.</p></li>\n<li><p>Delivery of an accurate and maintainable end-product.</p></li>\n</ul>\n<h2>Evolutionary Prototyping Model – Weaknesses</h2>\n<p>The weaknesses or disadvantages of the Evolutionary Prototyping model are as follows −</p>\n<ul class=\"list\">\n<li><p>Tendency to abandon structured development in the code-and-fix development, though it is not what is prescribed by the model.</p></li>\n<li><p>This model received bad reputation for the quick-and-dirty methods.</p></li>\n<li><p>Overall maintainability can possibly be overlooked.</p></li>\n<li><p>The customer can possibly ask for the delivery of the prototype as the final, not giving the opportunity for the developers to execute the final step i.e. standardization of the end-product.</p></li>\n<li><p>Project can continue forever (with continuous scope creep) and the management may not appreciate it.</p></li>\n</ul>\n<h2>When to Use Evolutionary Prototyping Model?</h2>\n<p>You can use the Evolutionary Prototyping model −</p>\n<ul class=\"list\">\n<li>When requirements are unstable or have to be clarified</li>\n<li>As the requirements clarification stage of a waterfall model</li>\n<li>To develop user interfaces</li>\n<li>For short-lived demonstrations</li>\n<li>For new or original development</li>\n<li>For implementing a new technology</li></ul>"
          ]
        },
        {
          "tag_line": "SDLC - Iterative Incremental Model",
          "details": [
            "<p>In an Iterative Incremental model, initially, a partial implementation of a total system is constructed so that it will be in a deliverable state. Increased functionality is added. Defects, if any, from the prior delivery are fixed and the working product is delivered. The process is repeated until the entire product development is completed. The repetitions of these processes are called iterations. At the end of every iteration, a product increment is delivered.</p>\n<img src=\"/adaptive_software_development/images/iterations.jpg\" alt=\"Iterations\">\n<h2>Iterative Incremental Model – Strengths</h2>\n<p>The advantages or strengths of Iterative Incremental model are −</p>\n<ul class=\"list\">\n<li><p>You can develop prioritized requirements first.</p></li>\n<li><p>Initial product delivery is faster.</p></li>\n<li><p>Customers gets important functionality early.</p></li>\n<li><p>Lowers initial delivery cost.</p></li>\n<li><p>Each release is a product increment, so that the customer will have a working product at hand all the time.</p></li>\n<li><p>Customer can provide feedback to each product increment, thus avoiding surprises at the end of development.</p></li>\n<li><p>Requirements changes can be easily accommodated.</p></li>\n</ul>\n<h2>Iterative Incremental Model – Weaknesses</h2>\n<p>The disadvantages of the Iterative Incremental model are −</p>\n<ul class=\"list\">\n<li><p>Requires effective planning of iterations.</p></li>\n<li><p>Requires efficient design to ensure inclusion of the required functionality and provision for changes later.</p></li>\n<li><p>Requires early definition of a complete and fully functional system to allow the definition of increments.</p></li>\n<li><p>Well-defined module interfaces are required, as some are developed long before others are developed.</p></li>\n<li><p>Total cost of the complete system is not lower.</p></li>\n</ul>\n<h2>When to Use Iterative Incremental Model?</h2>\n<p>Iterative Incremental model can be used when −</p>\n<ul class=\"list\">\n<li><p>Most of the requirements are known up-front but are expected to evolve over time.</p></li>\n<li><p>The requirements are prioritized.</p></li>\n<li><p>There is a need to get the basic functionality delivered fast.</p></li>\n<li><p>A project has lengthy development schedules.</p></li>\n<li><p>A project has new technology.</p></li>\n<li><p>The domain is new to the team.</p></li></ul>"
          ]
        },
        {
          "tag_line": "SDLC - Rapid Application Development Model",
          "details": [
            "<p>Rapid Application Development (RAD) model has the following phases −</p>\n<ul class=\"list\">\n<li><p><b>Requirements Planning phase</b> − In the requirements planning phase, aworkshop needs to be conducted to discuss business problems in a structured manner.</p></li>\n<li><p><b>User Description phase</b> − In the User Description phase, automated tools are used to capture information from users.</p></li>\n<li><p><b>Construction phase</b> − In the Construction phase, productivity tools, such as code generators, screen generators, etc. are used inside a time-box, with a “Do until Done” approach.</p></li>\n<li><p><b>Cut Over phase</b> − In the Cut over phase, installation of the system, user acceptance testing and user training are performed.</p></li>\n</ul>\n<img src=\"/adaptive_software_development/images/rad_phases.jpg\" alt=\"RAD Phases\">\n<h2>Rapid Application Development Model – Strengths</h2>\n<p>The advantages or strengths of the Rapid Application Development model are as follows −</p>\n<ul class=\"list\">\n<li><p>Reduced cycle time and improved productivity with fewer team members would mean lower costs.</p></li>\n<li><p>Customer’s involvement throughout the complete cycle minimizes the risk of not achieving customer satisfaction and business value.</p></li>\n<li><p>Focus moves to the code in a what-you-see-is-what-you-get mode (WYSIWYG). This brings clarity on what is being built is the right thing.</p></li>\n<li><p>Uses modelling concepts to capture information about business, data, and processes.</p></li>\n</ul>\n<h2>Rapid Application Development Model – Weaknesses</h2>\n<p>The disadvantages or strengths of Rapid Application Development model are as follows −</p>\n<ul class=\"list\">\n<li><p>Accelerated development process must give quick responses to the user.</p></li>\n<li><p>Risk of never achieving closure.</p></li>\n<li><p>Hard to use with legacy systems.</p></li>\n<li><p>Developers and customers must be committed to rapid-fire activities in an abbreviated time frame.</p></li>\n</ul>\n<h2>When to Use Rapid Application Development Model?</h2>\n<p>Rapid Application Development model can be used when −</p>\n<ul class=\"list\">\n<li>User can be involved throughout the life cycle.</li>\n<li>Project can be time-boxed.</li>\n<li>Functionality can be delivered in increments.</li>\n</ul>\n<p>Though the strengths of Rapid Application Development model are appreciated, it is sparingly used in the industry.</p>"
          ]
        },
        {
          "tag_line": "SDLC - Spiral Model",
          "details": [
            "<p>Spiral model adds Risk Analysis and RAD prototyping to the Waterfall model. Each cycle involves the same sequence of steps as the Waterfall model.</p>\n<img src=\"/adaptive_software_development/images/spiral_model.jpg\" alt=\"Spiral Model\">\n<p>Spiral model has four quadrants. Let us discuss them in detail.</p>\n<h3>Quadrant 1 - Determine objectives, alternatives and constraints</h3>\n<ul class=\"list\">\n<li><p><b>Objectives</b> − Functionality, performance, hardware/software interface, critical success factors, etc.</p></li>\n<li><p><b>Alternatives</b> − Build, reuse, buy, sub-contract, etc.</p></li>\n<li><p><b>Constraints</b> − Cost, schedule, interface, etc.</p></li>\n</ul>\n<h3>Quadrant 2 - Evaluate alternatives, identify and resolve risks</h3>\n<ul class=\"list\">\n<li><p>Study alternatives relative to the objectives and constraints that are determined.</p></li>\n<li><p>Identify risks such as lack of experience, new technology, tight schedules, etc.</p></li>\n<li><p>Resolve the identified risks evaluating their impact on the project, identifying the needed mitigation and contingency plans and implementing them. Risks always need to be monitored.</p></li>\n</ul>\n<h3>Quadrant 3 - Develop next-level product</h3>\n<p>Typical activities include −</p>\n<ul class=\"list\">\n<li>Create a design</li>\n<li>Review design</li>\n<li>Develop code</li>\n<li>Inspect code</li>\n<li>Test product</li>\n</ul>\n<h3>Quadrant 4 - Plan next phase</h3>\n<p>Typical activities include −</p>\n<ul class=\"list\">\n<li>Develop project plan</li>\n<li>Develop configuration management plan</li>\n<li>Develop a test plan</li>\n<li>Develop an installation plan</li>\n</ul>\n<h2>Spiral Model – Strengths</h2>\n<p>The advantages or strengths of the Spiral method are −</p>\n<ul class=\"list\">\n<li>Provides early indication of the risks, without involving much cost.</li>\n<li>Users can view the system early because of the rapid prototyping tools.</li>\n<li>Critical high-risk functions are developed first.</li>\n<li>The design does not have to be perfect.</li>\n<li>Users can be closely involved in all lifecycle steps.</li>\n<li>Early and frequent feedback from users.</li>\n<li>Cumulative costs assessed frequently.</li>\n</ul>\n<h2>Spiral Model – Weaknesses</h2>\n<p>The disadvantages or weaknesses of the Spiral method are −</p>\n<ul class=\"list\">\n<li><p>May be hard to define objectives, verifiable milestones that indicate readiness to proceed through the next iteration.</p></li>\n<li><p>Time spent in planning, resetting objectives, doing risk analysis and prototyping may be an overhead.</p></li>\n<li><p>Time spent for evaluating risks can be too large for small or low-risk projects.</p></li>\n<li><p>Spiral model is complex to understand for new team members.</p></li>\n<li><p>Risk assessment expertise is required.</p></li>\n<li><p>Spiral may continue indefinitely.</p></li>\n<li><p>Developers must be reassigned during non-development phase activities.</p></li>\n</ul>\n<h2>When to Use Spiral Model?</h2>\n<p>The Spiral model can be used when −</p>\n<ul class=\"list\">\n<li>Creation of a prototype is appropriate.</li>\n<li>Risk evaluation is important.</li>\n<li>A project is of medium to high-risk.</li>\n<li>Users are unsure of their needs.</li>\n<li>Requirements are complex.</li>\n<li>Product-line is new.</li>\n<li>Significant changes are expected during exploration.</li>\n<li>Long-term project commitment unwise because of potential business changes.</li></ul>"
          ]
        },
        {
          "tag_line": "SDLC - Agile Methods",
          "details": [
            "<p>Agile Methods are based on the Agile manifesto and are adaptive in nature. Agile methods ensure −</p>\n<ul class=\"list\">\n<li>Team collaboration.</li>\n<li>Customer collaboration.</li>\n<li>Constant and continuous communication.</li>\n<li>Response to changes.</li>\n<li>Readiness of a working product.</li>\n</ul>\n<p>Several Agile methods came into existence, promoting iterative and incremental development with time-boxed iterations. Though the Agile methods are adaptive, rules of the specific method cannot be by-passed and hence requires disciplined implementation.</p>\n<h2>Agile Methods – Strengths</h2>\n<p>The advantages or strengths of Agile method are −</p>\n<ul class=\"list\">\n<li>Early and frequent releases.</li>\n<li>Accommodation of changing requirements.</li>\n<li>Daily communication among the customer and developers.</li>\n<li>Projects built around motivated individuals.</li>\n<li>Self-organizing teams.</li>\n<li>Simplicity, focusing on what is immediately required.</li>\n<li>No building for future or overburdening the code.</li>\n<li>Regular reflection to adjust behavior to improve effectiveness.</li>\n</ul>\n<h2>Agile Methods – Weaknesses</h2>\n<p>The disadvantages or weaknesses of Spiral method are −</p>\n<ul class=\"list\">\n<li><p>Customer availability may not be possible.</p></li>\n<li><p>Teams should be experienced to follow the rules of the method.</p></li>\n<li><p>Appropriate planning is required to quickly decide on the functionality that needs to be delivered in an iteration.</p></li>\n<li><p>Team is expected to have estimation skills and negotiation skills.</p></li>\n<li><p>Team should have effective communication skills.</p></li>\n<li><p>New teams may not be able to organize themselves.</p></li>\n<li><p>Requires discipline to develop and deliver in time-boxed iterations.</p></li>\n<li><p>Design needs to be kept simple and maintainable, thus requiring effective design skills.</p></li>\n</ul>\n<h2>When to Use Agile methods?</h2>\n<p>The Agile methods can be used when −</p>\n<ul class=\"list\">\n<li><p>Application is time-critical.</p></li>\n<li><p>The scope is limited and less formal (scaling agile methods to larger projects is underway, with certain extensions to some of the agile methods).</p></li>\n<li><p>Organization employs disciplined methods.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Evolution",
          "details": [
            "<p>The earlier SDLC models are more oriented to the practices of stability, predictability and decreasing returns. The industry, such as the Internet Platforms has been moving to increase return environments, unpredictable, nonlinear, and fast approaches.</p>\n<p>Adaptive Software Development (ASD) has evolved to address these issues. It focuses on emergence as the most important factor from the management’s perspective, to enhance the ability to manage product development.</p>\n<p>In Jim Highsmith’s words, “Adaptive Software Development framework is based on years of experience with traditional Software Development methodologies, consulting on, practicing, and writing about Rapid Application Development (RAD) techniques and working with high-technology software companies on managing their product development practices”.</p>\n<p>Waterfall model is found to be characterized by linearity and predictability, with meagre feedback. It can be viewed as a sequence of <b>Plan → Build → Implement</b>.</p>\n<img src=\"/adaptive_software_development/images/waterfall_model.jpg\" alt=\"Waterfall Model\">\n<p>The Evolutionary Lifecycle models such as the Spiral model moved the Deterministic approach to the Adaptive one, with <b>Plan → Build → Revise Cycles</b>.</p>\n<img src=\"/adaptive_software_development/images/evolutionary_lifecycle.jpg\" alt=\"Evolutionary Lifecycle\">\n<p>However, the practitioners’ mindset remained Deterministic with long-term predictability turning to short-term predictability. The practices of Evolutionary Lifecycle models such as RAD are found to be less Deterministic.</p>\n<h2>The Adaptive Life Cycle</h2>\n<p>The Adaptive model is built from a different point of view. Though cyclical like the Evolutionary model, the names of the phase reflect the unpredictable nature of increasingly complex systems.</p>\n<p>Adaptive Development goes further than its evolutionary heritage in two key ways −</p>\n<ul class=\"list\">\n<li><p>It explicitly replaces Determinism with Emergence.</p></li>\n<li><p>It goes beyond a change in life cycle to a deeper change in management style.</p></li>\n</ul>\n<img src=\"/adaptive_software_development/images/asd_lifecycle.jpg\" alt=\"Adaptive S/W Development Lifecycle\">\n<p>The three phases in Adaptive Software Development Lifecycle are −</p>\n<ul class=\"list\">\n<li><p><b>Speculate</b> − Speculate replaces the deterministic word planning, planning of product specifications or planning of project management tasks.</p></li>\n<li><p><b>Collaborate</b> − Collaborate represents drawing a balance between</p>\n<ul class=\"list\">\n<li><p>Managing in the traditional project management sense, and</p></li>\n<li><p>Creating and maintaining the collaborative environment needed for emergence.</p></li>\n</ul>\n</li>\n<p>Collaborative Activities build products, keeping up the pace of changes in the environment.</p>\n<li><p><b>Learn</b> − Learn aims both, the developers and the customers, to use the results of each development cycle to learn the direction of the next.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Concepts",
          "details": [
            "<p>In this chapter, we will understand the various concepts of Adaptive Software Development.</p>\n<h2>Complex Adaptive Systems (CAS) Theory</h2>\n<p>Brian Arthur and his colleagues, at the Santa Fe institute, used the Complex Adaptive Systems (CAS) theory to revolutionize the understanding of Physics, Biology, Evolution, and Economics.</p>\n<p>Brian Arthur culminated his more than two decades of trying to convince mainstream economists that their view, dominated by fundamental assumptions of decreasing returns, equilibrium, and deterministic dynamics, was no longer sufficient to understand reality. The new world is one of increasing returns, instability, and inability to determine cause and effect.</p>\n<p>The two worlds differ in behavior, style, and culture. They call for −</p>\n<ul class=\"list\">\n<li>Different Management Techniques</li>\n<li>Different Strategies</li>\n<li>Different Understanding</li>\n</ul>\n<h2>Complex Software Development</h2>\n<p>With the scope of Software Applications being exploded, even the software development organizations are accruing similar contradictions as mentioned above.</p>\n<ul class=\"list\">\n<li><p>One World is represented by the Deterministic development, derived from management practices that are rooted with the basics of stability and predictability (which in Arthur's terms means decreasing returns)</p></li>\n<li><p>Second World is represented by the industries moving from decreasing to increasing return environments that are unpredictable, nonlinear and fast.</p></li>\n</ul>\n<p>To address the issues of this second world, Jig Highsmith offered a framework, Adaptive Software Development that is different from the Deterministic Software Development.</p>\n<p>The Adaptive Software Development focuses on addressing the complex systems −</p>\n<ul class=\"list\">\n<li><p>Adaptive Software Development for the development life cycle.</p></li>\n<li><p>Adaptive Management Techniques calling for a different mindset from that of traditional project management practices.</p></li>\n</ul>\n<p>In this tutorial, you can understand both these implementations.</p>\n<p>Adaptive Software Development (ASD) is based on two perspectives −</p>\n<ul class=\"list\">\n<li><p>Conceptual perspective based on the Complex Adaptive Systems (CAS) theory, as given in the first section of this chapter.</p></li>\n<li><p>Practical Perspective based on</p>\n<ul class=\"list\">\n<li><p>Years of experience with Deterministic software development methodologies.</p></li>\n<li><p>Consulting, practicing, and writing about Rapid Application Development (RAD) techniques; and working with high-technology software companies on managing their product development.</p></li>\n</ul>\n</li>\n</ul>\n<p>In this chapter, you will understand the conceptual perspective of Adaptive Software Development.</p>\n<h2>Complex Adaptive Systems (CAS) Concepts</h2>\n<p>Complex Adaptive Systems (CAS) theory has many concepts. Adaptive Software Development is based on two of these concepts −</p>\n<ul class=\"list\">\n<li>Emergence</li>\n<li>Complexity</li>\n</ul>\n<h3>Emergence</h3>\n<p>In complex software product-development projects, the outcomes are inherently unpredictable. However, successful products emerge from such environments all the time.</p>\n<p>This can happen by Emergence, as illustrated in the Complex Adaptive Systems (CAS) theory. It can be understood by a simple example, flocking behavior of birds.</p>\n<p>When you observe a flock of birds, you notice that −</p>\n<ul class=\"list\">\n<li><p>Each bird tries to</p>\n<ul class=\"list\">\n<li><p>Maintain a minimum distance from other objects in the environment, including other birds.</p></li>\n<li><p>Match velocities with birds in its neighborhood.</p></li>\n<li><p>Move towards the perceived center of mass of birds in its neighborhood.</p></li>\n</ul>\n</li>\n<li><p>There are no rules of behavior for the group. The only rules are about the behavior of individual birds.</p></li>\n<li><p>However, there exists an emergent behavior, the flocking of birds. When errant birds rush to catch up, the flock splits around obstacles and reforms on the other side.</p></li>\n</ul>\n<p>This shows the requirement of the most difficult mental model changes in Adaptive Development − From ways of managing and organizing that individual freedom to the notion that a creative new order emerges unpredictably from spontaneous selforganization.</p>\n<p>In addition to the development, emergence is the most important concept from the management perspective also.</p>\n<h3>Complexity</h3>\n<p>In the Software Development context, Complexity is about −</p>\n<ul class=\"list\">\n<li><p>The individuals of a team such as the developers, customers, vendors, competitors, and stockholders, their numbers and their speed.</p></li>\n<li><p>Size and technological complexity.</p></li>\n</ul>\n<h2>Adaptive Software Development Practices</h2>\n<p>Adaptive Software Development offers a different perspective on software management practices. In the sections below, you can understand the two important practices − Quality and RAD, both of which have ramifications for gathering requirements.</p>\n<p>You can find the details of all the practices in the chapter, Adaptive Software Development Practices in this tutorial.</p>\n<h3>Quality</h3>\n<p>In a complex environment, the age-old practice of \"Do it right the first time\" does not work as you cannot predict what is right at the beginning. You need to have an aim to produce the right value. However, in complex environment, the combinations and permutations of value components like scope (features, performance, defect levels), schedule, and resources is so vast that there can never be an optimum value. Hence, the focus is to shift to deliver the best value in the competitive market.</p>\n<h3>RAD Practices</h3>\n<p>RAD Practices generally involve a combination of the following −</p>\n<ul class=\"list\">\n<li>Evolutionary Lifecycle</li>\n<li>Customer Focus Groups, JAD Sessions, Technical Reviews</li>\n<li>Time-boxed Project Management</li>\n<li>Continuous Software Engineering</li>\n<li>Dedicated Teams with war rooms</li>\n</ul>\n<p>The RAD projects have an inherent adaptive, emergent flavor. Many IT organizations are against RAD. However, Microsoft and others have produced incredibly large and complex software using techniques comparable to RAD because it raises questions about their fundamental world view.</p>\n<p>RAD practices and Microsoft process are both examples of Adaptive Development in action. Giving them a label (i.e., Adaptive Development) and realizing that there is a growing body of scientific knowledge (i.e., CAS theory) explains why they work. This should provide a basis for more extensive use of these practices.</p>"
          ]
        },
        {
          "tag_line": "Lifecycle",
          "details": [
            "<p>Adaptive Software Development has evolved from RAD practices. The team aspects also were added to these practices. Companies from New Zealand to Canada, for a wide range of project and product types, have used adaptive Software Development.</p>\n<p>Jim Highsmith published Adaptive Software Development in 2000.</p>\n<p>Adaptive Software Development practices provide ability to accommodate change and are adaptable in turbulent environments with products evolving with little planning and learning.</p>\n<h2>Phases of ASD Life Cycle</h2>\n<p>Adaptive Software Development is cyclical like the Evolutionary model, with the phase names reflecting the unpredictability in the complex systems. The phases in the Adaptive development life cycle are −</p>\n<ul class=\"list\">\n<li>Speculate</li>\n<li>Collaborate</li>\n<li>Learn</li>\n</ul>\n<p>These three phases reflect the dynamic nature of Adaptive Software Development. The Adaptive Development explicitly replaces Determinism with Emergence. It goes beyond a mere change in lifecycle to a deeper change in management style. Adaptive Software Development has a dynamic Speculate-Collaborate-Learn Lifecycle.</p>\n<p>The Adaptive Software Development Lifecycle focuses on results, not tasks, and the results are identified as application features.</p>\n<img src=\"/adaptive_software_development/images/asd_lifecycle.jpg\" alt=\"Adaptive Software Development Lifecycle\">\n<h3>Speculate</h3>\n<p>The term plan is too deterministic and indicates a reasonably high degree of certainty about the desired result. The implicit and explicit goal of conformance to plan, restricts the manager's ability to steer the project in innovative directions.</p>\n<p>In Adaptive Software Development, the term plan is replaced by the term speculate. While speculating, the team does not abandon planning, but it acknowledges the reality of uncertainty in complex problems. Speculate encourages exploration and experimentation. Iterations with short cycles are encouraged.</p>\n<h3>Collaborate</h3>\n<p>Complex applications are not built, they evolve. Complex applications require that a large volume of information be collected, analyzed, and applied to the problem. Turbulent environments have high rates of information flow. Hence, complex applications require that a large volume of information be collected, analyzed, and applied to the problem. This results in diverse Knowledge requirements that can only be handled by team collaboration.</p>\n<p>Collaborate would require the ability to work jointly to produce results, share knowledge or make decisions.</p>\n<p>In the context of project management, Collaboration portrays a balance between managing with traditional management techniques and creating and maintaining the collaborative environment needed for emergence.</p>\n<h3>Learn</h3>\n<p>The Learn part of the Lifecycle is vital for the success of the project. Team has to enhance their knowledge constantly, using practices such as −</p>\n<ul class=\"list\">\n<li>Technical Reviews</li>\n<li>Project Retrospectives</li>\n<li>Customer Focus Groups</li>\n</ul>\n<p>Reviews should be done after each iteration. Both, the developers and customers examine their assumptions and use the results of each development cycle to learn the direction of the next. The team learns −</p>\n<ul class=\"list\">\n<li><p>About product changes</p></li>\n<li><p>More fundamental changes in underlying assumptions about how the products are being developed</p></li>\n</ul>\n<p>The iterations need to be short, so that the team can learn from small rather than large mistakes.</p>\n<h3>Speculate - Collaborate - Learn Cycle as a Whole</h3>\n<p>As you observe from the Speculate-Collaborate-Learn cycle, given above, it is obvious that the three phases are nonlinear and overlap.</p>\n<p>We observe the following from an Adaptive framework.</p>\n<ul class=\"list\">\n<li><p>It is difficult to Collaborate without Learning or to Learn without Collaborating.</p></li>\n<li><p>It is difficult to Speculate without Learning or to Learn without Speculating.</p></li>\n<li><p>It is difficult to Speculate without Collaborating or to Collaborate without Speculating.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Lifecycle Characteristics",
          "details": [
            "<p>Adaptive Software Development Lifecycle has six basic characteristics −</p>\n<ul class=\"list\">\n<li>Mission focused</li>\n<li>Feature based</li>\n<li>Iterative</li>\n<li>Time-boxed</li>\n<li>Risk driven</li>\n<li>Change tolerant</li>\n</ul>\n<p>In this chapter, you will understand these six characteristics of Adaptive Software Development.</p>\n<h2>Mission-focused</h2>\n<p>For many projects, the overall mission that guides the team is well articulated, though the requirements may be uncertain at the beginning of the project. Mission statements act as guides that encourage exploration in the beginning but have a narrow focus over the course of a project. A mission provides boundaries rather than a fixed destination. Mission statements and the discussions that result in those statements provide direction and criteria for making critical project tradeoff decisions.</p>\n<p>Without a clear mission and a constant mission refinement practice, iterative lifecycles become oscillating lifecycles, swinging back and forth with no progress in the development.</p>\n<h2>Feature-based</h2>\n<p>The Adaptive Software Development Lifecycle is based on application features and not on tasks. Features are the functionality that are developed during an iteration based on the customer’s priorities.</p>\n<p>Features can evolve over several iterations when the customers provide feedback.</p>\n<p>The application features that provide direct results to the customer after implementation are primary. A customer-oriented document such as a user manual is also considered as a feature. The other documents such as the data model, even if defined as deliverables are always secondary.</p>\n<h2>Iterative</h2>\n<p>The Adaptive Software Development Lifecycle is iterative and focuses on frequent releases in order to obtain feedback, assimilate the resulting learning and setting the right direction for further development.</p>\n<h2>Time-boxed</h2>\n<p>In Adaptive Software Development Lifecycle, the iterations are time-boxed. However, one should remember that time-boxing in Adaptive Software Development is not about time deadlines. It should not be used to make the team work for long hours challenging a collaborative environment or for compromising on the quality of the deliverables.</p>\n<p>In Adaptive Software Development, time-boxing is considered as a direction for focusing and forcing hard tradeoff decisions as and when required. In an uncertain environment, in which change rates are high, there needs to be a periodic forcing function such as a timebox to get the work finished.</p>\n<h2>Risk-driven</h2>\n<p>In Adaptive Software Development, the iterations are driven by identifying and evaluating the critical risks.</p>\n<h2>Change-tolerant</h2>\n<p>Adaptive Software Development is change-tolerant, viewing change as the ability to incorporate competitive advantage, but not as a problem for development.</p>"
          ]
        },
        {
          "tag_line": "Practices",
          "details": [
            "<p>The Adaptive Software Development practices are driven by a belief in continuous adaptation, with the lifecycle equipped to accepting continuous change as the norm.</p>\n<p>Adaptive Software Development Lifecycle is dedicated to −</p>\n<ul class=\"list\">\n<li>Continuous learning</li>\n<li>Change orientation</li>\n<li>Re-evaluation</li>\n<li>Peering into an uncertain future</li>\n<li>Intense collaboration among developers, management, and customers</li>\n</ul>\n<h2>Adaptive SDLC</h2>\n<p>Adaptive Software Development combines RAD with Software Engineering Best Practices, such as −</p>\n<ul class=\"list\">\n<li>Project initiation.</li>\n<li>Adaptive cycle planning.</li>\n<li>Concurrent component engineering.</li>\n<li>Quality review.</li>\n<li>Final QA and release.</li>\n</ul>\n<p>Adaptive Software Development practices can be illustrated as follows −</p>\n<img src=\"/adaptive_software_development/images/practices_learning_loop.jpg\" alt=\"Practices Learning Loop\">\n<p>As illustrated above, Adaptive Software Development practices are spread across the three phases as follows −</p>\n<ul class=\"list\">\n<li><b></b><p><b>Speculate</b> − Initiation and planning</p>\n<ul class=\"list\">\n<li><p>Project Initiation</p></li>\n<li><p>Establishing time-box for the entire project</p></li>\n<li><p>Decide on the number of iterations and assign a time-box to each one</p></li>\n<li><p>Develop a theme or objective for each of the iterations</p></li>\n<li><p>Assign features to each iteration</p></li>\n</ul>\n</li>\n<li><p><b>Collaborate</b> − Concurrent feature development</p>\n<ul class=\"list\">\n<li><p>Collaboration for distributed teams</p></li>\n<li><p>Collaboration for smaller projects</p></li>\n<li><p>Collaboration for larger projects</p></li>\n</ul>\n</li>\n<li><p><b>Learn</b> − Quality Review</p>\n<ul class=\"list\">\n<li><p>Result quality from the customer's perspective</p></li>\n<li><p>Result quality from a technical perspective</p></li>\n<li><p>The functioning of the delivery team and the practices team members are utilizing</p></li>\n<li><p>The project status</p></li>\n</ul>\n</li>\n</ul>\n<h2>Speculate - Initiation and Planning</h2>\n<p>In Adaptive Software Development, the speculate phase has two activities −</p>\n<ul class=\"list\">\n<li>Initiation</li>\n<li>Planning</li>\n</ul>\n<p>Speculate has five practices that can be executed repetitively during the initiation and planning phase. They are −</p>\n<ul class=\"list\">\n<li>Project initiation</li>\n<li>Establishing time-box for the entire project</li>\n<li>Decide on the number of iterations and assign a time-box to each one</li>\n<li>Develop a theme or objective for each of the iterations</li>\n<li>Assign features to each iteration</li>\n</ul>\n<h3>Project Initiation</h3>\n<p>Project Initiation involves −</p>\n<ul class=\"list\">\n<li>Setting the project's mission and objectives</li>\n<li>Understanding constraints</li>\n<li>Establishing the project organization</li>\n<li>Identifying and outlining requirements</li>\n<li>Making initial size and scope estimates</li>\n<li>Identifying key project risks</li>\n</ul>\n<p>The project initiation data should be gathered in a preliminary JAD session, considering speed as the major aspect. Initiation can be completed in a concentrated two to five day effort for a small to medium sized projects, or two to three weeks effort for larger projects.</p>\n<p>During the JAD sessions, requirements are gathered in enough detail to identify features and establish an overview of the object, data, or other architectural model.</p>\n<h3>Establishing Time-box for the Entire Project</h3>\n<p>The time-box for the entire project should be established, based on the scope, feature-set requirements, estimates, and resource availability that result from project initiation work.</p>\n<p>As you know, Speculating does not abandon estimating, but it just means accepting that estimates can go wrong.</p>\n<h3>Iterations and Time-box</h3>\n<p>Decide on the number of iterations and the individual iteration lengths based on the overall project scope and the degree of uncertainty.</p>\n<p>For a small to medium sized application −</p>\n<ul class=\"list\">\n<li>Iterations usually vary from four to eight weeks.</li>\n<li>Some projects work best with two-week iterations.</li>\n<li>Some projects might require more than eight weeks.</li>\n</ul>\n<p>Choose the time, based on what works for you. Once you decide on the number of iterations and the lengths of each of the iterations, assign a schedule to each of the iterations.</p>\n<h3>Develop a Theme or Objective</h3>\n<p>The team members should develop a theme or objective for each iteration. This is something similar to the Sprint Goal in Scrum. Each iteration should deliver a set of features that can demonstrate the product functionality making the product visible to the customer to enable review and feedback.</p>\n<p>Within the iterations, the builds should deliver working features on a preferably daily basis enabling integration process and making the product visible to the development team. Testing should be an ongoing, integral part of the feature development. It should not be delayed until the end of the project.</p>\n<h3>Assign Features</h3>\n<p>Developers and customers should together assign features to each iteration. The most important criteria for this feature assignment is that every iteration must deliver a visible set of features with considerable functionality to the customer.</p>\n<p>During the assignment of features to the iterations −</p>\n<ul class=\"list\">\n<li><p>Development team should come up with the feature estimates, risks, and dependencies and provide them to the customer.</p></li>\n<li><p>Customers should decide on feature prioritization, using the information provided by the development team.</p></li>\n</ul>\n<p>Thus iteration planning is feature-based and done as a team with developers and customers. Experience has shown that this type of planning provides better understanding of the project than a task-based planning by the project manager. Further, feature-based planning reflects the uniqueness of each project.</p>\n<h2>Collaborate ─ Concurrent Feature Development</h2>\n<p>During the Collaborate phase, the focus is on the development. The Collaborate phase has two activities −</p>\n<ul class=\"list\">\n<li><p>The Development team collaborate and deliver working software.</p></li>\n<li><p>The project managers facilitate collaboration and concurrent development activities.</p></li>\n</ul>\n<p>Collaboration is an act of shared creation that encompasses the development team, the customers and the managers. Shared creation is fostered by trust and respect.</p>\n<p>Teams should collaborate on −</p>\n<ul class=\"list\">\n<li>Technical problems</li>\n<li>Business requirements</li>\n<li>Rapid decision making</li>\n</ul>\n<p>Following are the practices relevant to the Collaborate phase in Adaptive Software Development −</p>\n<ul class=\"list\">\n<li>Collaboration for distributed teams</li>\n<li>Collaboration for smaller projects</li>\n<li>Collaboration for larger projects</li>\n</ul>\n<h3>Collaboration for Distributed Teams</h3>\n<p>In the projects involving distributed teams, the following should be considered −</p>\n<ul class=\"list\">\n<li>Varying alliance partners</li>\n<li>Broad-based knowledge</li>\n<li>The way people interact</li>\n<li>The way they manage interdependencies</li>\n</ul>\n<h3>Collaboration for Smaller Projects</h3>\n<p>In the smaller projects, when team members are working in physical proximity, Collaboration with informal hallway chats and whiteboard scribbling should be encouraged, as this is found to be effective.</p>\n<h3>Collaboration for Larger Projects</h3>\n<p>Larger projects require additional practices, collaboration tools, and project manager interaction and should be arranged on the contextual basis.</p>\n<h2>Learn - Quality Review</h2>\n<p>Adaptive Software Development encourages the concept of ‘Experiment and Learn’.</p>\n<p>Learning from the mistakes and experimentation requires that the team members share partially completed code and artifacts early, in order to −</p>\n<ul class=\"list\">\n<li>Find mistakes</li>\n<li>Learn from them</li>\n<li>Reduce rework by finding small problems before they become large ones</li>\n</ul>\n<p>At the end of each development iteration, there are four general categories of things to learn −</p>\n<ul class=\"list\">\n<li>Result quality from the customer's perspective</li>\n<li>Result quality from a technical perspective</li>\n<li>The functioning of the delivery team and the practices team</li>\n<li>The project status</li>\n</ul>\n<h3>Result Quality from the Customer's Perspective</h3>\n<p>In the Adaptive Software Development projects, getting feedback from the customers is the first priority. The recommended practice for this is a customer focus group. These sessions are designed to explore a working model of the application and record customer change requests.</p>\n<p>Customer focus group sessions are facilitated sessions, similar to jad sessions, but rather than generating requirements or defining project plans, they are designed to review the application itself. The customers provide feedback on the working software resulting from an iteration.</p>\n<h3>Result Quality from a Technical Perspective</h3>\n<p>In the Adaptive Software Development projects, periodic review of technical artifacts should be given importance. Code Reviews should be done on a continuous basis. Reviews of other technical artifacts, such as technical architecture can be conducted weekly or at the end of an iteration.</p>\n<p>In Adaptive Software Development projects, the team should monitor its own performance periodically. Retrospectives encourage the teams to learn about themselves and their work, together as a team.</p>\n<p>Iteration-end retrospectives facilitate periodic team performance self-review such as −</p>\n<ul class=\"list\">\n<li>Determine what is not working.</li>\n<li>What the Team needs to do more.</li>\n<li>What the Team needs to do less.</li>\n</ul>\n<h3>The Project Status</h3>\n<p>The Project status review helps in planning further work. In the adaptive software development projects, determining the project status is feature-based approach, the end of each iteration marked by completed features resulting in working software.</p>\n<p>The Project Status review should include −</p>\n<ul class=\"list\">\n<li>Where is the project?</li>\n<li>Where is the project versus the plans?</li>\n<li>Where should the project be?</li>\n</ul>\n<p>As the plans in the Adaptive Software Development projects are speculative, more than the question 2 above, question 3 is important. That is, the project team and the customers need to continuously ask themselves, \"What have we learned so far, and does it change our perspective on where we need to go?\"</p>"
          ]
        },
        {
          "tag_line": "Management",
          "details": [
            "<p>A flowchart of the Traditional software management is shown below.</p>\n<img src=\"/adaptive_software_development/images/reevaluation.jpg\" alt=\"Reevaluation\">\n<p>Traditional software management has been characterized by the term command-control.</p>\n<p>Many organizations are steeped in a tradition of optimization, efficiency, predictability, control, rigor and process improvement. However, the emerging information age economy requires adaptability, speed, collaboration, improvisation, flexibility, innovation, and suppleness.</p>\n<p>Harvard business review and management books have come up with the terms such as empowerment, participative management, learning organization, human-centered management, etc., but none of these are being put into managing modern organizations.</p>\n<p>In the context of Adaptive Software Development, the gap looks much wider and there is a necessity to consider the Adaptive management techniques that have been proven successful in other fields.</p>\n<h2>Adaptive Management</h2>\n<p>Adaptive management has proven successful in the environments where the resource managers worked together with stakeholders and scientists as a team, with the following goals −</p>\n<ul class=\"list\">\n<li><p>To learn how managed systems respond to human interventions.</p></li>\n<li><p>To improve resource policies and practices in future.</p></li>\n</ul>\n<p>The principle behind adaptive management is that many resource management activities are experiments as their outcomes cannot be reliably predicted beforehand. These experiments are then used as learning opportunities for the improvements in the future.</p>\n<p>Adaptive management is intended to increase the ability to respond timely in the face of new information and in a setting of varied stakeholder objectives and preferences. It encourages stakeholders to bound disputes and discuss them in an orderly fashion while the environmental uncertainties are being investigated and better understood.</p>\n<p>Adaptive management helps the stakeholders, the managers and other decision makers recognize the limits of knowledge and the need to act on imperfect information.</p>\n<p>Adaptive management helps to change the decisions made by making it clear that −</p>\n<ul class=\"list\">\n<li>The decisions are provisional.</li>\n<li>A management’s decision need not always be right.</li>\n<li>Modifications are expected.</li>\n</ul>\n<p>There are two types of Adaptive management approaches −</p>\n<ul class=\"list\">\n<li>Passive Adaptive Management.</li>\n<li>Active Adaptive Management.</li>\n</ul>\n<h2>Passive Adaptive Management</h2>\n<p>Adaptive management aims to enhance the scientific knowledge and thereby reduce uncertainties.</p>\n<img src=\"/adaptive_software_development/images/passive_adaptive.jpg\" alt=\"Passive Adaptive\">\n<p>Within Passive Adaptive management, a single preferred course of action, based on existing information and understanding, is selected. The outcomes of management actions are monitored, and subsequent decisions are adjusted based on the outcomes.</p>\n<p>This approach contributes to the learning and effective management. However, it is limited in its ability to enhance scientific and management capabilities for conditions that go beyond the course of action selected.</p>\n<h2>Active Adaptive Management</h2>\n<p>An Active Adaptive management approach reviews the information before management actions are taken.</p>\n<img src=\"/adaptive_software_development/images/active_adaptive.jpg\" alt=\"Active Adaptive\">\n<p>A range of competing, alternative system models of ecosystem and related responses (e.g. demographic changes; recreational uses), rather than a single model, is then developed. Management options are chosen based on the evaluations of these alternative models.</p>\n<h2>Leadership-Collaboration Management</h2>\n<p>Adaptive management is what is best suited for Adaptive Software Development. The approach requires resource managers, i.e. the managers who can work with people, allow human-interventions, and create an amicable environment.</p>\n<p>In software development, the leaders often take up these responsibilities. We need leaders more than the commanders. The leaders are collaborators and work alongside with the team. Collaborative-Leadership is the most sought after practice in Adaptive development.</p>\n<p>The leaders have the following qualities −</p>\n<ul class=\"list\">\n<li><p>Grasp and set the direction.</p></li>\n<li><p>Influence people involved and provide guidance.</p></li>\n<li><p>Collaborate, facilitate and macro-manage the team.</p></li>\n<li><p>Provide direction.</p></li>\n<li><p>Create environments where talented people can be innovative, creative, and make effective decisions.</p></li>\n<li><p>Understand that occasionally they need to command, but that is not their predominant style.</p></li></ul>"
          ]
        }
      ]
    },
    {
      "title": "Agile Methodology",
      "content": [
        {
          "tag_line": "About Agile Methodology ",
          "details": [
            "<p>Agile is a software development methodology to build a software incrementally using short iterations of 1 to 4 weeks so that the development is aligned with the changing business needs. This simple tutorial uses appropriate examples to help you understand agile development in a general and quick way.</p>\n<h1>Audience</h1>\n<p>This tutorial has been prepared for beginners to help them understand the basics of Agile principles and its implementation. After completing this tutorial, you will find yourself at a moderate level of expertise, from where you can advance further.</p>\n<h1>Prerequisites</h1>\n<p>Before proceeding with this tutorial, you need a basic knowledge of software development concepts such as software requirements, coding, testing, etc.</p>"
          ]
        },
        {
          "tag_line": "Primer",
          "details": [
            "<p>Agile is a software development methodology to build a software incrementally using short iterations of 1 to 4 weeks so that the development process is aligned with the changing business needs. Instead of a single-pass development of 6 to 18 months where all the requirements and risks are predicted upfront, Agile adopts a process of frequent feedback where a workable product is delivered after 1 to 4 week iteration.</p>\n<img src=\"/agile/images/agile_vs_traditional.jpg\" alt=\"Agile Vs Traditional SDLC\">\n<h2>Roles in Agile</h2>\n<h3>Scrum Master</h3>\n<p>A Scrum Master is a team leader and facilitator who helps the team members to follow agile practices so that they can meet their commitments. The responsibilities of a scrum master are as follows −</p>\n<ul class=\"list\">\n<li><p>To enable close co-operation between all roles and functions.</p></li>\n<li><p>To remove any blocks.</p></li>\n<li><p>To shield the team from any disturbances.</p></li>\n<li><p>To work with the organization to track the progress and processes of the company.</p></li>\n<li><p>To ensure that Agile Inspect &amp; Adapt processes are leveraged properly which includes</p>\n<ul class=\"list\">\n<li>Daily stand-ups,</li>\n<li>Planned meetings,</li>\n<li>Demo,</li>\n<li>Review,</li>\n<li>Retrospective Meetings, and</li>\n<li>To facilitate team meetings and decision-making process.</li>\n</ul>\n</li>\n</ul>\n<h3>Product Owner</h3>\n<p>A Product Owner is the one who drives the product from business perspective. The responsibilities or a Product Owner are as follows −</p>\n<ul class=\"list\">\n<li>To define the requirements and prioritize their values.</li>\n<li>To determine the release date and contents.</li>\n<li>To take an active role in iteration planning and release planning meetings.</li>\n<li>To ensure that team is working on the most valued requirement.</li>\n<li>To represent the voice of the customer.</li>\n<li>To accept the user stories that meet the definition of done and defined acceptance criteria.</li>\n</ul>\n<h2>Cross-functional Team</h2>\n<p>Every agile team should be a self-sufficient team with 5 to 9 team members and an average experience ranging from of 6 to 10 years. Typically, an agile team comprises of 3 to 4 developers, 1 tester, 1 technical lead, 1 product owner and 1 scrum master.</p>\n<img src=\"/agile/images/cross_functional_team.jpg\" alt=\"Cross functional Team\">\n<p>Product Owner and Scrum master are considered to be a part of Team Interface, whereas other members are part of Technical Interface.</p>\n<h2>How an Agile Team Plans its Work?</h2>\n<p>An Agile team works in iterations to deliver user stories where each iteration is of 10 to 15 days. Each user story is planned based on its backlog prioritization and size. The team uses its capacity − how many hours are available with team to work on tasks − to decide how much scope they have to plan.</p> \n<img src=\"/agile/images/planning.jpg\" alt=\"Planning\">\n<h3>Point</h3>\n<p>A Point defines how much a team can commit. A point usually refers to 8 hours. Each story is estimated in points.</p>\n<h3>Capacity</h3>\n<p>Capacity defines how much an individual can commit. Capacity is estimated in hours.</p>\n<h2>What is a User Story?</h2>\n<p>A user story is a requirement which defines what is required by the user as functionality. A user story can be in two forms −</p>\n<ul class=\"list\">\n<li>As a &lt;User Role&gt; I want &lt;Functionality&gt; so that &lt;Business Value&gt;</li>\n<li>In order to &lt;Business value&gt; as a &lt;User Role&gt; I want &lt;Functionality&gt;</li>\n</ul>\n<p>During release planning, a rough estimate is given to a user story using relative scale as points. During iteration planning, the story is broken down into tasks.</p>\n<h2>Relationship of User Stories and Tasks</h2>\n<ul class=\"list\">\n<li>User story talks about what is to be done. It defines what a user needs.</li>\n<li>Task talks about how it is to be done. It defines how a functionality is to be implemented.</li>\n<li>Stories are implemented by tasks. Each story is a collection of tasks.</li>\n<li>User story is divided into tasks when it is planned in current iteration.</li>\n<li>Tasks are estimated in hours, typically from 2 to 12 hours.</li>\n<li>Stories are validated using acceptance tests.</li>\n</ul>\n<img src=\"/agile/images/user_story_relationship.jpg\" alt=\"Relationship of User Stories and Tasks\">\n<h2>When a Story is Done</h2>\n<p>The team decides what <b>done</b> means. The criteria may be −</p>\n<ul class=\"list\">\n<li>All tasks (development, testing) are completed.</li>\n<li>All acceptance tests are running and are passed.</li>\n<li>No defect is open.</li>\n<li>Product owner has accepted the story.</li>\n<li>Deliverable to the end-user.</li>\n</ul>\n<h2>What is Acceptance Criteria?</h2>\n<p>Criteria defines the functionality, behavior, and performance required by a feature so that it can be accepted by the product owner. It defines what is to be done so that the developer knows when a user story is complete.</p>\n<h2>How the Requirements are Defined?</h2>\n<p>Requirements are defined as</p>\n<ul class=\"list\">\n<li>A User Story,</li>\n<li>With Acceptance Criteria, and </li>\n<li>Tasks to implement the story.</li></ul>"
          ]
        },
        {
          "tag_line": "Manifesto",
          "details": [
            "<p>In February 2001, at the Snowbird resort in Utah, 17 software developers met to discuss lightweight development methods. The outcome of their meeting was the following Agile Manifesto for software development −</p>\n<blockquote>\n<p>We are uncovering better ways of developing software by doing it and helping others do it. Through this work, we have come to value −</p>\n<ul class=\"list\">\n<li>Individuals and interactions over Processes and tools</li>\n<li>Working software over Comprehensive documentation</li>\n<li>Customer collaboration over Contract negotiation</li>\n<li>Responding to change over Following a plan</li>\n</ul>\n<p>That is, while there is value in the items on the right, we value the items on the left more.</p>\n</blockquote>\n<h2>Twelve Principles of Agile Manifesto</h2>\n<ul class=\"list\">\n<li><p><b>Customer Satisfaction</b> − Highest priority is given to satisfy the requirements of customers through early and continuous delivery of valuable software.</p></li>\n<li><p><b>Welcome Change</b> − Changes are inevitable during software development. Ever-changing requirements should be welcome, even late in the development phase. Agile processes should work to increase customers' competitive advantage.</p></li>\n<li><p><b>Deliver a Working Software</b> −  Deliver a working software frequently, ranging from a few weeks to a few months, considering shorter time-scale.</p></li>\n<li><p><b>Collaboration</b> − Business people and developers must work together during the entire life of a project. </p></li>\n<li><p><b>Motivation</b> − Projects should be built around motivated individuals. Provide an environment to support individual team members and trust them so as to make them feel responsible to get the job done.</p></li>\n<li><p><b>Face-to-face Conversation</b> − Face-to-face conversation is the most efficient and effective method of conveying information to and within a development team.</p></li>\n<li><p><b>Measure the Progress as per the Working Software</b> − Working software is the key and it should be the primary measure of progress.</p></li>\n<li><p><b>Maintain Constant Pace</b> − Agile processes aim towards sustainable development. The business, the developers, and the users should be able to maintain a constant pace with the project.</p></li>\n<li><p><b>Monitoring</b> − Pay regular attention to technical excellence and good design to enhance agility.</p></li>\n<li><p><b>Simplicity</b> − Keep things simple and use simple terms to measure the work that is not completed.</p></li>\n<li><p><b>Self-organized Teams</b> − An agile team should be self-organized and should not depend heavily on other teams because the best architectures, requirements, and designs emerge from self-organized teams.</p></li>\n<li><p><b>Review the Work Regularly</b> − Review the work done at regular intervals so that the team can reflect on how to become more effective and adjust its behavior accordingly.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Characteristics",
          "details": [
            "<h2>Iterative/incremental and Ready to Evolve</h2>\n<p>Most of the agile development methods break a problem into smaller tasks. There is no direct long-term planning for any requirement. Normally, iterations are planned which are of vary short period of time, for example, 1 to 4 weeks. A cross-functional team is created for each iteration that works in all functions of software development like planning, requirements analysis, design, coding, unit testing, and acceptance testing. The result at the end of the iteration is a working product and it is demonstrated to the stakeholders at the end of an iteration.</p>\n<p>After demo, review comments are taken and are planned to be incorporated in the working software as required.</p>\n<h2>Face-to-face Communication</h2>\n<p>Each agile team should have a customer representative such as a product owner in scrum methodology. This representative is authorized to act on behalf of the stakeholders and he can answer the queries of the developers in between iterations. </p>\n<p>An information radiator (physical display) is normally located prominently in an office, where passers-by can see the progress of the agile team. This information radiator shows an up-to-date summary of the status of a project.</p>\n<h2>Feedback Loop</h2>\n<p>Daily stand-up is a common culture of any agile development; it is also known as <b>daily scrum</b>. It is a kind of a brief session where each team member reports to each other regarding the status of what they have done, what to do next, and any issues they are facing.</p>"
          ]
        },
        {
          "tag_line": "Daily Stand-up",
          "details": [
            "<p>Daily stand-up, as the name suggests, is a daily status meeting among all the members of an agile team. It not only provides a forum for regular updates but also brings the problems of team members into focus so that it can be quickly addressed. Daily stand-up is a must-do practice, no matter how an agile team is established regardless of its office location.</p>\n<h2>What is Daily Stand-up?</h2>\n<ul class=\"list\">\n<li><p>A daily stand-up is a daily status meeting among all team members and it is held roughly for 15 minutes.</p></li>\n<li><p>Every member has to answer three important questions −</p>\n<ul class=\"list\">\n<li>What I did yesterday?</li>\n<li>What I'll do today?</li>\n<li>Any impediment I am facing.../ I am blocked due to...</li>\n</ul>\n</li>\n<li><p>Daily stand-up is for status update, not for any discussion. For discussion, team members should schedule another meeting at a different time.</p></li>\n<li><p>Participants usually stand instead of sitting so that the meeting gets over quickly.</p></li>\n</ul>\n<h2>Why Stand-up is Important?</h2>\n<p>The benefits of having a daily stand-up in agile are as follows −</p>\n<ul class=\"list\">\n<li>The team can evaluate the progress on a daily basis and see if they can deliver as per the iteration plan.</li>\n<li>Each team member informs all about his/ her commitments for the day.</li>\n<li>It provides visibility to the team on any delay or obstacles.</li>\n</ul>\n<h2>Who Attends a Stand-up?</h2>\n<ul class=\"list\">\n<li><p>The scrum master, the product owner, and the delivery team should attend the stand-up on a daily basis.</p></li>\n<li><p>Stakeholders and Customers are encouraged to attend the meeting and they can act as an observer, but they are not supposed to participate in stand-ups.</p></li>\n<li><p>It is the scrum master's responsibility to take note of each team member's queries and the problems they are facing.</p></li>\n</ul>\n<h2>Geographically Dispersed Teams</h2>\n<p>Stand-ups can be done in multiple ways, in case the agile team members are operating from different time zones −</p>\n<ul class=\"list\">\n<li><p>Select a member on a rotational basis, who can attend the stand-up meeting of teams located in different time zones.</p></li>\n<li><p>Have a separate stand-up per team, update the status of the stand-up in a tool such as Rally, SharePoint, Wikis, etc.</p></li>\n<li><p>Have a wide variety of communication tools ready like conference call, video conferencing, instant messengers, or any other third-party knowledge sharing tools.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Definition of Done",
          "details": [
            "<p>The definition of <b>done</b> for User Story, Iteration, and Release is given below.</p>\n<h2>User Story</h2>\n<p>A user story is a requirement which is formulated in a few sentences in everyday language of an user and it should be completed within an iteration. A user story is done when</p>\n<ul class=\"list\">\n<li>All the related code have been checked-in.</li>\n<li>All the unit test cases have been passed.</li>\n<li>All the acceptance test cases have been passed.</li>\n<li>Help text is written.</li>\n<li>Product Owner has accepted the story.</li>\n</ul>\n<h2>Iteration</h2>\n<p>An iteration is a time boxed collection of user stories / defects to be worked upon and accepted within the release of a product. Iterations are defined during iteration planning meeting and completed with an iteration demo and review meeting. An iteration is also termed as a <b>sprint</b>. An iteration is done when</p>\n<ul class=\"list\">\n<li>Product backup is complete.</li>\n<li>Performance has been tested.</li>\n<li>User stories have been accepted or moved to the next iteration.</li>\n<li>Defects have been fixed or postponed to the next iteration.</li>\n</ul>\n<h2>Release</h2>\n<p>A release is a major milestone that represents an internal or external delivery of working, tested version of the product/system. A release is done when</p>\n<ul class=\"list\">\n<li>System is stress tested.</li>\n<li>Performance is tuned.</li>\n<li>Security validations are carried out.</li>\n<li>Disaster recovery plan is tested.</li></ul>"
          ]
        },
        {
          "tag_line": "Release Planning",
          "details": [
            "<p>The purpose of release planning is to create a plan to deliver an increment to the product. It is done after every 2 to 3 months.</p>\n<img src=\"/agile/images/agile_release_planning.jpg\" alt=\"Release planning\">\n<h2>Who is Involved?</h2>\n<ul class=\"list\">\n<li><p><b>Scrum Master</b> − The scrum master acts as a facilitator for the agile delivery team.</p></li>\n<li><p><b>Product Owner</b> − The product owner represents the general view of the product backlog.</p></li>\n<li><p><b>Agile Team</b> − Agile delivery team provides insights on the technical feasibilities or any dependencies.</p></li>\n<li><p><b>Stakeholders</b> − Stakeholders like customers, program managers, subject matter experts act as advisers as decisions are made around the release planning.</p></li>\n</ul>\n<h2>Prerequisites of Planning</h2>\n<p>The prerequisites of release planning are as follows −</p>\n<ul class=\"list\">\n<li><p>A ranked product backlog, managed by the Product Owner. Generally five to ten features are taken which the product owner feels that can be included in a release</p></li>\n<li><p>Team's input about capabilities, known velocity or about any technical challenge</p></li>\n<li><p>High-level vision</p></li>\n<li><p>Market and Business objective</p></li>\n<li><p>Acknowledgement whether new product backlog items are needed</p></li>\n</ul>\n<h2>Materials Required</h2>\n<p>The list of materials required for release planning is as follows −</p>\n<ul class=\"list\">\n<li>Posted agenda, purpose</li>\n<li>Flip charts, whiteboards, markers</li>\n<li>Projector, way to share computers having data/tools required during planning meeting</li>\n<li>Planning data</li>\n</ul>\n<h2>Planning Data</h2>\n<p>The list of data required to do release planning is as follows −</p>\n<ul class=\"list\">\n<li>Previous iterations or release planning results</li>\n<li>Feedback from various stakeholders on product, market conditions, and deadlines</li>\n<li>Action plans of previous releases / iterations</li>\n<li>Features or defects to be considered</li>\n<li>Velocity from previous releases/ estimates.</li>\n<li>Organizational and personal calendars</li>\n<li>Inputs from other teams and subject matter experts to manage any dependencies</li>\n</ul>\n<h2>Output</h2>\n<p>The output of a release planning can be the following −</p>\n<ul class=\"list\">\n<li>Release plan</li>\n<li>Commitment</li>\n<li>Issues, concerns, dependencies, and assumptions which are to be monitored</li>\n<li>Suggestions to improve future release plannings</li>\n</ul>\n<h2>Agenda</h2>\n<p>The agenda of a release planning can be −</p>\n<ul class=\"list\">\n<li><p><b>Opening ceremony</b> − Welcome message, review purpose and agenda, organizing tools and introduction to business sponsors.</p></li>\n<li><p><b>Product Vision, Roadmap</b> − Show the large picture of the product.</p></li>\n<li><p><b>Review previous releases</b> − Discussion on any item which can impact the plan.</p></li>\n<li><p><b>Release name / theme</b> − Inspect the current status of roadmap themes and do the required adjustments, if any.</p></li>\n<li><p><b>Velocity</b> − Present the velocity for the current release and of previous releases.</p></li>\n<li><p><b>Release schedule</b> − Review key milestones and decision on time boxes for release and iterations within release.</p></li>\n<li><p><b>Issues and concerns</b> − Check any concerns or issue and record them.</p></li>\n<li><p><b>Review and Update the Definition of Done</b> − Review the definition of <b>done</b> and make appropriate changes based on technology, skill, or changes in team members since the last iteration / release.</p></li>\n<li><p><b>Stories and items to be considered</b> − Present the user stories and features from the product backlog to be considered for scheduling in the current release.</p></li>\n<li><p><b>Determine sizing values</b> − If the velocity is unknown, then plan the sizing values to be used in the release planning.</p></li>\n<li><p><b>Coarse the size of stories</b> −  The delivery team determines the appropriate size of the stories under consideration and splits the stories into multiple iterations if a story is too large. The product owner and the subject matter experts clarify the doubts, elaborate the acceptance criteria, and make proper story splits. The scrum master facilitates the collaboration.</p></li>\n<li><p><b>Map stories to iterations</b> − The delivery team and the product owner move the stories/defects in the iterations based on the size and velocity. The scrum master facilitates the collaboration.</p></li>\n<li><p><b>New concerns or issues</b> − Check any new issues based on previous experience and record the same.</p></li>\n<li><p><b>Dependencies and assumptions</b> − Check any dependencies/assumptions planned during the release planning.</p></li>\n<li><p><b>Commit</b> − The scrum master calls for the planning. Delivery team and Product owner signal it as the best plan and then commit to move to the next level of planning, that is, iteration planning.</p></li>\n<li><p><b>Communication and logistics planning</b> − Review/Update the communication and logistics planning for the release.</p></li>\n<li><p><b>Parking lot</b> − Process parking lot means all items should be either resolved or set as action items.</p></li>\n<li><p><b>Distribute Action items and action plans</b> − Distribute the action items among their owners, process the action plan.</p></li>\n<li><p><b>Retrospect</b> − Solicit feedback from participants to make the meeting successful.</p></li>\n<li><p><b>Close</b> − Celebrate the success.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Iteration Planning",
          "details": [
            "<p>The purpose of iteration planning is for the team to complete the set of top-ranked product backlog items. This commitment is time boxed based on the length of iteration and team velocity.</p>\n<img src=\"/agile/images/agile_iteration_planning.jpg\" alt=\"Iteration Planning\">\n<h2>Who is Involved?</h2>\n<ul class=\"list\">\n<li><p><b>Scrum Master</b> − The scrum master acts as a facilitator for the agile delivery team.</p></li>\n<li><p><b>Product Owner</b> − The product owner deals with the detailed view of the product backlog and their acceptance criteria.</p></li>\n<li><p><b>Agile Team</b> − Agile delivery defines their tasks and sets the effort estimates required to fulfil the commitment.</p></li>\n</ul>\n<h2>Prerequisites of Planning</h2>\n<ul class=\"list\">\n<li>Items in product backlog are sized and have a relative story point assigned.</li>\n<li>Ranking has been given to portfolio items by the product owner.</li>\n<li>Acceptance criteria has been clearly stated for each portfolio item.</li>\n</ul>\n<h2>Planning Process</h2>\n<p>Following are the steps involved in iteration planning −</p>\n<ul class=\"list\">\n<li>Determine how many stories can fit in an iteration.</li>\n<li>Break these stories into tasks and assign each task to their owners.</li>\n<li>Each task is given estimates in hours.</li>\n<li>These estimates help team members to check how many task hours each member have for the iteration.</li>\n<li>Team members are assigned tasks considering their velocity or capacity so that they are not overburdened.</li>\n</ul>\n<h2>Velocity Calculation</h2>\n<p>An agile team calculates velocity based on past iterations. Velocity is an average number of units required to finish user stories in an iteration. For example, if a team took 12, 14, 10 story points in each iteration for the last three iterations, the team can take 12 as velocity for the next iteration.</p>\n<p>Planned velocity tells the team how many user stories can be completed in the current iteration. If the team quickly finishes the tasks assigned, then more user stories can be pulled in. Otherwise, stories can be moved out too to the next iteration.</p>\n<h2>Task Capacity</h2>\n<p>The capacity of a team is derived from the following three facts −</p>\n<ul class=\"list\">\n<li>Number of ideal working hours in a day</li>\n<li>Available days of person in the iteration</li>\n<li>Percentage of time a member is exclusively available for the team.</li>\n</ul>\n<p>Suppose a team has 5 members, committed to work full time (8 hours a day) on a project and no one is on leave during an iteration, then the task capacity for a two-week iteration will be −</p>\n<p style=\"text-align:center;\">5 × 8 × 10 = 400 hours</p>\n<h2>Planning Steps</h2>\n<ul class=\"list\">\n<li>Product Owner describes the highest ranked item of product backlog.</li>\n<li>Team describes the tasks required to complete the item.</li>\n<li>Team members own the tasks.</li>\n<li>Team members estimate the time to finish each task.</li>\n<li>These steps are repeated for all the items in the iteration.</li>\n<li>If any individual is overloaded with tasks, then his/her task is distributed among other team members.</li></ul>"
          ]
        },
        {
          "tag_line": "Product Backlog",
          "details": [
            "<p>A product backlog is a list of items to be done. Items are ranked with feature descriptions. In an ideal scenario, items should be broken down into user stories.</p>\n<h2>Why Product Backlog is Important?</h2>\n<ul class=\"list\">\n<li>It is prepared so that estimates can be given to each and every feature.</li>\n<li>It helps in planning the roadmap for the product.</li>\n<li>It helps in re-ranking the features so that more value can be added to the product.</li>\n<li>It helps in determining what to prioritize first. Team ranks the item and then builds value.</li>\n</ul>\n<h2>Characteristics of Product Backlog</h2>\n<ul class=\"list\">\n<li><p>Each product should have one product backlog which can have a set of large to very large features.</p></li>\n<li><p>Multiple teams can work on a single product backlog.</p></li>\n<li><p>Ranking of features is done based on business value, technical value, risk management or strategic fitness.</p></li>\n<li><p>Highest ranking items are decomposed into smaller stories during release planning so that they can be completed in future iterations.</p></li></ul>"
          ]
        },
        {
          "tag_line": "Useful Terms",
          "details": [
            "<h2>Acceptance Criteria</h2>\n<p>It is the conditions set by the product owner or the customer in order to accept a feature to be valid and adhering to their requirements.</p>\n<h2>Backlog Grooming</h2>\n<p>It is an ongoing process in which the product manager or the customer manages the product backlog by getting feedback from agile teams. This process involves prioritizing the portfolio items, breaking them in smaller items, planning them for future iterations, creating new stories, updating acceptance criteria or elaborating acceptance criteria in details.</p>\n<h2>Capacity</h2>\n<p>It is the amount of work a team can take to complete in one iteration.</p>\n<h2>Feature</h2>\n<p>An improvement done to a product or capability of value to stakeholder which can be developed in a release.</p>\n<h2>Iteration</h2>\n<p>A theme-based work item that can be completed within a time box and accepted within the release of a product. Iteration work is defined during iteration planning and it finishes with demo and review meeting. It is also termed as Sprint.</p>\n<h2>Increment</h2>\n<p>An increment is the changing state of a product as it undergoes gradual development. It is normally represented by milestones or number of fixed iterations.</p>\n<h2>Product Owner</h2>\n<p>The product owner is a member of the Agile delivery team, responsible to collect and rank business requirements in the product backlog. A product owner communicates what is to be done in a release/iteration. He/she sets the commitments and is responsible to protect team from any change in requirements during an iteration.</p>\n<h2>Product Backlog</h2>\n<p>Set of functional and non-functional product requirements.</p>\n<h2>Product Backlog Items </h2>\n<p>May be user stories, defects, features which are to be developed by the agile team.</p>\n<h2>Points</h2>\n<p>A common unit used to set the relative size of user stories, features, or any other portfolio items.</p>\n<h2>Release</h2>\n<p>A time box where work is done to support delivery of testable increment to a software. In scrum, a release consists of multiple iterations.</p>\n<h2>Requirement</h2>\n<p>A specification of a software product to satisfy a stated contract or functionality. User stories and portfolio items are types of requirements.</p>\n<h2>Story Points</h2>\n<p>A unit used by the agile team to estimate relative sizes of user stories and features.</p>\n<h2>Sprint</h2>\n<p>Same as Iteration.</p>\n<h2>Timebox</h2>\n<p>A fixed duration of time in which a deliverable is to be developed. Normally, along with fixing start and end date of a timebox, the number of resources is also fixed.</p>\n<h2>Task</h2>\n<p>It is a unit of work that contributes towards the completion of a user story within an iteration. User stories are decomposed into multiple tasks and each task can be divided between team members marking them as owner of the tasks. Team members can take responsibility of each task, update estimates, log work done or to-do as desired.</p>\n<h2>User Story</h2>\n<p>A listed acceptance criteria to fulfil certain requirements of a user. It is normally written from the perspective of an end-user.</p>\n<h2>Velocity</h2>\n<p>A measure to weight the accepted work in an iteration or timebox. Normally it is the sum of story points accepted in an iteration.</p>"
          ]
        }
      ]
    },
    {
      "title": "Agile Data Science",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Computer Programming",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Inter Process Communication",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Basics of Computers",
      "content": [
        {
          "tag_line": "Template",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Basics of Computer Science",
      "content": [
        {
          "tag_line": "Template lo",
          "details": [
            ""
          ]
        }
      ]
    }
  ]
}