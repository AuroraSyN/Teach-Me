{
  "items": [
    {
      "title": "C++17",
      "content": [
        {
          "tag_line": "Свертка параметров шаблона",
          "qType": "ru_1",
          "details": [
            "<ul class=\"post__hubs post__hubs_full-post inline-list\"><li class=\"inline-list__item inline-list__item_hub\"><a href=\"https://habr.com/ru/company/pvs-studio/\" class=\"inline-list__item-link hub-link \" title=\"Вы не подписаны на этот хаб\" onclick=\"if (typeof ga === 'function') { ga('send', 'event', 'hub', 'post page', 'Блог компании PVS-Studio'); }\">Блог компании PVS-Studio</a>, \n          </li>\n          <li class=\"inline-list__item inline-list__item_hub\">\n            <a href=\"https://habr.com/ru/hub/cpp/\" class=\"inline-list__item-link hub-link \" title=\"Вы не подписаны на этот хаб\" onclick=\"if (typeof ga === 'function') { ga('send', 'event', 'hub', 'post page', 'C++'); }\">C++</a>, \n          </li>\n          <li class=\"inline-list__item inline-list__item_hub\">\n            <a href=\"https://habr.com/ru/hub/compilers/\" class=\"inline-list__item-link hub-link \" title=\"Вы не подписаны на этот хаб\" onclick=\"if (typeof ga === 'function') { ga('send', 'event', 'hub', 'post page', 'Компиляторы'); }\">Компиляторы</a>\n          </li>\n      </ul>\n\n    <ul class=\"post__marks inline-list\"></ul>\n\n    <div class=\"post__body post__body_full\">\n      <div class=\"post__text post__text-html js-mediator-article\"><p><img src=\"https://habrastorage.org/getpro/habr/post_images/150/aca/98e/150aca98ef9de93d2b53062ab916e468.png\" alt=\"Рисунок 2\"></p><br>\nЯзык C++ постоянно развивается, и нам как разработчикам статического анализатора важно следить за всеми изменениями, чтобы поддерживать все новые возможности языка. В этой обзорной статье я хотел бы поделиться с читателем наиболее интересными нововведениями, появившимися в C++17, а также продемонстрировать их на примерах.<br>\n<a name=\"habracut\"></a><br>\nСейчас поддержка нового стандарта активно добавляется разработчиками компиляторов. Посмотреть, что поддерживается на текущий момент, можно по ссылкам:<br>\n<br>\n<ul>\n<li><a href=\"https://gcc.gnu.org/projects/cxx-status.html\">GCC</a></li>\n<li><a href=\"https://clang.llvm.org/cxx_status.html\">Clang</a></li>\n<li><a href=\"https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance\">Visual Studio</a></li>\n</ul><br>\n<h2>Свертка параметров шаблона (Fold expressions)</h2><br>\nДля начала несколько слов о том, что вообще такое свертка списка (также известна как fold, reduce или accumulate).<br>\n<br>\nСвертка – это функция, которая применяет заданную комбинирующую функцию к последовательным парам элементов в списке и возвращает результат. Простейшим примером может служить суммирование элементов списка при помощи свертки:<br>\n<br>\nПример из C++:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">vector</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>&gt; lst = { <span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">7</span></span> };\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> res = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::accumulate(lst.begin(), lst.end(), <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, \n  [](<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> a, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> b)  { <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> a + b; });\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; res &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 16</span></span></code></pre><br>\nЕсли комбинирующая функция применяется к первому элементу списка и результату рекурсивной обработки хвоста списка, то свертка называется <b>правоассоциативной. </b>В нашем примере получим:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span> + (<span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span> + (<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span> + (<span class=\"hljs-number\"><span class=\"hljs-number\">7</span></span> + <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>)))</code></pre><br>\nЕсли комбинирующая функция применяется к результату рекурсивной обработки начала списка <i>(весь список без последнего элемента)</i> и последнему элементу, то свертка называется <b>левоассоциативной</b>. В нашем примере получим:<br>\n<br>\n<pre><code class=\"cpp hljs\">(((<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span> + <span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>) + <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>) + <span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>) + <span class=\"hljs-number\"><span class=\"hljs-number\">7</span></span></code></pre><br>\nТаким образом, тип свертки определяет порядок вычислений.<br>\n<br>\nВ C++17 появилась поддержка свертки для списка параметров шаблонов. Она имеет следующий синтаксис:<br>\n<table>\n<tbody><tr>\n<td>(pack op ...)</td>\n<td>Унарная правоассоциативная свертка</td>\n</tr>\n<tr>\n<td>(… op pack)</td>\n<td>Унарная левоассоциативная свертка</td>\n</tr>\n<tr>\n<td>(pack op… op init)</td>\n<td>Бинарная правоассоциативная свертка</td>\n</tr>\n<tr>\n<td>(init op… op pack)</td>\n<td>Бинарная левоассоциативная свертка</td>\n</tr>\n</tbody></table><br>\n<i>op</i> – один из следующих бинарных операторов:<br>\n<br>\n<pre><code class=\"cpp hljs\">+ - * / % ^ &amp; | ~ = &lt; &gt; &lt;&lt; &gt;&gt; += -= *= /= %=\n^= &amp;= |= &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || , .* -&gt;*</code></pre><br>\n<i>pack</i> – выражение, содержащее нераскрытую группу параметров (parameter pack)<br>\n<br>\n<i>init</i> – начальное значение<br>\n<br>\nВот, например, шаблонная функция, принимающая переменное число параметров и вычисляющая их сумму:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span></span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span>... Args&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Sum</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(Args... args)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> (args + ...);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; Sum(<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>) &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 15</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nПримечание: В данном примере функцию <i>Sum </i> можно было бы объявить как <i>constexpr</i>.<br>\n<br>\nЕсли мы хотим указать начальное значение, то используем бинарную свертку:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span></span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span>... Args&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Func</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(Args... args)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> (args + ... + <span class=\"hljs-number\"><span class=\"hljs-number\">100</span></span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; Func(<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>) &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">//115</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nДо C++17 чтобы реализовать подобную функцию, пришлось бы явно указывать правила для рекурсии:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++14</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Sum</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> Arg, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span>... Args&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Sum</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(Arg first, Args... rest)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> first + Sum(rest...);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; Sum(<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 10</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nОтдельно хочется отметить оператор ',' (запятая), который раскроет <i>pack</i> в последовательность действий, перечисленных через запятую. Пример:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span></span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span>... Args&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">PushToVector</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(</span></span><span class=\"hljs-built_in\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-built_in\">std</span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">::</span></span><span class=\"hljs-built_in\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-built_in\">vector</span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">&lt;T&gt;&amp; v, Args&amp;&amp;... args)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  (v.push_back(<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::forward&lt;Args&gt;(args)), ...);\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">//Раскрывается в последовательность выражений через запятую вида:</span></span>\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">//v.push_back(std::forward&lt;Args_1&gt;(arg1)),</span></span>\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">//v.push_back(std::forward&lt;Args_2&gt;(arg2)),</span></span>\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">//....</span></span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">vector</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>&gt; vct;\n  PushToVector(vct, <span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">8</span></span>);\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nТаким образом, свертка сильно упрощает работу с variadic templates.<br>\n<br>\n<h2>template&lt;auto&gt;</h2><br>\nТеперь в шаблонах можно писать auto для non-type template параметров. Например:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> n&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Func</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{ <span class=\"hljs-comment\"><span class=\"hljs-comment\">/* .... */</span></span> }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  Func&lt;<span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span>&gt;(); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// выведет тип int</span></span>\n  Func&lt;<span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>&gt;(); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// выведет тип char</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nРанее единственным способом передать non-type template параметр с неизвестным типом была передача двух параметров – типа и значения. Другими словами, ранее этот пример выглядел бы следующим образом:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++14</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> Type, Type n&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Func</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{ <span class=\"hljs-comment\"><span class=\"hljs-comment\">/* .... */</span></span> }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  Func&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span>&gt;();\n  Func&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">char</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>&gt;();\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre></div></div>"
          ]
        },
        {
          "tag_line": "Вывод типов шаблонных параметров для классов",
          "qType": "ru_1",
          "details": [
            "<br>\nДо C++17 вывод типов шаблонных параметров работал только для функций, из-за чего при конструировании шаблонного класса всегда было нужно в явном виде указывать шаблонные параметры:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++14</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> p = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::pair&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">char</span></span>&gt;(<span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>);</code></pre><br>\nлибо использовать специализированные функции вроде <i>std::make_pair</i>, для неявного вывода типов:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++14</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> p = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::make_pair(<span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>);</code></pre><br>\nСвязано это было с тем, что достаточно сложно осуществить такой вывод при наличии нескольких конструкторов в классе. В новом стандарте эта проблема была решена:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;tuple&gt;</span></span></span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;array&gt;</span></span></span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> U&gt;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">S</span></span></span><span class=\"hljs-class\">\n{</span></span>\n  T m_first;\n  U m_second;\n  S(T first, U second) : m_first(first), m_second(second) {}\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++14</span></span>\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::pair&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">char</span></span>, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>&gt; p1 = { <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span> };\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::tuple&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">char</span></span>, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">double</span></span>&gt; t1 = { <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3.14</span></span> };\n  S&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">char</span></span>&gt; s1 = { <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span> };\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::pair p2 = { <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span> };\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::tuple t2 = { <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3.14</span></span> };\n  S s2 = { <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'c'</span></span> };\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nСтандартом было определено множество <a href=\"http://en.cppreference.com/w/cpp/language/class_template_argument_deduction\">правил вывода типов</a> (<i>deduction guides</i>). Также предоставляется возможность самим писать эти правила, например:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span></span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> U&gt;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">S</span></span></span><span class=\"hljs-class\">\n{</span></span>\n  T m_first;\n  U m_second;\n};\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// Мой deduction guide</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> U&gt;\nS(<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">const</span></span> T &amp;first, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">const</span></span> U &amp;second) -&gt; S&lt;T, U&gt;;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  S s = { <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">\"hello\"</span></span> };\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; s.m_first &lt;&lt; s.m_second &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>;\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nБольшинство стандартных контейнеров работают без необходимости вручную указывать <i>deduction guide</i>.<br>\n<br>\nПримечание: компилятор может вывести <i>deduction guide</i> автоматически из конструктора, но в данном примере у структуры <i>S </i> нет ни одного конструктора, поэтому и определяем <i>deduction guide вручную.</i><br>\n<br>\nТаким образом, вывод типов для классов позволяет значительно сократить код и забыть о таких функциях как <i>std::make_pair</i>, <i>std::make_tuple,</i> и использовать вместо них конструктор."
          ]
        },
        {
          "tag_line": "Constexpr if",
          "qType": "ru_1",
          "details": [
            "В C++17 появилась возможность выполнять условные конструкции на этапе компиляции. Это очень мощный инструмент, особенно полезный в метапрограммировании. Приведу простой пример:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span></span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">&lt;type_traits&gt;</span></span></span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span> &lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">GetValue</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(T t)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">if</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">constexpr</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(</span></span><span class=\"hljs-built_in\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-built_in\">std</span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">::is_pointer&lt;T&gt;::value)</span></span></span><span class=\"hljs-function\">\n  </span></span>{\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> *t;\n  }\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span>\n  {\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> t;\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> v = <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; GetValue(v) &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 10</span></span>\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; GetValue(&amp;v) &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 10</span></span>\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nДо C++17 нам пришлось бы использовать <a href=\"https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\">SFINAE</a> и <i>enable_if</i>:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++14</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T&gt;\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::enable_if&lt;<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::is_pointer&lt;T&gt;::value,\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">remove_pointer_t</span></span>&lt;T&gt;&gt;::<span class=\"hljs-function\"><span class=\"hljs-function\">type\n</span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">GetValue</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(T t)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> *t;\n}\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">template</span></span>&lt;<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> T&gt;\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">typename</span></span> <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::enable_if&lt;!<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::is_pointer&lt;T&gt;::value, T&gt;::<span class=\"hljs-function\"><span class=\"hljs-function\">type\n</span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">GetValue</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(T t)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> t;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> v = <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; GetValue(v) &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 10</span></span>\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; GetValue(&amp;v) &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 10</span></span>\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nНе трудно заметить, что код с <i>constexpr if</i> на порядок читабельнее.<br>\n"
          ]
        },
        {
          "tag_line": "Constexpr лямбды",
          "qType": "ru_1",
          "details": [
            "До C++17 лямбды не были совместимы с <i>constexpr</i>. Теперь лямбды можно писать внутри <i>constexpr</i> выражений, а также можно объявлять сами лямбды как <i>constexpr</i>.<br>\n<br>\nПримечание: даже если спецификатор <i>constexpr</i> не указан, лямбда все равно будет <i>constexpr</i>, если это возможно.<br>\n<br>\nПример с лямбдой внутри <i>constexpr</i> функции:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// С++17</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">constexpr</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Func</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(</span></span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\"> x)</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> f = [x]() { <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> x * x; };\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> x + f();\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">constexpr</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> v = Func(<span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>);\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">static_assert</span></span>(v == <span class=\"hljs-number\"><span class=\"hljs-number\">110</span></span>);\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre><br>\nПример с <i>constexpr </i> лямбдой:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// C++17</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">main</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n</span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">constexpr</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> squared = [](<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> x) { <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> x * x; };\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">constexpr</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> s = squared(<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>);\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">static_assert</span></span>(s == <span class=\"hljs-number\"><span class=\"hljs-number\">25</span></span>);\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}</code></pre>"
          ]
        },
        {
          "tag_line": "Захват *this в лямбда-выражениях",
          "qType": "ru_1",
          "details": [
            "Теперь лямбда-выражения могут захватывать члены класса по значению при помощи <i>*this</i>:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">SomeClass</span></span></span><span class=\"hljs-class\">\n{</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">public</span></span>:\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> m_x = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">f</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">const</span></span></span><span class=\"hljs-function\">\n  </span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">std</span></span>::<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">cout</span></span> &lt;&lt; m_x &lt;&lt; <span class=\"hljs-string\"><span class=\"hljs-string\">'\\n'</span></span>;\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">g</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n  </span></span>{\n    m_x++;\n  }\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// С++14</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Func</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n  </span></span>{\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// const копия *this</span></span>\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> lambda1 = [self = *<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">this</span></span>](){ self.f(); };\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// non-const копия *this</span></span>\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> lambda2 = [self = *<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">this</span></span>]() <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">mutable</span></span> { self.g(); };\n    lambda1();\n    lambda2();\n  }\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// С++17</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">FuncNew</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\">\n  </span></span>{\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// const копия *this</span></span>\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> lambda1 = [*<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">this</span></span>](){ f(); }; \n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// non-const копия *this</span></span>\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">auto</span></span> lambda2 = [*<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">this</span></span>]() <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">mutable</span></span> { g(); };\n    lambda1();\n    lambda2();\n  }\n};</code></pre>"
          ]
        },
        {
          "tag_line": "inline переменные",
          "qType": "ru_1",
          "details": [
            "<h2>inline переменные</h2><br>\nВ C++17 в дополнение к inline функциям появились также inline переменные. Переменная или функция, объявленная inline, может быть определена (обязательно одинаково) в нескольких единицах трансляции.<br>\n<br>\ninline переменные могут пригодиться разработчикам библиотек, состоящих из одного заголовочного файла. Приведу небольшой пример:<br>\n<br>\n(Вместо того, чтобы писать extern и присваивать значение в .cpp)<br>\n<br>\nheader.h:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">ifndef</span></span></span><span class=\"hljs-meta\"> _HEADER_H</span></span>\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">define</span></span></span><span class=\"hljs-meta\"> _HEADER_H</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">inline</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> MyVar = <span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span>;\n<span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">endif</span></span></span></span></code></pre><br>\nsource1.h:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">\"header.h\"</span></span></span></span>\n....\nMyVar += <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>;</code></pre><br>\nsource2.h:<br>\n<br>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-meta\"><span class=\"hljs-meta\">#</span><span class=\"hljs-meta-keyword\"><span class=\"hljs-meta\"><span class=\"hljs-meta-keyword\">include</span></span></span><span class=\"hljs-meta\"> </span><span class=\"hljs-meta-string\"><span class=\"hljs-meta\"><span class=\"hljs-meta-string\">\"header.h\"</span></span></span></span>\n....\nFunc(MyVar);</code></pre><br>\nДо C++17 пришлось бы объявлять переменную <i>MyVar</i> как <i>extern</i> и в одном из .cpp файлов присваивать ей значение."
          ]
        }
      ]
    },
    {
      "title": "Лямбда-выражения в Java 8",
      "content": [
        {
          "tag_line": "Лямбда-выражения в Java 8",
          "details": [
            "В новой версии Java 8 наконец-то появились долгожданные лямбда-выражения. Возможно, это самая важная новая возможность последней версии; они позволяют писать быстрее и делают код более ясным, а также открывают дверь в мир функционального программирования. В этой статье я расскажу, как это работает.<br>\n<br>\nJava задумывалась как объектно-ориентированный язык в 90-е годы, когда объектно-ориентированное программирование было главной парадигмой в разработке приложений. Задолго до этого было объектно-ориентированное программирование, были функциональные языки программирования, такие, как Lisp и Scheme, но их преимущества не были оценены за пределами академической среды. В последнее время функциональное программирование сильно выросло в значимости, потому что оно хорошо подходит для параллельного программирования и программирования, основанного на событиях («reactive»). Это не значит, что объектная ориентированность – плохо. Наоборот, вместо этого, выигрышная стратегия – смешивать объектно-ориентированное программирование и функциональное. Это имеет смысл, даже если вам не нужна параллельность. Например, библиотеки коллекций могут получить мощное API, если язык имеет удобный синтаксис для функциональных выражений.<br>\n<br>\nГлавным улучшением в Java 8 является добавление поддержки функциональных программных конструкций к его объектно-ориентированной основе. <a name=\"habracut\"></a>В этой статье я продемонстрирую основной синтаксис и как использовать его в нескольких важных контекстах. Ключевые моменты понятия лямбды:<br>\n<br>\n<ul>\n<li>Лямбда-выражение является блоком кода с параметрами. </li>\n<li>Используйте лямбда-выражение, когда хотите выполнить блок кода в более поздний момент времени.</li>\n<li>Лямбда-выражения могут быть преобразованы в функциональные интерфейсы. </li>\n<li>Лямбда-выражения имеют доступ к final переменным из охватывающей области видимости. </li>\n<li>Ссылки на метод и конструктор ссылаются на методы или конструкторы без их вызова. </li>\n<li>Теперь вы можете добавить методы по умолчанию и статические методы к интерфейсам, которые обеспечивают конкретные реализации. </li>\n<li>Вы должны разрешать любые конфликты между методами по умолчанию из нескольких интерфейсов.</li></ul>"
          ]
        },
        {
          "tag_line": "Зачем нужны лямбды?",
          "details": [
            "Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен позже, один или несколько раз. Прежде чем углубляться в синтаксис (и любопытное название), давайте сделаем шаг назад и увидим, где вы использовали аналогичные блоки кода в Java до этого. <br>\n<br>\nЕсли вы хотите выполнить действия в отдельном потоке, вы помещаете их в метод <code>run</code> из <code>Runnable</code>, вот так:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">MyRunner</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">implements</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Runnable</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">run</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{\n        <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; <span class=\"hljs-number\"><span class=\"hljs-number\">1000</span></span>; i++)\n           doWork();\n        }\n        ...\n}\n</code></pre><br>\nЗатем, когда вы хотите выполнить этот код, вы создаете экземпляр класса <code>MyRunner</code>. Вы можете поместить экземпляр в пул потоков, или поступить проще и запустить новый поток:<br>\n<pre><code class=\"java hljs\">MyRunner r = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> MyRunner();\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Thread(r).start();\n</code></pre><br>\nКлючевым моментом является то, что метод <code>run</code> содержит код, который нужно выполнить в отдельном потоке.<br>\n<br>\nРассмотрим сортировку с использованием пользовательского компаратора. Если вы хотите отсортировать строки по длине, а не по умолчанию, вы можете передать объект <code>Comparator</code> в метод <code>sort</code>:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">LengthStringComparator</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">implements</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Comparator</span></span></span><span class=\"hljs-class\">&lt;</span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">String</span></span></span><span class=\"hljs-class\">&gt; </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">compare</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(String firstStr, String secondStr)</span></span></span><span class=\"hljs-function\"> </span></span>{\n        <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> Integer.compare(firstStr.length(),secondStr.length());\n    }\n}\n   \nArrays.sort(strings, <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> LengthStringComparator ());\n</code></pre><br>\nМетод <code>sort</code> все так же вызывает метод <code>compare</code>, переставляя элементы, если они стоят не по порядку, пока массив не будет отсортирован. Вы предоставляете методу <code>sort</code> фрагмент кода, необходимый для сравнения элементов, и этот код встраивается в остальную часть логики сортировки, которую вам, вероятно, не нужно переопределять. Обратите внимание, что вызов <code>Integer.compare (х, у)</code> возвращает ноль, если х и у равны, отрицательное число, если х &lt; у, и положительное число, если х &gt; у. Этот статический метод был добавлен в Java 7. Вы не должны вычислять х – y, чтобы сравнивать х и у, потому что расчет может вызвать переполнение для больших операндов противоположного знака.<br>\n<br>\nВ качестве другого примера отложенного выполнения рассмотрим коллбэк для кнопки. Вы помещаете действие обратного вызова в метод класса, реализующего интерфейс слушателя, создаете экземпляр, и регистрируете экземпляр. Это настолько распространенный сценарий, что многие программисты используют синтаксис «анонимный экземпляр анонимного класса»:<br>\n<pre><code class=\"java hljs\">button.setOnAction(<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> EventHandler&lt;ActionEvent&gt;() {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">handle</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(ActionEvent event)</span></span></span><span class=\"hljs-function\"> </span></span>{\n        System.out.println(<span class=\"hljs-string\"><span class=\"hljs-string\">\"The button has been clicked!\"</span></span>);\n    }\n});\n</code></pre><br>\nЗдесь важен код внутри метода <code>handle</code>. Этот код выполняется всякий раз, когда нажимается кнопка.<br>\n<br>\nПоскольку Java 8 позиционирует JavaFX в качестве преемника инструментария Swing GUI, я использую JavaFX в этих примерах. Детали не имеют значения. В каждой библиотеке пользовательского интерфейса, будь то Swing, JavaFX или Android, вы передаете кнопке некоторый код, который вы хотите запустить, когда кнопка нажата.<br>\n<br>\nВо всех трех примерах вы видели один и тот же подход. Блок кода кому-то передавался — пулу потоков, методу сортировки или кнопке. Этот код вызывался некоторое время спустя.<br>\n<br>\nДо сих пор передача кода не была простой в Java. Вы не могли просто передать блоки кода куда угодно. Java является объектно-ориентированным языком, так что вы должны были создать объект, принадлежащий к классу, у которого есть метод с нужным кодом.<br>\nВ других языках можно работать с блоками кода непосредственно. Проектировщики Java сопротивлялись добавлению этой функции в течение длительного времени. В конце концов, большая сила Java в ее простоте и последовательности. Язык может стать крайне беспорядочным, если будет включать в себя все функции, которые дают чуть более краткий код. Тем не менее, в тех других языках, это не просто легче порождать поток или зарегистрировать обработчик кнопки щелчка; многие их API проще, более последовательны и мощные. В Java, можно было бы написать подобные интерфейсы, которые принимают объекты классов, реализующих определенную функцию, но такие API было бы неудобно использовать.<br>\n<br>\nВ последнее время вопрос был не в том, расширять Java для функционального программирования или нет, а как это сделать. Потребовалось несколько лет экспериментов, прежде чем выяснилось, что это хорошо подходит для Java. В следующем разделе вы увидите, как можно работать с блоками кода в Java 8."
          ]
        },
        {
          "tag_line": "\nСинтаксис лямбда-выражений\n",
          "details": [
            "Рассмотрим предыдущий пример сортировки еще раз. Мы передаем код, который проверяет, какая строка короче. Мы вычисляем<br>\n<pre><code class=\"java hljs\">Integer.compare(firstStr.length(), secondStr.length())\n</code></pre><br>\nЧто такое <code>firstStr</code> и <code>secondStr</code>? Они оба строки! Java является строго типизированным языком, и мы должны указать типы:<br>\n<pre><code class=\"java hljs\">(String firstStr, String secondStr)\n     -&gt; Integer.compare(firstStr.length(),secondStr.length())\n</code></pre><br>\n<br>\nВы только что видели ваше первое лямбда-выражение! Такое выражение является просто блоком кода вместе со спецификацией любых переменных, которые должны быть переданы в код.<br>\n<br>\nПочему такое название? Много лет назад, когда еще не было никаких компьютеров, логик Алонзо Чёрч хотел формализовать, что значит для математической функции быть эффективно вычисляемой. (Любопытно, что есть функции, которые, как известно, существуют, но никто не знает, как вычислить их значения.) Он использовал греческую букву лямбда (λ), чтобы отметить параметры. Если бы он знал о Java API, он написал бы что-то не сильно похожее на то, что вы видели, скорее всего.<br>\n<br>\nПочему буква λ? Разве Чёрч использовал все буквы алфавита? На самом деле, почтенный труд Principia Mathematica использует символ ˆ для обозначения свободных переменных, которые вдохновили Чёрча использовать заглавную лямбда (Λ) для параметров. Но, в конце концов, он переключился на строчной вариант буквы. С тех пор, выражение с переменными параметрами было названо «лямбда-выражение».<br>\n<br>\nВы только что видели одну форму лямбда-выражений в Java: параметры, стрелку -&gt; и выражение. Если код выполняет вычисление, которое не вписывается в одно выражение, запишите его так же, как вы бы написали метод: заключенный в {} и с явными выражениями <code>return</code>. Например,<br>\n<pre><code class=\"java hljs\">(String firstStr, String secondStr) -&gt; {\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (firstStr.length() &lt; secondStr.length()) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> -<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>;\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (firstStr.length() &gt; secondStr.length()) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>;\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n}\n</code></pre><br>\nЕсли лямбда-выражение не имеет параметров, вы все равно ставите пустые скобки, так же, как с методом без параметров:<br>\n<pre><code class=\"java hljs\">() -&gt; { <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; <span class=\"hljs-number\"><span class=\"hljs-number\">1000</span></span>; i++) doWork(); }\n</code></pre><br>\nЕсли типы параметров лямбда-выражения можно вывести, можно опустить их. Например,<br>\n<pre><code class=\"java hljs\">Comparator&lt;String&gt; comp\n    = (firstStr, secondStr) <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Same as (String firstStr, String secondStr)</span></span>\n        -&gt; Integer.compare(firstStr.length(),secondStr.length());\n</code></pre><br>\nЗдесь компилятор может сделать вывод, что <code>firstStr</code> и <code>secondStr</code> должны быть строками, потому что лямбда-выражение присваивается компаратору строк. (Мы посмотрим на это присваивание повнимательнее позже.) <br>\n<br>\nЕсли метод имеет один параметр выводимого типа, вы можете даже опустить скобки:<br>\n<pre><code class=\"java hljs\">EventHandler&lt;ActionEvent&gt; listener = event -&gt;\n    System.out.println(<span class=\"hljs-string\"><span class=\"hljs-string\">\"The button has been clicked!\"</span></span>);\n        <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Instead of (event) -&gt; or (ActionEvent event) -&gt;</span></span>\n</code></pre><br>\n<br>\nВы можете добавить аннотации или модификатор <code>final</code> к параметрам лямбды таким же образом, как и для параметров метода:<br>\n<pre><code class=\"java hljs\">(<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">final</span></span> String <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span>) -&gt; ...\n(<span class=\"hljs-meta\"><span class=\"hljs-meta\">@NonNull</span></span> String <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span>) -&gt; ...\n</code></pre><br>\nВы никогда не указываете тип результата лямбда-выражения. Это всегда выясняется из контекста. Например, выражение<br>\n<pre><code class=\"java hljs\">(String firstStr, String secondStr) -&gt; Integer.compare(firstStr.length(), secondStr.length())\n</code></pre><br>\nможет быть использовано в контексте, где ожидается результат типа <code>int</code>. <br>\n<br>\nОбратите внимание, что лямбда-выражение не может возвращать значение в каких-то ветках, а в других не возвращать. Например, <code>(int x) -&gt; { if (x &lt;= 1) return -1; }</code> является недопустимым.<br>\n"
          ]
        },
        {
          "tag_line": "Функциональные интерфейсы",
          "details": [
            "Как мы уже обсуждали, в Java есть много существующих интерфейсов, которые инкапсулируют блоки кода, такие, как <code>Runnable</code> или <code>Comparator</code>. Лямбда-выражения имеют обратную совместимость с этими интерфейсами.<br>\n<br>\nВы можете поставить лямбда-выражение всякий раз, когда ожидается объект интерфейса с одним абстрактным методом. Такой интерфейс называется функциональным интерфейсом.<br>\n<br>\nВы можете удивиться, почему функциональный интерфейс должен иметь единственный абстрактный метод. Разве не все методы в интерфейсе абстрактные? На самом деле, всегда было возможно для интерфейса переопределить методы класса <code>Object</code>, например, <code>toString</code> или <code>clone</code>, и эти объявления не делают методы абстрактными. (Некоторые интерфейсы в Java API переопределяют методы <code>Object</code>, чтобы присоединить javadoc-комментарии. Посмотрите Comparator API для примера.) Что еще более важно, как вы вскоре увидите, в Java 8 интерфейсы могут объявлять неабстрактные методы.<br>\n<br>\nЧтобы продемонстрировать преобразование в функциональный интерфейс, рассмотрим метод <code>Arrays.sort</code>. Его второй параметр требуется экземпляр <code>Comparator</code>, интерфейса с единственным методом. Просто предоставьте лямбду:<br>\n<pre><code class=\"java hljs\">Arrays.sort(strs,\n    (firstStr, secondStr) -&gt; Integer.compare(firstStr.length(), secondStr.length()));\n</code></pre><br>\nЗа кулисами, метод <code>Arrays.sort</code> получает объект некоторого класса, реализующего <code><code>Comparator . Вызов метода compare</code> на этом объекте выполняет тело лямбда-выражения. Управление этими объектами и классами полностью зависит от реализации, и это может быть что-то гораздо более эффективное, чем использование традиционных внутренних классов. Лучше всего думать о лямбда-выражении как о функции, а не об объекте, и признать, что он может быть передан функциональному интерфейсу. <br>\n<br>\nЭто преобразование в интерфейсы – это то, что делает лямбда-выражения настолько мощными. Синтаксис короткий и простой. Вот еще один пример:<br>\n<pre><code class=\"java hljs\">button.setOnAction(event -&gt;\n    System.out.println(<span class=\"hljs-string\"><span class=\"hljs-string\">\"The button has been clicked!\"</span></span>));\n</code></pre><br>\nЭтот код очень легко читать. <br>\n<br>\nВ самом деле, преобразование в функциональный интерфейс - это единственное, что вы можете сделать с лямбда-выражением в Java. В других языках программирования, которые поддерживают функциональные литералы, можно объявить типы функций, таких как <code>(String, String) -&gt; int</code>, объявлять переменные этих типов, и использовать переменные для сохранения функциональных выражений. В Java вы не можете даже присвоить лямбда-выражение переменной типа <code>Object</code>, потому <code>Object</code> не является функциональным интерфейсом. Проектировщики Java решили строго придерживаться знакомой концепции интерфейсов, а не добавлять типы функций в язык.<br>\n<br>\nJava API определяет несколько универсальных функциональных интерфейсов в пакете java.util.function. Один из интерфейсов, <code>BiFunction &lt;T, U, R&gt;</code>, описывает функции с типами Т и U и типом возвращаемого значения R. Вы можете сохранить вашу лямбду сравнения строк в переменной этого типа:<br>\n<pre><code class=\"java hljs\">BiFunction&lt;String, String, Integer&gt; compareFunc\n    = (firstStr, secondStr) -&gt; Integer.compare(firstStr.length(), secondStr.length());\n</code></pre><br>\nТем не менее, это не поможет вам с сортировкой. Не существует метода <code>Arrays.sort</code>, который принимает <code>BiFunction</code>. Если вы использовали функциональный язык программирования и прежде, вы можете найти это любопытным. Но для Java программистов это довольно естественно. Такой интерфейс, как <code>Comparator</code>, имеет конкретную цель, а не просто метод с заданным параметром и возвращаемым типом. Java 8 сохраняет этот стиль. Если вы хотите сделать что-то с лямбда-выражениями , вы все еще должны понимать назначение этого выражения, и иметь конкретный функциональный интерфейс для этого.<br>\n<br>\nИнтерфейсы из java.util.function используются в нескольких Java 8 интерфейсах API , и вы, вероятно, увидите их в других местах в будущем. Но имейте в виду, что вы можете одинаково хорошо преобразовать лямбда-выражение в функциональный интерфейс, который является частью любого API, который вы используете сегодня. Кроме того, вы можете пометить любой функциональный интерфейс с помощью аннотации <code>@FunctionalInterface</code>. Это имеет два преимущества. Компилятор проверяет, что аннотированная сущность представляет собой интерфейс с одним абстрактным методом. И страница Javadoc включает в себя утверждение, что ваш интерфейс является функциональным интерфейсом. Вы не обязаны использовать аннотацию. Любой интерфейс с одним абстрактным методом является, по определению, функциональным интерфейсом. Но использование аннотации <code>@FunctionalInterface</code> - это хорошая идея.<br>\n<br>\nНаконец, заметим, что checked исключения могут возникнуть при преобразовании лямбды в экземпляр функционального интерфейса. Если тело лямбда-выражения может бросить checked исключение, это исключение должно быть объявлено в абстрактном методе целевого интерфейса. Например, следующее было бы ошибкой:<br>\n<pre><code class=\"java hljs\">Runnable sleepingRunner = () -&gt; { System.out.println(<span class=\"hljs-string\"><span class=\"hljs-string\">\"…\"</span></span>); Thread.sleep(<span class=\"hljs-number\"><span class=\"hljs-number\">1000</span></span>); };\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Error: Thread.sleep can throw a checkedInterruptedException</span></span>\n</code></pre><br>\nПоскольку <code>Runnable.run</code> не может бросить исключение, это присваивание является некорректным. Чтобы исправить ошибку, у вас есть два варианта. Вы можете поймать исключение в теле лямбда-выражения. Или вы можете присвоить лямбду интерфейсу, один абстрактный метод которого может бросить исключение. Например, метод <code>call</code> из интерфейса <code>Callable</code> может бросить любое исключение. Таким образом, вы можете присвоить лямбду <code><code>Callable (если добавить return null</code>).<br>\n</code></code>"
          ]
        },
        {
          "tag_line": "Ссылки на методы",
          "details": [
            "Иногда уже есть метод, который осуществляет именно те действия, которые вы хотели бы передать в другое место. Например, предположим, что вы просто хотите распечатать объект события <code>event</code>, когда кнопка нажата. Конечно, вы могли бы вызвать<br>\n<pre><code class=\"java hljs\">button.setOnAction(event -&gt; System.out.println(event));\n</code></pre><br>\nБыло бы лучше, если бы вы могли просто передать метод <code>println</code> в метод <code>setOnAction</code>. Примерно так:<br>\n<pre><code class=\"java hljs\">button.setOnAction(System.out::println);\n</code></pre><br>\nВыражение <code>System.out::println</code> является ссылкой на метод, который эквивалентен лямбда-выражению <code>x -&gt; System.out.println(x)</code>. <br>\n<br>\nВ качестве другого примера, предположим, что вы хотите отсортировать строки независимо от регистра букв. Вы можете написать такой код:<br>\n<pre><code class=\"java hljs\">Arrays.sort(strs, String::compareToIgnoreCase)\n</code></pre><br>\nКак вы можете видеть из этих примеров оператор :: отделяет имя метода от имени объекта или класса. Есть три основных варианта:<br>\n<br>\n<ul>\n<li>object::instanceMethod</li>\n<li>Class::staticMethod</li>\n<li>Class::instanceMethod</li>\n</ul><br>\n<br>\nВ первых двух случаях ссылка на метод эквивалентна лямбда-выражению, которое предоставляет параметры метода. Как уже упоминалось, <code>System.out::println</code> эквивалентно <code>x -&gt; System.out.println(x)</code>. Точно так же, <code>Math::pow</code> эквивалентно <code>(x, y) -&gt; Math.pow(x, y)</code>. В третьем случае первый параметр становится целевым объектом метода. Например , <code>String::compareToIgnoreCase</code> - это то же самое, что и <code>(x, y) -&gt; x.compareToIgnoreCase(y)</code>.<br>\n<br>\nПри наличии нескольких перегруженных методов с тем же именем компилятор попытается найти из контекста, какой вы имеете в виду. Например, есть два варианта метода <code>Math.max</code>, один для <code>int</code> и один для <code>double</code>. Какой из них будет вызван, зависит от параметров метода функционального интерфейса, к которому <code>Math.max</code> преобразуется. Так же, как и лямбда-выражения, ссылки на методы не живут в изоляции. Они всегда преобразуются в экземпляры функциональных интерфейсов.<br>\n<br>\nВы можете захватить параметр <code>this</code> в ссылке на метод. Например, <code>this::equals</code> – это то же, что и <code>x -&gt; this.equals(x)</code>. Можно также использовать <code>super</code>. Выражение <code>super::instanceMethod</code> использует <code>this</code> в качестве цели и вызывает версию данного метода суперкласса. Вот искусственный пример, который демонстрирует механизм:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Speaker</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">speak</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{\n        System.out.println(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Hello, world!\"</span></span>);\n    }\n}\n   \n<span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">ConcurrentSpeaker</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">extends</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Speaker</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">speak</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{\n        Thread t = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Thread(<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">super</span></span>::speak);\n            t.start();\n        }\n}\n</code></pre><br>\nПри запуске потока вызывается его <code>Runnable</code>, и <code>super::speak</code> выполняется, вызывая <code>speak</code> суперкласса. (Обратите внимание, что во внутреннем классе вы можете захватить эту ссылку из класса приложения, как <code>EnclosingClass.this::method</code> или <code>EnclosingClass.super::method</code>.) "
          ]
        },
        {
          "tag_line": "\nСсылки на конструктор",
          "details": [
            "Ссылки на конструктор такие же, как ссылки на метод, за исключением того, что именем метода является new. Например, Button::new является ссылкой на конструктор класса Button. На какой именно конструктор? Это зависит от контекста. Предположим, у вас есть список строк. Затем, вы можете превратить его в массив кнопок, путем вызова конструктора для каждой из строк, с помощью следующего вызова:\n\nList<String> strs = ...;\nStream<Button> stream = strs.stream().map(Button::new);\nList<Button> buttons = stream.collect(Collectors.toList());\n\n\nПодробная информация о stream, map и методах collect выходит за рамки этой статьи. На данный момент, важно то, что метод map вызывает конструктор Button(String) для каждого элемента списка. Есть несколько конструкторов Button, но компилятор выбирает тот, что с параметром строкового типа, потому что из контекста ясно, что конструктор вызывается со строкой.\n\nВы можете сформировать ссылки на конструкторы с типом массивов. Например, int[]::new является ссылкой на конструктор с одним параметром: длиной массива. Это равносильно лямбда-выражению x -> new int[x].\n\nСсылки на конструкторы массива полезны для преодоления ограничений Java. Невозможно создать массив универсального типа T. Выражение new T[n] является ошибкой, так как оно будет заменено new Object[n]. Это является проблемой для авторов библиотек. Например, предположим, мы хотим иметь массив кнопок. Интерфейс Stream имеет метод toArray, возвращающее массив Object:\n\nObject[] buttons = stream.toArray();\n\n\nНо это неудовлетворительно. Пользователь хочет массив кнопок, а не объектов. Библиотека потоков решает эту проблему за счет ссылок на конструкторы. Передайте Button[]::new методу toArray:\n\nButton[] buttons = stream.toArray(Button[]::new);\n\n\nМетод toArray вызывает этот конструктор для получения массива нужного типа. Затем он заполняет и возвращает массив."
          ]
        },
        {
          "tag_line": "Область действия переменной",
          "details": [
            "Часто вы хотели бы иметь возможность получить доступ к переменным из охватывающего метода или класса в лямбда-выражении. Рассмотрим следующий пример:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">repeatText</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(String text, </span></span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\"> count)</span></span></span><span class=\"hljs-function\"> </span></span>{\n     Runnable r = () -&gt; {\n         <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; count; i++) {\n             System.out.println(text);\n             Thread.yield();\n         }\n    };\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Thread(r).start();\n}\n</code></pre><br>\nРассмотрим вызов:<br>\n<pre><code class=\"java hljs\">repeatText(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Hi!\"</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2000</span></span>); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Prints Hi 2000 times in a separate thread</span></span>\n</code></pre><br>\nТеперь посмотрим на переменные <code>count</code> и <code>text</code> внутри лямбда-выражения. Обратите внимание, что эти переменные не определены в лямбда-выражении. Вместо этого, они являются параметрами метода <code>repeatText</code>.<br>\n<br>\nЕсли подумать хорошенько, то не очевидно, что здесь происходит. Код лямбда-выражения может выполниться гораздо позже вызова <code>repeatText</code> и переменные параметров уже будут потеряны. Как же переменные <code>text</code> и <code>count</code> остаются доступными?<br>\n<br>\nЧтобы понять, что происходит, мы должны уточнить наши представления о лямбда-выражениях. Лямбда-выражение имеет три компонента:<br>\n<br>\n<ul>\n<li>Блок кода</li>\n<li>Параметры</li>\n<li>Значения для свободных переменных; то есть, переменных, которые не являются параметрами и не определены в коде</li>\n</ul><br>\nВ нашем примере лямбда-выражение имеет две свободных переменных, <code>text</code> и <code>count</code>. Структура данных, представляющая лямбда-выражение, должна сохранять значения для этих переменных, в нашем случае , \"Hi!\" и 2000. Будем говорить, что эти значения были захвачены лямбда-выражением. (Это деталь реализации , как это делается. Например, можно преобразовать лямбда-выражение в объект с одним методом, так что значения свободных переменных копируются в переменные экземпляра этого объекта.)<br>\n<br>\nТехническим термином для блока кода вместе со значениями свободных переменных является замыкание. Если кто-то злорадствует, что их язык поддерживает замыкания, будьте уверены, что Java также их поддерживает. В Java лямбда-выражения являются замыканиями. На самом деле, внутренние классы были замыканиями все это время. Java 8 предоставляет нам замыкания с привлекательным синтаксисом.<br>\n<br>\nКак вы видели, лямбда-выражение может захватить значение переменной в охватывающей области. В Java, чтобы убедиться, что захватили значение корректно, есть важное ограничение. В лямбда-выражении можно ссылаться только на переменные, значения которых не меняются. Например, следующий код является неправильным:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">repeatText</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">(String text, </span></span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\"> count)</span></span></span><span class=\"hljs-function\"> </span></span>{\n    Runnable r = () -&gt; {\n        <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">while</span></span> (count &gt; <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>) {\n            count--; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Error: Can't mutate captured variable</span></span>\n            System.out.println(text);\n            Thread.yield();\n       }\n    };\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Thread(r).start();\n}\n</code></pre><br>\nСуществует причина для этого ограничения. Изменяющиеся переменные в лямбда-выражениях не потокобезопасны. Рассмотрим последовательность параллельных задач, каждая из которых обновляет общий счетчик.<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> matchCount = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (Path p : files)\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Thread(() -&gt; { <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (p has some property) matchCount++; }).start();\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Illegal to mutate matchCount</span></span>\n</code></pre><br>\nЕсли бы этот код был правомерным, это было бы не слишком хорошо. Приращение <code>matchCount++</code> неатомарно, и нет никакого способа узнать, что произойдет, если несколько потоков выполнят этот код одновременно. <br>\n<br>\nВнутренние классы могут также захватывать значения из охватывающей области. До Java 8 внутренние классы могли иметь доступ только к локальным <code>final</code> переменным. Это правило теперь ослаблено для соответствия правилу для лямбда-выражений. Внутренний класс может получить доступ к любой эффективно <code>final</code> локальной переменной; то есть, к любой переменной, значение которой не изменяется. <br>\n<br>\nНе рассчитывайте, что компилятор выявит все параллельные ошибки доступа. Запрет на модификацию имеет место только для локальных переменных. Если <code>matchCount</code> – переменная экземпляра или статическая переменная из охватывающего класса, то никакой ошибки не будет, хотя результат так же не определен.<br>\n<br>\nКроме того, совершенно законно изменять разделяемый объект, хоть это и не очень надежно. Например,<br>\n<pre><code class=\"java hljs\">List&lt;Path&gt; matchedObjs = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> ArrayList&lt;&gt;();\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (Path p : files)\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Thread(() -&gt; { <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (p has some property) matchedObjs.add(p); }).start();\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Legal to mutate matchedObjs, but unsafe</span></span>\n</code></pre><br>\nОбратите внимание, что переменная <code>matchedObjs</code> эффективно <code>final</code>. (Эффективно <code>final</code> переменная является переменной, которой никогда не присваивается новое значение после ее инициализации.) В нашем случае <code>matchedObjs</code> всегда ссылается на один и тот же объект <code>ArrayList</code>. Однако объект изменяется, и это не потокобезопасно. Если несколько потоков вызовут метод <code>add</code>, результат может быть непредсказуемым. <br>\n<br>\nСуществуют безопасные механизмы подсчета и сбора значений одновременно. Вы можете использовать потоки для сбора значений с определенными свойствами. В других ситуациях вы можете использовать потокобезопасные счетчики и коллекции.<br>\n<br>\nКак и с внутренними классами, есть обходное решение, которое позволяет лямбда-выражению обновить счетчик в локальной охватывающей области видимости. Используйте массив длиной 1, вроде этого:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>[] counts = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span>[<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>];\nbutton.setOnAction(event -&gt; counts[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>]++);\n</code></pre><br>\nКонечно, такой код не потокобезопасный. Для обратного вызова кнопки это не имеет значения, но в целом, вы должны подумать дважды, прежде чем использовать этот трюк. <br>\n<br>\nТело лямбда-выражения имеет ту же область видимости, что и вложенный блок. Здесь применяются те же самые правила для конфликтов имен. Нельзя объявить параметр или локальную переменную в лямбде, которые имеют то же имя, что и локальная переменная.<br>\n<pre><code class=\"java hljs\">Path first = Paths.get(<span class=\"hljs-string\"><span class=\"hljs-string\">\"/usr/local\"</span></span>);\nComparator&lt;String&gt; comp =\n    (first, second) -&gt; Integer.compare(first.length(), second.length());\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Error: Variable first already defined</span></span>\n</code></pre><br>\nВнутри метода вы не можете иметь две локальные переменные с тем же именем. Таким образом, вы не можете объявить такие переменные также и в лямбда-выражении. При использовании ключевого слова <code>this</code> в лямбда-выражении вы ссылаетесь на параметр <code>this</code> метода, который создает лямбду. Рассмотрим, например, следующий код<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> class </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">Application</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">doWork</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{\n        Runnable r = () -&gt; { ...; System.out.println(<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">this</span></span>.toString()); ... };\n        ...\n    }\n}\n</code></pre><br>\nВыражение <code>this.toString()</code> вызывает метод <code>toString</code> объекта <code>Application</code>, а не экземпляра <code>Runnable</code>. Нет ничего особенного в использовании <code>this</code> в лямбда-выражении. Область видимости лямбда-выражения вложена внутрь метода <code>doWork</code>, и <code>this</code> имеет такое же значение в любой точке этого метода.<br>\n"
          ]
        },
        {
          "tag_line": "Методы по умолчанию",
          "details": [
            "Многие языки программирования интегрируют функциональные выражения с их библиотеками коллекций. Это часто приводит к коду, который короче и проще для понимания, чем эквивалент, использующий циклы. Например, рассмотрим цикл:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">int</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; strList.size(); i++)\n    System.out.println(strList.get(i));\n</code></pre><br>\nСуществует лучший способ. Авторы библиотеки могут предоставить метод <code>forEach</code>, который применяет функцию к каждому элементу. Тогда вы можете просто вызвать<br>\n<pre><code class=\"java hljs\">strList.forEach(System.out::println);\n</code></pre><br>\nЭто нормально, если библиотека коллекций была разработана с нуля. Но библиотека коллекций Java была разработана много лет назад, и есть проблема. Если интерфейс <code>Collection</code> получает новые методы, такие как <code>forEach</code>, то каждая программа, которая определяет свой собственный класс, реализующий <code>Collection</code>, сломается, пока тоже не реализует этот метод. Это просто недопустимо в Java.<br>\n<br>\nПроектировщики Java решили эту проблему раз и навсегда, позволив создавать методы интерфейса с конкретной реализацией (так называемые методы по умолчанию). Эти методы могут быть безопасно добавлены к существующим интерфейсам. В этом разделе мы рассмотрим методы по умолчанию в деталях. В Java 8 метод <code>forEach</code> был добавлен к интерфейсу <code>Iterable</code>, суперинтерфейсу <code>Collection</code>, используя механизм, который я опишу здесь. <br>\n<br>\nРассмотрим такой интерфейс:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Person</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">long</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">getId</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span></span></span><span class=\"hljs-function\"> String </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">getFirstName</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{ <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> <span class=\"hljs-string\"><span class=\"hljs-string\">\"Jack\"</span></span>; }\n}\n</code></pre><br>\nИнтерфейс имеет два метода: <code>getId</code>, это абстрактный метод, и метод по умолчанию <code>getFirstName</code>. Конкретный класс, реализующий интерфейс <code>Person</code>, должен, конечно, предоставить реализацию <code>getId</code>, но он может выбрать, оставить реализацию <code>getFirstName</code> или переопределить ее.<br>\n<br>\nМетоды по умолчанию кладут конец классическому паттерну предоставления интерфейса и абстрактного класса, который реализует все или почти все из его методов, такие, как <code>Collection/AbstractCollection</code> или <code>WindowListener/WindowAdapter</code>. Теперь вы можете просто реализовать методы в интерфейсе.<br>\nЧто произойдет, если точно такой же метод определен как метод по умолчанию в одном интерфейсе, а затем снова в качестве метода суперкласса или другого интерфейса? Языки типа Скала и C++ имеют сложные правила разрешения таких неоднозначностей. К счастью, правила в Java гораздо проще. Вот они:<br>\n<br>\n<ol>\n<li>Родительские классы выиграют. Если суперкласс предоставляет конкретный метод, методы по умолчанию с тем же именем и типами параметров просто игнорируются.</li>\n<li>Интерфейсы сталкиваются. Если супер интерфейс предоставляет метод по умолчанию, а другой интерфейс поставляет метод с тем же именем и типами параметров (по умолчанию или нет), то вы должны разрешить конфликт путем переопределения этого метода.</li>\n</ol><br>\nДавайте посмотрим на второе правило. Рассмотрим еще один интерфейс с методом <code>getFirstName</code>:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Naming</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span></span></span><span class=\"hljs-function\"> String </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">getFirstName</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{ <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> getClass().getName() + <span class=\"hljs-string\"><span class=\"hljs-string\">\"_\"</span></span> + hashCode(); }\n}\n</code></pre><br>\nЧто произойдет, если вы создадите класс, реализующий оба?<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Student</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">implements</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Person</span></span></span><span class=\"hljs-class\">, </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Naming</span></span></span><span class=\"hljs-class\"> </span></span>{\n    ...\n}\n</code></pre><br>\nКласс наследует две противоречивые версии метода <code>getFirstName</code>, предоставляемые интерфейсами <code>Person</code> и <code>Naming</code>. Вместо выбора того или другого метода, компилятор Java сообщает об ошибке и оставляет программисту разрешение неоднозначности. Просто предоставьте метод <code>getFirstName</code> в классе <code>Student</code>. В этом методе вы можете выбрать один из двух конфликтующих методов, как показано ниже:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Student</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">implements</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Person</span></span></span><span class=\"hljs-class\">, </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Naming</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span></span></span><span class=\"hljs-function\"> String </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">getFirstName</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span><span class=\"hljs-function\"> </span></span>{ returnPerson.<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">super</span></span>.getFirstName(); }\n        ...\n}\n</code></pre><br>\nТеперь предположим, что <code>Naming</code> интерфейс не содержит реализацию по умолчанию для <code>getFirstName</code>:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Naming</span></span></span><span class=\"hljs-class\"> </span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-function\">String </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">getFirstName</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">()</span></span></span></span>;\n}\n</code></pre><br>\nМожет ли класс <code>Student</code> унаследовать метод по умолчанию из интерфейса <code>Person</code>? Это могло бы быть разумным, но проектировщики Java приняли решение в пользу единообразия. Это не имеет значения, как два интерфейсы конфликтуют. Если хотя бы один интерфейс обеспечивает реализацию, компилятор сообщает об ошибке, и программист должен устранить неоднозначность. <br>\n<br>\nЕсли ни один интерфейс не обеспечивает реализацию по умолчанию для общего метода, то мы находимся в пре-Java 8 ситуации и нет никакого конфликта. У класса реализации есть две возможности: реализовать метод или оставить его нереализованным. В последнем случае класс сам является абстрактным.<br>\n<br>\nМы только что обсудили конфликты имен между двумя интерфейсами. Теперь рассмотрим класс, расширяющий суперкласс и реализующий интерфейс, наследуя тот же метод от обоих. Например, предположим, что <code>Person</code> является классом и <code>Student</code> определяется как:<br>\n<pre><code class=\"java hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Student</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">extends</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Person</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-keyword\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">implements</span></span></span><span class=\"hljs-class\"> </span><span class=\"hljs-title\"><span class=\"hljs-class\"><span class=\"hljs-title\">Naming</span></span></span><span class=\"hljs-class\"> </span></span>{ ... }\n</code></pre><br>\nВ этом случае только метод суперкласса имеет значение, и любой метод по умолчанию из интерфейса просто игнорируется . В нашем примере <code>Student</code> наследует метод <code>getFirstName</code> от <code>Person</code>, и нет никакой разницы, обеспечивает ли интерфейс <code>Naming</code> реализацию по умолчанию для <code>getFirstName</code> или нет. Это правило «класс побеждает» в действии. Правило «класс побеждает» обеспечивает совместимость с Java 7. Если вы добавляете методы по умолчанию к интерфейсу, это не имеет никакого влияния на код, который работал до того, как появились методы по умолчанию. Но имейте в виду: вы не имеете права создавать метод по умолчанию, который переопределяет один из методов класса <code>Object</code>. Например, вы не можете определить метод по умолчанию для <code>toString</code> или <code>equals</code>, хотя это могло бы быть удобным для таких интерфейсов, как <code>List</code>. Как следствие правила о победе классов, такой метод никогда не может выиграть у <code>Object.toString</code> или <code>Object.equals</code>.<br>\n"
          ]
        }
      ]
    }
  ]
}