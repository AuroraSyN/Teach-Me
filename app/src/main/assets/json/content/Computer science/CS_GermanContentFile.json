{
  "items": [
    {
      "title": "Objektorientiertes Programmieren in Java",
      "qType": "BIG_de_1",
      "content": [
        {
          "tag_line": "Objekte",
          "qType": "SMALL_de_1",
          "details": [
            "<h2>Objekte</h2>\n\n<p>Java ist eine objektorientierte Sprache. Das verlangt vom Entwickler neben dem Erlernen neuer Sprachelemente auch eine neue &laquo;objektorientierte&raquo; Denkweise. In Form eines Tutorials soll hier mit dieser Denkweise vertraut gemacht werden.</p>\n\n<p>Herk&ouml;mmliche Softwareentwicklung bestand oftmals darin, zur L&ouml;sung eines vorgegebenen Problems Algorithmen zu entwerfen und diese in Prozeduren zu gie&szlig;en, die in einer Programmiersprache - wie zum Beispiel C - formuliert sind. Man spricht daher auch von prozeduraler Programmierung.</p>\n\n<p>Betrachtet man jedoch die reale Welt, so stellt man fest, dass die Dinge sich hier nicht in einer abstrakten prozeduralen Weise bewegen. Diesen Bruch zwischen realer Welt und Softwareentwicklung versucht der objektorientierte Ansatz zu &uuml;berwinden. Analysiert man seine materielle Umgebung, so stellt man fest, dass diese im wesentlichen aus Objekten besteht, die in verschiedener Art und Weise miteinander agieren. So k&ouml;nnte es hier zum Beispiel gerade ein Objekt Fahrrad geben.</p>\n\n<p><img align=\"left\" alt=\"Objekt\" height=\"160\" src=\"https://www.kompf.de/java/images/java-tutor-1.gif\" width=\"165\" /> Nimmt man das Fahrrad noch weiter unter die Lupe, erkennt man, dass dieses Fahrrad bestimmte <em>Eigenschaften</em> bzw. <em>Attribute</em> (wie Farbe, Gr&ouml;&szlig;e, momentane Geschwindigkeit) besitzt und dass es <em>Methoden</em> gibt, diese Eigenschaften zu ver&auml;ndern (z.B. die Methode &quot;Tritt schneller&quot;, die zu einer Erh&ouml;hung der Geschwindigkeit f&uuml;hren wird oder die Methode &quot;Bremse&quot;, die das Gegenteil bewirken sollte).</p>\n\n<p>Transformiert man diese Erkenntnis aus der realen in die Software Welt, so kann man formulieren:</p>\n\n<p class=\"definition\">Ein Software Objekt ist ein B&uuml;ndel aus Attributen und darauf bezogenen Methoden.</p>\n"
          ]
        },
        {
          "tag_line": "Klassen",
          "qType": "SMALL_de_2",
          "details": [
            "<h2>Klassen</h2>\n\n<h3 id=\"klassen_als_bauplan\">Klassen als Bauplan</h3>\n\n<p>Wenn man verschiedene Fahrr&auml;der der realen Welt genauer betrachtet, so ist festzustellen, dass alle diese Fahrrad Objekte &auml;hnlich sind: Alle besitzen Bremsen, alle haben irgendeine Farbe usw. Es muss also einen <em>Bauplan</em> geben, der beschreibt, wie ein Fahrrad grunds&auml;tzlich auszusehen hat. Alle Fahrrad Objekte sind nach diesem Bauplan erstellt worden - deswegen ist es auch m&ouml;glich, ein beliebiges Fahrrad zu fahren, wenn man einmal das Fahrradfahren gelernt hat!</p>\n\n<p class=\"definition\">Eine Klasse ist ein Bauplan, welcher die Attribute und Methoden definiert, die alle Objekte einer bestimmten Art besitzen.</p>\n\n<p><img align=\"left\" alt=\"class StockItem\" height=\"134\" src=\"https://www.kompf.de/java/images/java-tutor-2.png\" style=\"margin-right:15px;\" width=\"158\" /> Die Abbildung zeigt eine Klasse <tt>StockItem</tt> in der sogenannten UML (unified modelling language) Notation. Diese Klasse k&ouml;nnte in einem Programm zur Aktienanalyse verwendet werden. Ein solches Programm muss viele verschiedene Aktien Objekte verwalten k&ouml;nnen. Damit dies effektiv geschehen kann, sollten alle diese verschiedenen Objekte jedoch nach einem einheitlichen Bauplan - der Klassendefinition - erstellt werden.</p>\n\n<p>Der Name der Klasse steht in der UML-Notation im oberen Drittel des Rechtecks. Im mittleren Drittel stehen die Attribute. Die Beispielklasse <tt>StockItem</tt> definiert die zwei Attribute m_name und m_value, d.h. den Namen der Aktie und den momentanen Kurswert. Das Minuszeichen vor den Attributen bedeutet, das diese <tt class=\"keyword\">private</tt> Mitglieder der Klasse sind, d.h. von au&szlig;en kann nicht direkt auf sie zugegriffen werden.</p>\n\n<p>Im unteren Drittel stehen die Methoden der Klasse <tt>StockItem</tt>. Das Pluszeichen vor ihnen zeigt, dass sie <tt class=\"keyword\">public</tt> sind, d.h. die Methoden d&uuml;rfen von anderen Objekten aufgerufen werden. Damit zeigt sich das Prinzip der Kapselung: Anstatt auf das Attribut m_value direkt zuzugreifen, <em>m&uuml;ssen</em> andere Objekte die Zugriffsmethoden setValue() und getValue() benutzen! So hat der Entwickler der Klasse die M&ouml;glichkeit, in setValue() noch zus&auml;tzliche Abfragen, z.B. bez&uuml;glich der G&uuml;ltigkeit des Parameters, einzubauen.</p>\n\n<p>Aufmerksamen Lesern wird bei Betrachtung der Abbildung nicht entgangen sein, dass Methoden in Java - wie auch in C++ - nicht nur durch den Namen, sondern durch Namen <em>und</em> Parameteranzahl und -typ unterschieden werden! So kann es die Methode setValue() zweimal geben: Einmal mit einem Parameter vom Typ <tt class=\"keyword\">double</tt> und mit einem vom Typ <tt>String</tt>. Der Compiler erkennt beim Aufruf dieser Methode anhand des Parametertyps selbstt&auml;tig, welche Variante er verwenden muss.</p>\n\n<h3 id=\"klassendefinition_und_implementierung\">Klassendefinition und Implementierung</h3>\n\n<p>In Java gibt es keine Trennung zwischen Definition und Implementierung einer Klasse. Beides erfolgt in einer Textdatei mit der Extension <b>.java</b>, die den Namen der Klasse tr&auml;gt. Eine Unterteilung in Header- und Implementierungsdatei wie bei C++ gibt es nicht.</p>\n\n<p>Die Definition und Implementierung der Java Klasse f&uuml;r StockItem wird also in der Datei mit dem Namen <b>StockItem.java</b> vorgenommen:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">package</span> de.kompf.tutor;\n\n<span class=\"doccomment\">/**\n * Class representing a StockItem.\n */</span>\n<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> StockItem {\n  <span class=\"keyword\">private</span> String m_name;\n  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> m_value;\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItem with empty name and no value.\n   */</span>\n  <span class=\"keyword\">public</span> StockItem() {\n    <span class=\"keyword\">this</span>(<span class=\"quotedstring\">&quot;&quot;</span>, 0.0);\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItem with no value.\n   * \n   * @param name The name of the StockItem.\n   */</span>\n  <span class=\"keyword\">public</span> StockItem(String name) {\n    <span class=\"keyword\">this</span>(name, 0.0);\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItem.\n   * \n   * @param name The name.\n   * @param value The value.\n   */</span>\n  <span class=\"keyword\">public</span> StockItem(String name, <span class=\"keyword\">double</span> value) {\n    m_name = name;\n    m_value = value;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The name.\n   */</span>\n  <span class=\"keyword\">public</span> String getName() {\n    <span class=\"keyword\">return</span> m_name;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param val The value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setValue(<span class=\"keyword\">double</span> val) {\n    m_value = val;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param val The value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setValue(String val) {\n    m_value = Double.parseDouble(val);\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The value.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getValue() {\n    <span class=\"keyword\">return</span> m_value;\n  }\n\n  <span class=\"doccomment\">/**\n   * @see java.lang.Object#toString()\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> String toString() {\n    <span class=\"keyword\">return</span> m_name + <span class=\"quotedstring\">&quot;: &quot;</span> + m_value;\n  }\n}\n</pre>\n\n<p>Die Datei beginnt mit einer Package Deklaration. Dadurch lassen sich auch gro&szlig;e Projekte gut strukturieren. Zum einen dient der Packagename <tt>de.kompf.tutor</tt> als eine Art Namensraum: Klassennamen m&uuml;ssen nur innerhalb einer Package eindeutig sein. Zum anderen werden die Dateien entsprechend ihres Packagenamens auf der Platte abgelegt: Alle zur Package <tt>de.kompf.tutor</tt> geh&ouml;renden Java Dateien befindet sich im Verzeichnis <b>de/kompf/tutor</b> relativ zum Projektverzeichnis.</p>\n\n<p>Die eigentliche Klassendefinition beginnt mit den Schl&uuml;sselw&ouml;rtern <tt class=\"keyword\">public class</tt> gefolgt vom Namen der Klasse. Der Klassenrumpf wird von geschweiften Klammern { } umschlossen. Er enth&auml;lt s&auml;mtliche Methoden und Attribute (&laquo;Member&raquo;) der Klasse. Dabei kennzeichnen die Schl&uuml;sselw&ouml;rter <tt class=\"keyword\">public</tt> und <tt class=\"keyword\">private</tt> vor <em>jeder</em> Deklaration die im letzten Abschnitt besprochene &ouml;ffentliche oder private Sichtbarkeit des Members. Es gibt au&szlig;erdem noch die M&ouml;glichkeit, mittels <tt class=\"keyword\">protected</tt> Variablen und Methoden zu deklarieren, die ausschlie&szlig;lich abgeleiteten Klassen zur Verf&uuml;gung stehen sollen. Dazu mehr sp&auml;ter mehr beim Thema <em>Vererbung</em>. Es ist auch m&ouml;glich, die Sichtbarkeit nicht explizit anzugeben. Dann ist der entsprechende Member in der zugeh&ouml;rigen Package sichtbar.</p>\n\n<p>Jede Klasse ben&ouml;tigt mindestens einen Konstruktor (kurz <em>ctor</em>) zur Erzeugung von Objekten der Klasse. Ein Konstruktor hat den gleichen Namen wie die Klasse und keinen R&uuml;ckgabewert. Eine Angabe der Sichtbarkeit per <tt class=\"keyword\">public</tt>, <tt class=\"keyword\">private</tt> und so weiter ist auch f&uuml;r Konstruktoren m&ouml;glich. Man kann auch auf die explizite Angabe eines Konstruktors verzichten, in diesem Fall hat die Klasse automatisch einen impliziten <tt class=\"keyword\">public</tt> Konstruktor ohne Parameter, den <em>Default Konstruktor</em>.</p>\n\n<p>Die Klasse besitzt drei Konstruktoren, um eine Initialisierung mit verschiedenen Kombinationen von Parametern zu erlauben. Eine Angabe von Defaultwerten direkt in der Parameterliste analog zu C++ ist in Java nicht m&ouml;glich. Die restliche Implementierung besteht aus den Methoden zum Setzen und Auslesen der Membervariablen. Eine Methode zum Setzen des Namens fehlt mit Absicht, es soll nicht m&ouml;glich sein, den Namen eines StockItems im Nachhinein zu &auml;ndern.</p>\n\n<p>Im Gegensatz zur gleichnamigen C++ Klasse aus dem <a href=\"https://www.kompf.de/cplus/tutor.html\">C++ Tutorial</a> ist es in Java nicht notwendig, sich mit Dingen wie Copy-Constructor, Destructor und Assignment Operator herumzuschlagen. Warum dies so ist, wird bei der Betrachtung des <em>Objektlebenszyklus</em> verst&auml;ndlich.</p>\n"
          ]
        },
        {
          "tag_line": "Objektlebenszyklus",
          "qType": "SMALL_de_3",
          "details": [
            "<h2>Objektlebenszyklus</h2>\n\n<p>Der Lebenszyklus eines Java Objektes besteht aus den Abschnitten</p>\n\n<ol>\n\t<li>Erzeugung</li>\n\t<li>Benutzung</li>\n\t<li>Zerst&ouml;rung</li>\n</ol>\n\n<h3 id=\"erzeugen_eines_objektes\">Erzeugen eines Objektes</h3>\n\n<p>Das Erzeugen eines Objektes erfolgt immer dynamisch mittels des <tt class=\"keyword\">new</tt> Operators in Verbindung mit einem <em>Konstruktor</em>. Das Ergebnis kann einer Variablen mit passendem Typ zugewiesen werden:</p>\n\n<pre class=\"java\">\nStockItem bas = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;BAS&quot;</span>, 120.34);\n</pre>\n\n<p>Eine statische Erzeugung ohne <tt class=\"keyword\">new</tt> analog zu C++ ist in Java nicht m&ouml;glich. Eine Objektvariable enth&auml;lt demnach <em>immer</em> eine <em>Referenz</em> auf das Objekt und nicht das Objekt selbst.</p>\n\n<h3 id=\"benutzen_eines_objektes\">Benutzen eines Objektes</h3>\n\n<p>Ein Objekt wird benutzt, indem eine seiner Methoden aufgerufen wird:</p>\n\n<pre class=\"java\">\nbas.setValue(52.80);\n<span class=\"keyword\">double</span> v = bas.getValue();\n<span class=\"slashslashcomment\">// v sollte jetzt den Wert 52.8 haben</span>\n</pre>\n\n<p>Au&szlig;erdem kann ein Objekt als Parameter an eine Methode &uuml;bergeben oder von dieser per <tt class=\"keyword\">return</tt> zur&uuml;ckgeliefert werden. Die Parameter&uuml;bergabe an Methoden erfolgt in Java immer <em>per Value</em>. Da die Objektvariable in Java aber nur die Referenz auf das Objekt und nicht das Objekt selbst enth&auml;lt, erfolgt hierbei kein Kopieren des Objektes. Als Konsequenz sind &Auml;nderungen am Objekt, die eine Methode vornimmt, auch im aufrufenden Kode sichtbar:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">class</span> Converter {\n  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> split(StockItem item, <span class=\"keyword\">double</span> count) {\n    item.setValue(item.getValue() / count);\n  }\n}\n\nbas.setValue(52.80);\nConverter.split(bas, 2);\nSystem.out.println(bas);\n<span class=\"slashslashcomment\">// gibt &#39;BAS: 26.4&#39; aus</span>\n</pre>\n\n<p>Die Zuweisung eines Objektes an eine Variable betrifft dann ebenso nur die Objektreferenz. Es gibt in Java kein Pendant zum Assignment Operator aus C++.</p>\n\n<pre class=\"java\">\nStockItem x = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;XYZ&quot;</span>, 42);\nStockItem y = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;ABC&quot;</span>, 22);\n\nx = y;\n<span class=\"slashslashcomment\">// Die Variable x enth&auml;lt eine Referenz auf das Objekt mit dem Namen &quot;ABC&quot;.</span>\n<span class=\"slashslashcomment\">// Das Objekt namens &quot;XYZ&quot; wird nicht mehr referenziert und irgendwann vom</span>\n<span class=\"slashslashcomment\">// Garbage Collector entsorgt.</span>\n</pre>\n\n<p>Zuweisungen und Parameter&uuml;bergaben betreffen in Java also immer nur die Objektreferenz. Als Konsequenz wird niemals eine automatische Kopie von Objekten erzeugt. Ben&ouml;tigt man aber doch einmal eine Kopie eines Objektes, kann man daf&uuml;r seine <tt>clone()</tt> Methode verwenden. Diese Methode muss vom Entwickler kodiert werden, es gibt hierf&uuml;r keinen Automatismus. Der Fall, das man eine Kopie eines Objektes ben&ouml;tigt, tritt allerdings &auml;u&szlig;erst selten auf. Dieses Einsteigertutorial verzichtet daher auf eine n&auml;here Betrachtung von <tt>clone()</tt>.</p>\n\n<h3 id=\"statische_methoden\">Statische Methoden</h3>\n\n<p>Bei der im vorigen Abschnitt eingef&uuml;hrten Methode <tt>split</tt> handelt es sich um eine <b>statische</b> Methode. Im Programmcode werden statische Methoden durch das Keyword <tt class=\"keyword\">static</tt> bei der Methodendeklaration gekennzeichnet.</p>\n\n<p>Statische Methoden geh&ouml;ren zu einer bestimmtem Klasse und nicht zu einem Objekt. Daher steht beim Aufruf einer solchen Methode vor dem Punkt auch ein Klassenname und keine Variable. Statische Methoden haben logischerweise keinen Zugriff auf die nicht-statischen Variablen und Methoden der Klasse. Oft werden <tt class=\"keyword\">static</tt> Methoden als Utility- und Hilfsfunktionen verwendet, die nicht im Kontext eines bestimmten Objektes ausgef&uuml;hrt werden m&uuml;ssen. Prominentes Beispiel daf&uuml;r sind die mathematischen Funktionen aus <tt>java.lang.Math</tt>.</p>\n\n<h3 id=\"zerst_ren_eines_objektes\">Zerst&ouml;ren eines Objektes</h3>\n\n<p>Der Java Programmierer braucht sich nicht um das Aufr&auml;umen nicht mehr ben&ouml;tigter Objekte zu k&uuml;mmern. Das erledigt der Garbage Collector (GC) f&uuml;r ihn.</p>\n\n<p>Der GC f&uuml;hrt Buch &uuml;ber alle per <tt class=\"keyword\">new</tt> angelegten Objekte. Er pr&uuml;ft in regelm&auml;&szlig;igen Abst&auml;nden, ob es Objekte gibt, die von keiner Variablem mehr referenziert werden. Der von diesen Objekten belegte Speicherplatz wird dann freigegeben.</p>\n\n<p>Es gibt in Java im Unterschied zu C++ daher auch keinen delete Operator und keinen Destruktor. Falls man doch eine M&ouml;glichkeit ben&ouml;tigt, kurz vor dem Entfernen des Objektes noch eigenen Programmcode auszuf&uuml;hren, kann daf&uuml;r die Methode <tt>finalize()</tt> genutzt werden.</p>\n"
          ]
        },
        {
          "tag_line": "Vererbung",
          "qType": "SMALL_de_4",
          "details": [
            "<h2>Vererbung</h2>\n\n<h3 id=\"konzept\">Konzept</h3>\n\n<p>Vererbung erlaubt die Definition neuer Klassen auf der Basis von bestehenden Klassen. Dies ist ein grundlegendes Konzept objektorientierten Designs. <img align=\"left\" alt=\"Vererbung\" height=\"107\" src=\"https://www.kompf.de/java/images/java-tutor-3.gif\" width=\"173\" /> Weiter oben wurde der Begriff der <em>Klasse</em> als eine Art Bauplan f&uuml;r Objekte erkl&auml;rt. Anhand des dort verwendeten Beispiels &quot;Fahrrad&quot; lassen sich weitere Parallelen zur realen Welt ziehen: Es f&auml;llt auf, dass es hier <em>verschiedene Arten</em> von Fahrr&auml;dern gibt: Rennr&auml;der, Montainbikes, Trekkingr&auml;der und das gute alte Hollandrad. Warum sind alle diese verschiedenen R&auml;der als F&auml;hrr&auml;der erkennbar? Weil sie gewisse gemeinsame Eigenschaften haben: Alle haben zwei R&auml;der, einen Lenker und lassen sich durch Tritt auf die Pedale fortbewegen. Zus&auml;tzlich zu diesen Gemeinsamkeiten bringen sie aber auch neue Eigenschaften ein: Montainbikes und Rennr&auml;der haben jeweils eine Gangschaltung, unterscheiden sich aber durch die Art der Bereifung.</p>\n\n<p>In objektorientierter Sprache k&ouml;nnte man also sagen: Die Klassen Montainbikes, Rennr&auml;der und Hollandr&auml;der <em>erben</em> von der Klasse Fahrr&auml;der gemeinsame Eigenschaften und f&uuml;gen zus&auml;tzliche hinzu. Allgemein gilt:</p>\n\n<ul>\n\t<li>Klassen k&ouml;nnen definiert werden in Abh&auml;ngigkeit von anderen Klassen: &quot;A ist eine Art von B&quot;. In diesem Fall ist B die <em>Basisklasse</em> von A.</li>\n\t<li>Eine Klasse kann auch von mehreren Klassen erben: A ist eine Art von B und C (Mehrfachvererbung). Allerdings ist Mehrfachvererbung in Java nicht f&uuml;r Klassen, sondern nur f&uuml;r <a href=\"https://www.kompf.de/java/tutor.html#h2_interfaces\">Interfaces</a> erlaubt.</li>\n\t<li>Jede Klasse erbt die (&ouml;ffentlichen) Attribute und Methoden ihrer Basisklasse(n).</li>\n\t<li>Jedoch kann jede Klasse eigene Variablen und Methoden hinzuf&uuml;gen.</li>\n</ul>\n\n<p>Es ist wichtig zu verstehen, dass Vererbung nur in eine Richtung l&auml;uft: Ein Rennrad ist zwar immer auch ein Fahrrad, aber nicht jedes Fahrrad ist automatisch ein Rennrad.</p>\n\n<h3 id=\"vererbung_in_java\">Vererbung in Java</h3>\n\n<p>Die bereits definierte und benutzte Klasse <em>StockItem</em> erlaubt die Speicherung eines Namens und eines dazugeh&ouml;renden Wertes und ist zur Darstellung von Aktienkursen gedacht. Wer sich mit dieser Materie schon besch&auml;ftigt hat, der wei&szlig;, dass zu einer Aktie noch viele Informationen mehr gespeichert werden k&ouml;nnen. So gibt es neben dem (Tages- oder Wochen-)Schlusskurs (<em>Close</em>) noch Er&ouml;ffnungs- (<em>Open</em>), H&ouml;chst- (<em>High</em>) und Tiefstkurs (<em>Low</em>). StockItem soll daher um die M&ouml;glichkeit erweitert werden, statt nur einem Wert die Er&ouml;ffnungs- und Schlusskurse abfragen und setzen zu k&ouml;nnen.</p>\n\n<p>Diese Erweiterung soll jedoch nicht durch Ver&auml;ndern der existierenden Klasse StockItem erfolgen - diese Klasse wird bereits in vielen Softwareprojekten benutzt und eine &Auml;nderung ihrer Funktionalit&auml;t k&ouml;nnte unter Umst&auml;nden b&ouml;se Auswirkungen haben. Auch will man das Rad nicht v&ouml;llig neu erfinden - vorhandener Code soll so weit wie m&ouml;glich wiederverwendet werden. Das alles l&auml;sst sich dadurch erreichen, indem eine neue Klasse <em>StockItemOC</em> definiert wird, die von der vorhandenen Klasse StockItem <em>abgeleitet</em> ist:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">package</span> de.kompf.tutor;\n\n<span class=\"doccomment\">/**\n * Class representing a StockItem with open and close value.\n */</span>\n<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> StockItemOC <span class=\"keyword\">extends</span> StockItem {\n\n  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> m_open;\n  <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> m_close;\n  \n  <span class=\"doccomment\">/**\n   * Construct a new StockItemOC with empty name and no values.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC() {\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItemOC with no values.\n   * \n   * @param name The name.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC(String name) {\n    <span class=\"keyword\">super</span>(name);\n  }\n\n  <span class=\"doccomment\">/**\n   * Construct a new StockItemOC.\n   * \n   * @param name The name.\n   * @param open The open value.\n   * @param close The close value.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC(String name, <span class=\"keyword\">double</span> open, <span class=\"keyword\">double</span> close) {\n    <span class=\"keyword\">super</span>(name);\n    m_open = open;\n    m_close = close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The value of this item which is identical to the close value.\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getValue() {\n    <span class=\"keyword\">return</span> m_close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param val The value of this item to set.\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setValue(<span class=\"keyword\">double</span> val) {\n    m_close = val;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The open value.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getOpen() {\n    <span class=\"keyword\">return</span> m_open;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param open The open value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setOpen(<span class=\"keyword\">double</span> open) {\n    m_open = open;\n  }\n\n  <span class=\"doccomment\">/**\n   * @return The close value.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> getClose() {\n    <span class=\"keyword\">return</span> m_close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @param close The close value to set.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setClose(<span class=\"keyword\">double</span> close) {\n    m_close = close;\n  }\n\n  <span class=\"doccomment\">/**\n   * @see Object#toString()\n   */</span>\n  @Override\n  <span class=\"keyword\">public</span> String toString() {\n    <span class=\"keyword\">return</span> getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + m_open + <span class=\"quotedstring\">&quot;/&quot;</span> + m_close;\n  }\n}\n</pre>\n\n<p>Die einzige syntaktische Erweiterung gegen&uuml;ber der bekannten Klassendefinition ist, dass zu Beginn der Definition nach dem Klassennamen <tt>StockItemOC</tt> das Schl&uuml;sselwort <tt class=\"keyword\">extends</tt> gefolgt vom Namen der Basisklasse angegeben wird.</p>\n\n<p>Welche Auswirkung hat diese Vererbungsbeziehung nun auf das Verhalten der abgeleiteten Klasse StockItemOC? <img align=\"left\" alt=\"class StockItemOC\" height=\"386\" src=\"https://www.kompf.de/java/images/java-tutor-4.png\" style=\"margin:5px 35px 5px 0px;\" width=\"159\" /></p>\n\n<ul>\n\t<li>StockItemOC <em>erbt</em> die Methode getName() von StockItem. Diese Methode braucht also nicht noch einmal implementiert zu werden.</li>\n\t<li>StockItemOC <em>&uuml;berschreibt</em> die Methoden setValue() und getValue() von StockItem. Diese Methoden m&uuml;ssen anders implementiert sein, da StockItemOC ja zwei Kurswerte statt einem zur Auswahl hat.</li>\n\t<li>StockItemOC hat die <em>zus&auml;tzlichen</em> Methoden getOpen(), setOpen(), getClose() und setClose(), um die zus&auml;tzliche gew&uuml;nschte Funktionalit&auml;t abbilden zu k&ouml;nnen.</li>\n\t<li>StockItemOC <em>erbt</em> die Variablen m_name und m_value von StockItem. Da diese Variablen dort aber als <em>private</em> deklariert sind, haben die Methoden von StockItemOC keinen Zugriff auf diese Variable - au&szlig;er nat&uuml;rlich getName(), denn diese ist ja auch von StockItem geerbt.</li>\n\t<li>StockItemOC deklariert die <em>zus&auml;tzlichen</em> privaten Variablen m_open und m_close.</li>\n</ul>\n\n<p>Interessant sind auch die Konstruktoren der Klasse: Da ja kein Zugriff auf die <tt class=\"keyword\">private</tt> Membervariablen der Basisklasse erlaubt ist, erfolgt das Setzen von <tt>m_name</tt> &uuml;ber den Aufruf des Konstruktors der Basisklasse per <tt class=\"keyword\">super</tt><tt>(<i>Parameterliste</i>)</tt>. Der Aufruf von <tt class=\"keyword\">super</tt> muss immer das erste Statement im Konstruktor sein. L&auml;sst man ihn - wie im parameterlosen Defaultkonstruktor des Beispiels - weg, dann f&uuml;gt der Compiler implizit <tt class=\"keyword\">super()</tt> ein.</p>\n\n<h3 id=\"verwendung_abgeleiteter_klassen\">Verwendung abgeleiteter Klassen</h3>\n\n<p>Die Verwendung von abgeleiteten Klassen soll nun anhand der Klasse StockItemOC in einem kleinen Testprogramm demonstriert werden.</p>\n\n<p>Als Eintrittspunkt in ein Java-(Konsolen-)Programm dient die spezielle statische Methode <tt>main</tt> mit genau der im folgenden Beispiel angegebenen Signatur:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) {\n  StockItem a = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;BAY&quot;</span>, 34.9);\n  StockItem b = <span class=\"keyword\">new</span> StockItem(<span class=\"quotedstring\">&quot;BAS&quot;</span>, 24.2);\n  StockItemOC c = <span class=\"keyword\">new</span> StockItemOC(<span class=\"quotedstring\">&quot;DTE&quot;</span>, 57.0, 59.4);\n\n  System.out.println(a.getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + a.getValue());\n  System.out.println(b.getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + b.getValue());\n  System.out.println(c.getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + c.getValue() \n      + <span class=\"quotedstring\">&quot; (&quot;</span> + c.getOpen() + <span class=\"quotedstring\">&quot;/&quot;</span> + c.getClose() + <span class=\"quotedstring\">&quot;)&quot;</span>);\n</pre>\n\n<p>Dies bietet auf den ersten Blick nichts neues. Beim zweiten Hinsehen erkennen wir, dass in der letzten Anweisung die Methode getName() des Objektes c, welches vom Typ StockItemOC ist, aufgerufen wird. Die Klasse StockItemOC hat aber gar keine Methode getName() definiert! Mit dem neu erworbenen Wissen &uuml;ber Vererbung ist jedoch klar, was passiert: Es wird einfach die von der Klasse StockItem <em>geerbte</em> Methode verwendet!</p>\n\n<p>Interessant ist auch die Verwendung der Methode getValue(). Diese gibt es sowohl in StockItem als auch in StockItemOC. In diesem Beispiel ist jedoch relativ einfach zu verstehen, was passiert: In der letzten Anweisung ruft der Java Compiler StockItemOC.getValue() auf, in den Anweisungen davor jedoch StockItem.getValue(). Das ist eindeutig, weil der Typ der Objekte a, b und c bereits zur &Uuml;bersetzungszeit bekannt ist.</p>\n\n<p>Was passiert jedoch, wenn der Compiler beim &Uuml;bersetzen den genauen Typ des Objektes noch nicht kennt? Hier ist die Fortsetzung des Programms:</p>\n\n<pre class=\"java\">\n  <span class=\"slashslashcomment\">// array with element type StockItem</span>\n  StockItem[] astocks = <span class=\"keyword\">new</span> StockItem[3];\n  astocks[0] = a;\n  astocks[1] = b;\n  astocks[2] = c;\n  \n  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = 0; i &lt; astocks.length; ++i) {\n      System.out.println(astocks[i].getName() + <span class=\"quotedstring\">&quot;: &quot;</span> + astocks[i].getValue());\n  }\n</pre>\n\n<p>Beim Aufruf astocks[i].getValue() muss je nachdem, ob die in astocks stehende Variable ein Objekt vom Typ StockItem (bei Index 0 und 1) oder vom Typ StockItemOC (Index 2) referenziert, eine andere Methode aufgerufen werden. Dies kann erst zur Laufzeit entschieden werden, man spricht daher von <em>dynamischer</em> oder <em>sp&auml;ter Bindung</em>.</p>\n\n<p>Der Java Compiler arbeitet immer mit dynamischer Bindung. C++ dagegen erlaubt hier die Steuerung der Bindungsart (statisch oder dynamisch) per Schl&uuml;sselwort <tt>virtual</tt> - diese Falle gibt es in Java zum Gl&uuml;ck nicht.</p>\n\n<p>Zum Schluss noch eine fortgeschrittene Anwendung. Statt in ein Array werden die Objekte in eine Liste gepackt. Anschlie&szlig;end werden sie nach ihrem Wert (getValue()) sortiert und ausgegeben. Das alles funktioniert auch dann, wenn die Liste sowohl Objekte vom Typ StockItem als auch StockItemOC enth&auml;lt:</p>\n\n<pre class=\"cplus\">\n  <span class=\"slashslashcomment\">// get the stock items ordered by price</span>\n  List&lt;StockItem&gt; stocks = <span class=\"keyword\">new</span> LinkedList&lt;StockItem&gt;();\n    \n  stocks.add(a);\n  stocks.add(b);\n  stocks.add(c);\n  \n  Collections.sort(stocks, <span class=\"keyword\">new</span> Comparator&lt;StockItem&gt;() {\n\n    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> compare(StockItem s1, StockItem s2) {\n      <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) Math.signum(s1.getValue() - s2.getValue());\n    }\n  });\n\n  System.out.println(<span class=\"quotedstring\">&quot;stock items ordered by price&quot;</span>);\n  System.out.println(stocks);\n} \n</pre>\n\n<p>F&uuml;r die Sortierung ist ein Comparator notwendig. Dessen Methode <tt>compare</tt> vergleicht die Werte zweier StockItems. Wie man sieht, reicht es v&ouml;llig aus, <tt>compare</tt> f&uuml;r Parameter des Typs StockItem zu implementieren. Es ist beim Aufruf der Methode dann egal, ob der aktuelle Parameter auf ein Objekt vom Typ StockItem oder StockItemOC zeigt. Dies ist ein Resultat (und Vorteil) der verwendeten Vererbungshierarchie.</p>\n\n<p>Die Ausgabe aller Items erfolgt ganz einfach per &Uuml;bergabe der kompletten Liste an <tt>System.out.println</tt>, was im Beispiel den Text</p>\n\n<pre class=\"code\">\n[BAS: 24.2, BAY: 34.9, DTE: 57.0/59.4]\n</pre>\n\n<p>in die Standardausgabe schreibt.</p>\n\n<p><tt>System.out.println</tt> verlangt als Parameter eine Variable vom Typ <tt>Object</tt>. Im Beispiel wird jedoch eine <tt>List</tt> &uuml;bergeben. Bei der Erkl&auml;rung, warum das funktioniert, kommt man zu einer wichtigen Eigenschaft aller Klassen in Java:</p>\n\n<p class=\"definition\">Alle Java Klassen sind implizit von der Klasse <tt>java.lang.Object</tt> abgeleitet.</p>\n\n<p>Also auch die Klassen StockItem und StockItemOC! <tt>System.out.println</tt> ruft nun die Methode <tt>toString()</tt> des &uuml;bergebenen Objekts auf und schreibt den R&uuml;ckgabewert in die Standardausgabe. Die Klasse LinkedList (die ja auch von Object erbt) implementiert <tt>toString()</tt> in der Form, dass f&uuml;r jedes Element der Liste ebenfalls <tt>toString()</tt> aufgerufen wird. Damit wird jetzt klar, warum in den Klassendefinitionen f&uuml;r StockItem und StockItemOC (siehe oben) jeweils die Methode <tt>toString()</tt> implementiert ist! H&auml;tte man dies nicht getan, dann s&auml;he die Ausgabe etwa so aus:</p>\n\n<pre class=\"code\">\n[de.kompf.tutor.StockItem@11b86e7, de.kompf.tutor.StockItem@35ce36, de.kompf.tutor.StockItemOC@757aef]\n</pre>\n\n<p>Es k&auml;me dann die von <tt>Object</tt> geerbte <tt>toString()</tt> Methode zur Anwendung, die den Klassennamen und eine Adresse ausgibt.</p>\n\n<h3 id=\"abstrakte_klassen\">Abstrakte Klassen</h3>\n\n<p>Bei einigen Vererbungshierarchien kommt man vielleicht zu der Erkenntnis, dass f&uuml;r bestimmte Basisklassen nie Objekte instanziert werden. Im oben eingef&uuml;hrten Fahrradbeispiel w&uuml;rde das dann hei&szlig;en, dass es keine Fahrr&auml;der vom Typ &laquo;Fahrrad&raquo; gibt, sondern jedes Fahrad sich einem speziellen, abgeleiteten Typ, wie Rennrad, Hollandrad und so weiter zuordnen l&auml;sst. Die Basisklasse Fahrrad wird dann als <b>abstrakt</b> bezeichnet.</p>\n"
          ]
        },
        {
          "tag_line": "Interfaces",
          "qType": "SMALL_de_5",
          "details": [
            "<h2>Interfaces</h2>\n\n<p>Wenn eine abstrakte Klasse nur noch Methodensignaturen, aber keine Implementierung mehr enth&auml;lt, wird sie zum <b>interface</b>. Java verwendet daf&uuml;r das reservierte Sch&uuml;sselwort <tt class=\"keyword\">interface</tt>.</p>\n\n<p>Ein <tt class=\"keyword\">interface</tt> verwendet man, um das Verhalten von Objekten festzulegen, bei denen man sich (noch) nicht auf eine bestimmte Implementierung festlegen will. Zum Beispiel k&ouml;nnte man so einen <tt>QuoteService</tt> definieren, der die Abfrage von Aktienkursen erlaubt:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">package</span> de.kompf.tutor;\n\n<span class=\"doccomment\">/**\n * Interface to define a service to get quotes.\n */</span>\n<span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> QuoteService {\n\n  <span class=\"doccomment\">/**\n   * Get the last known price for a stock item.\n   * \n   * @param name The name of the item.\n   * @return The price.\n   */</span>\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> lastPrice(String name);\n\n  <span class=\"doccomment\">/**\n   * Get a stock item with the open and close at a given date.\n   * \n   * @param name The name of the item.\n   * @param date The date.\n   * @return The StockItemOC.\n   */</span>\n  <span class=\"keyword\">public</span> StockItemOC openClose(String name, java.util.Date date);\n}\n</pre>\n\n<p>Zu diesem Zeitpunkt gibt es noch keine Implementierung des Interface. Man kann beim Programmieren aber schon so tun, als g&auml;be es eine, indem einfach gegen das Interface programmiert wird:</p>\n\n<pre class=\"java\">\nList&lt;StockItem&gt; myStocks;\nQuoteService quoteService;\n<span class=\"slashslashcomment\">//  ...</span>\n<span class=\"slashslashcomment\">// get actual quotes for my stock</span>\n<span class=\"keyword\">for</span> (StockItem stockItem : myStocks) {\n  <span class=\"keyword\">double</span> lastPrice = quoteService.lastPrice(stockItem.getName());\n  stockItem.setValue(lastPrice);\n}\n</pre>\n\n<p>Um das Programm jetzt schon zu testen, kann man sich einen &laquo;Mock&raquo; Service schreiben, der das Interface QuoteService implementiert und irgendwelche Werte zur&uuml;ckliefert:</p>\n\n<pre class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> MockQuoteService <span class=\"keyword\">implements</span> QuoteService {\n\n  <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> lastPrice(String name) {\n    <span class=\"keyword\">return</span> 10.0;\n  }\n\n  <span class=\"keyword\">public</span> StockItemOC openClose(String name, Date date) {\n    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StockItemOC(name, 10.0, 11.0);\n  }\n}\n</pre>\n\n<p>Im Code erg&auml;nzt man dann</p>\n\n<pre class=\"java\">\nquoteService = <span class=\"keyword\">new</span> MockQuoteService();\n</pre>\n\n<p>Sp&auml;ter, wenn die richtige Implementierung, zum Beispiel als Klasse <tt>YahooQuoteService</tt> zur Verf&uuml;gung steht, &auml;ndert man diese Zeile einfach in</p>\n\n<pre class=\"java\">\nquoteService = <span class=\"keyword\">new</span> YahooQuoteService();\n</pre>\n\n<p>und benutzt von diesem Zeitpunkt an eine andere Implementierung. Am restlichen Programm d&uuml;rfte sich nichts mehr &auml;ndern, wenn man konsequent gegen das Interface programmiert hat.</p>\n\n<p>Diese M&ouml;glichkeit zur Trennung von Interface und Implementierung ist ein gro&szlig;er Vorteil von Java. Insbesondere unter den Aspekten der Teamarbeit und der Wiederverwendbarkeit von Programmcode sollte man sich die Regel &laquo;Programmiere gegen Interfaces statt gegen Implementierungen&raquo; verinnerlichen.</p>\n"
          ]
        }
      ]
    },
    {
      "title": "Objektorientiertes Programmieren mit C++",
      "qType": "BIG_de_2",
      "content": [
        {
          "tag_line": "Objekte",
          "qType": "SMALL_de_6",
          "details": [
            "<h2>Objekte C++</h2>\n\n<p>C++ ist nicht nur das bessere C, sondern bietet dem Entwickler die M&ouml;glichkeit, objektorientiert zu programmieren. Dies verlangt neben dem Erlernen neuer Sprachelemente auch eine neue &quot;objektorientierte&quot; Denkweise. In Form eines Tutorials soll hier mit dieser Denkweise vertraut gemacht werden.</p>\n\n<p>Herk&ouml;mmliche Softwareentwicklung bestand oftmals darin, zur L&ouml;sung eines vorgegebenen Problems Algorithmen zu entwerfen und diese in Prozeduren zu gie&szlig;en, die in einer Programmiersprache - wie zum Beispiel C - formuliert sind. Man spricht daher auch von prozeduraler Programmierung.</p>\n\n<p>Betrachtet man jedoch die reale Welt, so stellt man fest, da&szlig; die Dinge sich hier nicht in einer abstrakten prozeduralen Weise bewegen. Diesen Bruch zwischen realer Welt und Softwareentwicklung versucht der objektorientierte Ansatz zu &uuml;berwinden. Analysiert man seine materielle Umgebung, so stellt man fest, da&szlig; diese im wesentlichen aus Objekten besteht, die in verschiedener Art und Weise miteinander agieren. So k&ouml;nnte es in unserer unmittelbaren Umgebung gerade ein Objekt Fahrrad geben.</p>\n\n<p><img align=\"left\" alt=\"Objekt\" height=\"160\" src=\"https://www.kompf.de/cplus/images/art2s.gif\" width=\"165\" /> Nimmt man das Fahrrad noch weiter unter die Lupe, erkennt man, da&szlig; dieses Fahrrad bestimmte <em>Eigenschaften</em> bzw. <em>Attribute</em> (wie Farbe, Gr&ouml;&szlig;e, momentane Geschwindigkeit) besitzt und da&szlig; es <em>Methoden</em> gibt, diese Eigenschaften zu ver&auml;ndern (z.B. die Methode &quot;Tritt schneller&quot;, die zu einer Erh&ouml;hung der Geschwindigkeit f&uuml;hren wird oder die Methode &quot;Bremse&quot;, die das Gegenteil bewirken sollte).</p>\n\n<p>Transformiert man diese Erkenntnis aus der realen in die Software-Welt, so kann man formulieren:</p>\n\n<p class=\"definition\">Ein Software-Objekt ist ein B&uuml;ndel aus Attributen und darauf bezogenen Methoden.</p>\n"
          ]
        },
        {
          "tag_line": "Klassen",
          "qType": "SMALL_de_7",
          "details": [
            "<h2>Klassen C++</h2>\n\n<h3 id=\"klassen_als_bauplan\">Klassen als Bauplan</h3>\n\n<p>Wenn wir verschiedene Fahrrad-Objekte der realen Welt genauer betrachten, so stellen wir fest, da&szlig; alle diese Fahrrad-Objekte &auml;hnlich sind: Alle besitzen Bremsen, alle haben irgendeine Farbe usw. Es mu&szlig; also einen <em>Bauplan</em> geben, der beschreibt, wie ein Fahrrad grunds&auml;tzlich auszusehen hat. Alle Fahrrad-Objekte sind nach diesem Bauplan erstellt worden - deswegen ist es uns auch m&ouml;glich, ein beliebiges Fahrrad zu fahren, wenn wir einmal das Fahrradfahren gelernt haben! Wieder &uuml;bertragen wir diese Erkenntnis in die Softwarewelt:</p>\n\n<p class=\"definition\">Eine Klasse ist ein Bauplan, welcher die Attribute und Methoden definiert, die alle Objekte einer bestimmten Art besitzen.</p>\n\n<p><img align=\"left\" alt=\"class StockItem\" height=\"127\" src=\"https://www.kompf.de/cplus/images/art4.gif\" width=\"173\" /> Die Abbildung zeigt eine Klasse <tt>StockItem</tt> in der sogenannten UML (unified modelling language) Notation. Diese Klasse k&ouml;nnte in einem Programm zur Aktienanalyse verwendet werden. Ein solches Programm mu&szlig; viele verschiedene Aktien-Objekte verwalten k&ouml;nnen. Damit dies effektiv geschehen kann, sollten alle diese verschiedenen Objekte jedoch nach einem einheitlichen Bauplan - der Klassendefinition - erstellt werden.</p>\n\n<p>Der Name der Klasse steht in der UML-Notation im oberen Drittel des Rechtecks. Im mittleren Drittel stehen die Attribute. Unsere Beispielklasse <tt>StockItem</tt> definiert die zwei Attribute m_name und m_value, d.h. den Namen der Aktie und den momentanen Kurswert. Das Minuszeichen vor den Attributen bedeutet, das diese <tt class=\"keyword\">private</tt> Mitglieder der Klasse sind, d.h. von au&szlig;en kann nicht direkt auf sie zugegriffen werden.</p>\n\n<p>Im unteren Drittel stehen die Methoden der Klasse <tt>StockItem</tt>. Das Pluszeichen vor ihnen zeigt, da&szlig; sie <tt class=\"keyword\">public</tt> sind, d.h. die Methoden d&uuml;rfen von anderen Objekten aufgerufen werden. Damit zeigt sich das Prinzip der Kapselung: Anstatt auf das Attribut m_value direkt zuzugreifen, <em>m&uuml;ssen</em> andere Objekte die Zugriffsmethoden setValue() und getValue() benutzen! So hat der Entwickler der Klasse die M&ouml;glichkeit, in setValue() noch zus&auml;tzliche Abfragen, z.B. bez&uuml;glich der G&uuml;ltigkeit des Parameters, einzubauen.</p>\n\n<p>Aufmerksamen Lesern wird bei Betrachtung der Abbildung eine Erweiterung von C++ gegen&uuml;ber C nicht entgangen sein: Funktionen werden in C++ nicht nur - wie in C - durch den Namen, sondern durch Namen <em>und</em> Parameteranzahl und -typ unterschieden! So kann es die Methode setValue() zweimal geben: Einmal mit einem Parameter vom Typ <tt class=\"keyword\">double</tt> und mit einem vom Typ <tt><span class=\"keyword\">const char</span>*</tt>. Der Compiler erkennt beim Aufruf dieser Methode anhand des Parametertyps selbstt&auml;tig, welche Variante er verwenden mu&szlig;.</p>\n\n<h3 id=\"klassendefinition\">Klassendefinition</h3>\n\n<p>Es ist angebracht, C++-Klassendefinitionen generell in Headerdateien (das sind die mit der Extension .h) vorzunehmen. Guter Programmierstil ist dabei, jeweils eine Headerdatei je Klasse vorzusehen und diese auch wie die Klasse zu benennen.</p>\n\n<p>Die Klassendefinition f&uuml;r StockItem wird also in der Headerdatei mit dem Namen <b>StockItem.h</b> vorgenommen:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#ifndef StockItem_h</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#define StockItem_h 1</span>\n<span class=\"comment\">/*  3 */</span>\n<span class=\"comment\">/*  4 */</span>  <span class=\"keyword\">class</span> StockItem {\n<span class=\"comment\">/*  5 */</span>\n<span class=\"comment\">/*  6 */</span>  <span class=\"keyword\">public</span>:\n<span class=\"comment\">/*  7 */</span>      <span class=\"slashslashcomment\">// ctor</span>\n<span class=\"comment\">/*  8 */</span>      StockItem( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name = <span class=\"quotedstring\">&quot;&quot;</span>, <span class=\"keyword\">double</span> val = 0.0);\n<span class=\"comment\">/*  9 */</span>\n<span class=\"comment\">/* 10 */</span>      <span class=\"slashslashcomment\">// copy ctor</span>\n<span class=\"comment\">/* 11 */</span>      StockItem( <span class=\"keyword\">const</span> StockItem &amp;right);\n<span class=\"comment\">/* 12 */</span>      <span class=\"slashslashcomment\">// dtor</span>\n<span class=\"comment\">/* 13 */</span>      <span class=\"keyword\">virtual</span> ~StockItem();\n<span class=\"comment\">/* 14 */</span>      <span class=\"slashslashcomment\">// assignment operator</span>\n<span class=\"comment\">/* 15 */</span>      <span class=\"keyword\">const</span> StockItem&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItem &amp;right);\n<span class=\"comment\">/* 16 */</span>\n<span class=\"comment\">/* 17 */</span>      <span class=\"slashslashcomment\">// public member functions</span>\n<span class=\"comment\">/* 18 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* getName() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 19 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setValue( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 20 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setValue( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* val);\n<span class=\"comment\">/* 21 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getValue() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 22 */</span>\n<span class=\"comment\">/* 23 */</span>  <span class=\"keyword\">private</span>:\n<span class=\"comment\">/* 24 */</span>      <span class=\"slashslashcomment\">// private member variables</span>\n<span class=\"comment\">/* 25 */</span>      <span class=\"keyword\">char</span> *m_name;\n<span class=\"comment\">/* 26 */</span>      <span class=\"keyword\">double</span> m_value;\n<span class=\"comment\">/* 27 */</span>  };\n<span class=\"comment\">/* 28 */</span>\n<span class=\"comment\">/* 29 */</span>  <span class=\"preprocessor\">#endif </span>\n</pre>\n\n<p>Die Klassendefinition beginnt mit dem Schl&uuml;sselwort <tt class=\"keyword\">class</tt> gefolgt vom Namen der Klasse (Zeile 4). Die eigentliche Definition wird von geschweiften Klammern { } umschlossen. Die Schl&uuml;sselw&ouml;rter <tt class=\"keyword\">public</tt> und <tt class=\"keyword\">private</tt> trennen die im letzten Abschnitt besprochenen &ouml;ffentlichen (Zeilen 7 bis 21) und privaten (Zeilen 24 bis 26) Bereiche der Definition ab. Es gibt au&szlig;erdem noch die M&ouml;glichkeit, mittels <tt class=\"keyword\">protected</tt> Variablen und Methoden zu deklarieren, die ausschlie&szlig;lich abgeleiteten Klassen zur Verf&uuml;gung stehen sollen. Dazu mehr sp&auml;ter mehr beim Thema <em>Vererbung</em>.</p>\n\n<p>Die Deklaration der &ouml;ffentlichen Methoden (Zeilen 18 bis 19) und der privaten Variablen (Zeilen 25 und 26) erfolgt genauso wie eine normale Deklaration von Funktionen bzw. Variablen in C. Bei den Funktionen f&auml;llt die Verwendung der Spezifikation <tt class=\"keyword\">virtual</tt> auf. Dies ist wiederum f&uuml;r das Thema <em>Vererbung</em> wichtig und wird sp&auml;ter besprochen. Man macht jedoch nicht viel verkehrt, wenn man direkt jeder Funktion von vorneherein diese Spezifikation verpa&szlig;t.</p>\n\n<p>Auf den Zeilen 7 bis 15 werden <em>Constructor</em>, <em>Copy-Constructor</em>, <em>Destructor</em> und <em>Assignment Operator</em> deklariert. Um den Sinn dieser Elemente verstehen zu k&ouml;nnen, m&uuml;ssen wir zun&auml;chst auf den <em>Objektlebenszyklus</em> eingehen</p>\n\n<p><em>PS: Noch ein kleiner Tip: Der Compiler produziert die wunderlichsten Fehlermeldungen, wenn der Programmierer das Semikolon am Ende der Klassendefinition (Zeile 27) vergi&szlig;t...</em></p>\n"
          ]
        },
        {
          "tag_line": "Objektlebenszyklus",
          "details": [
            "<h2>Objektlebenszyklus C++</h2>\n\n<p>Der Lebenszyklus eines C++-Objektes besteht aus den Abschnitten</p>\n\n<ol>\n\t<li>Erzeugung</li>\n\t<li>Benutzung</li>\n\t<li>Zerst&ouml;rung</li>\n</ol>\n\n<h3 id=\"erzeugen_eines_objektes\">Erzeugen eines Objektes</h3>\n\n<p>Das Erzeugen eines Objektes erfogt durch Aufruf des <em>Konstruktors</em> (kurz <em>ctor</em>) des Objektes. Dies kann sowohl statisch durch Variablendeklaration als auch dynamisch mittels des <tt class=\"keyword\">new</tt> Operators geschehen:</p>\n\n<pre class=\"cplus\">\nStockItem bay;\n<span class=\"slashslashcomment\">// default constructor, statisch</span>\n\nStockItem dte( <span class=\"quotedstring\">&quot;Deutsche Telekom AG&quot;</span>, 50.34);\n<span class=\"slashslashcomment\">// spezieller ctor, statisch</span>\n\nStockItem *bas = <span class=\"keyword\">new</span> StockItem( <span class=\"quotedstring\">&quot;BASF&quot;</span>, 120.34);\n<span class=\"slashslashcomment\">// spezieller ctor, dynamisch </span>\n<span class=\"slashslashcomment\">// der f&uuml;r bas n&ouml;tige Speicherplatz wird auf dem Heap alloziert</span>\n</pre>\n\n<h3 id=\"benutzen_eines_objektes\">Benutzen eines Objektes</h3>\n\n<p>Ein Objekt wird benutzt, indem eine seiner Methoden aufgerufen wird:</p>\n\n<pre class=\"cplus\">\ndte.setValue( 52.80);\n<span class=\"slashslashcomment\">// ruft Methode StockItem::setValue() des Objektes dte auf</span>\n\na = bas-&gt;getValue();\n<span class=\"slashslashcomment\">// ruft Methode StockItem::getValue() des Objektes bas auf </span>\n</pre>\n\n<p>Au&szlig;erdem kann das komplette Objekt als Parameter an eine Funktion &uuml;bergeben oder von dieser per <tt class=\"keyword\">return</tt> zur&uuml;ckgegeben werden. Erfolgt die Wert&uuml;bergabe dabei <em>per Value</em>, so wird implizit der <em>Copy Konstruktor</em> des Objektes aufgerufen:</p>\n\n<pre class=\"cplus\">\nStockItem cnv( StockItem x) {\n    <span class=\"slashslashcomment\">// ...</span>\n\n    <span class=\"keyword\">return</span> x2;\n    <span class=\"slashslashcomment\">// return per value: ruft den Copy Constructor von x2 auf</span>\n}\n\nStockItem bas( <span class=\"quotedstring\">&quot;BASF&quot;</span>, 120.34);\ncnv( bas);\n<span class=\"slashslashcomment\">// parameter per value: ruft den Copy Constructor von bas auf</span>\n\nStockItem bas2 = bas;\n<span class=\"slashslashcomment\">// explizite Kopie: ruft den Copy Constructor von bas2 auf </span>\n</pre>\n\n<p>Ebenso kann ein Objekt komplett einem anderen bereits existierenden Objekt zugewiesen werden, wenn dieses den gleichen Typ oder den Typ einer Basisklasse hat. Dann wird der <em>Assignment Operator</em> des Objektes aufgerufen:</p>\n\n<pre class=\"cplus\">\nStockItem x;\nStockItem y( <span class=\"quotedstring\">&quot;ABC&quot;</span>, 22);\n\nx = y;\n<span class=\"slashslashcomment\">// ruft den Assignment Operator von x auf</span>\n</pre>\n\n<h3 id=\"zerst\">Zerst&ouml;ren eines Objektes</h3>\n\n<p>Wird ein Objekt nicht mehr ben&ouml;tigt, so sollte es zerst&ouml;rt werden, damit es keinen Speicherplatz mehr verbraucht. Bei der Zerst&ouml;rung eines Objektes wird automatisch sein <em>Destruktor</em> (kurz <em>dtor</em>) aufgerufen. Im Falle eines dynamisch per <tt class=\"keyword\">new</tt> erzeugten Objektes wird dies mit dem Operator <tt class=\"keyword\">delete</tt> bewerkstelligt. Ein statisch erzeugtes Objekt wird automatisch zerst&ouml;rt, wenn bei der Programmausf&uuml;hrung der G&uuml;ltigkeitsbereich der statischen Deklaration verlassen wird:</p>\n\n<pre class=\"cplus\">\n<span class=\"keyword\">delete</span> bas;\n<span class=\"slashslashcomment\">// der Destructor des Objektes bas wird aufgerufen und anschlie&szlig;end</span>\n<span class=\"slashslashcomment\">// der durch bas belegte Speicherplatz freigegeben</span>\n<span class=\"keyword\">if</span> (x) {\n    StockItem bmw;\n    <span class=\"slashslashcomment\">// ...</span>\n} <span class=\"slashslashcomment\">// der dtor des statisch angelegten Objektes bmw wird hier am Blockende</span>\n<span class=\"slashslashcomment\">// wegen des Verlassens des G&uuml;ltigkeitsbereiches der Deklaration aufgerufen</span>\n</pre>\n\n<p><strong>Beachte:</strong>Der Destruktor eines Objektes wird in der Regel niemals direkt aufgerufen, sondern sein Aufruf erfolgt wie oben dargestellt implizit durch Verwendung von <tt class=\"Keyword\">delete</tt> oder beim Verlassen des G&uuml;ltigkeitsbereiches!</p>\n\n<h2 id=\"objektimplementierung\">Objektimplementierung</h2>\n\n<p>Was uns nun noch zum ersten vollst&auml;ndigen C++-Programm fehlt, ist die Implementierung der einzelnen Methoden des Objektes StockItem.</p>\n\n<p>Die Implementierung wird vorzugsweise in einer Datei mit Namen <b>StockItem.cpp</b> vorgenommen. Zu Beginn wird die Headerdatei <b>StockItem.h</b> inkludiert:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#include &quot;StockItem.h&quot;</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#include &lt;cstdlib&gt;</span>\n<span class=\"comment\">/*  3 */</span>  <span class=\"preprocessor\">#include &lt;cstring&gt;</span>\n<span class=\"comment\">/*  4 */</span> \n<span class=\"comment\">/*  5 */</span>  StockItem::StockItem( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name <span class=\"comment\">/* = &quot;&quot; */</span>, <span class=\"keyword\">double</span> val <span class=\"comment\">/* = 0.0 */</span>)\n<span class=\"comment\">/*  6 */</span>  {\n<span class=\"comment\">/*  7 */</span>      m_name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[strlen(name)+1];\n<span class=\"comment\">/*  8 */</span>      strcpy( m_name, name);\n<span class=\"comment\">/*  9 */</span>      m_value = val;\n<span class=\"comment\">/* 10 */</span>  }\n<span class=\"comment\">/* 11 */</span>\n<span class=\"comment\">/* 12 */</span>  StockItem::StockItem( <span class=\"keyword\">const</span> StockItem &amp;right)\n<span class=\"comment\">/* 13 */</span>\n<span class=\"comment\">/* 14 */</span>  {\n<span class=\"comment\">/* 15 */</span>\n<span class=\"comment\">/* 16 */</span>      m_name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[strlen( right.m_name)+1];\n<span class=\"comment\">/* 17 */</span>      strcpy( m_name, right.m_name);\n<span class=\"comment\">/* 18 */</span>      m_value = right.m_value;\n<span class=\"comment\">/* 19 */</span>  }\n<span class=\"comment\">/* 20 */</span>\n<span class=\"comment\">/* 21 */</span>  StockItem::~StockItem()\n<span class=\"comment\">/* 22 */</span>  {\n<span class=\"comment\">/* 23 */</span>      <span class=\"keyword\">delete</span>[] m_name;\n<span class=\"comment\">/* 24 */</span>  }\n<span class=\"comment\">/* 25 */</span>\n<span class=\"comment\">/* 26 */</span>  <span class=\"keyword\">const</span> StockItem&amp; StockItem::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItem &amp;right)\n<span class=\"comment\">/* 27 */</span>  {\n<span class=\"comment\">/* 28 */</span>      <span class=\"slashslashcomment\">// handle self assignment</span>\n<span class=\"comment\">/* 29 */</span>      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;right) {\n<span class=\"comment\">/* 30 */</span>          <span class=\"keyword\">delete</span>[] m_name;\n<span class=\"comment\">/* 31 */</span>          m_name = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[strlen( right.m_name)+1];\n<span class=\"comment\">/* 32 */</span>          strcpy( m_name, right.m_name);\n<span class=\"comment\">/* 33 */</span>          m_value = right.m_value;\n<span class=\"comment\">/* 34 */</span>      }\n<span class=\"comment\">/* 35 */</span>\n<span class=\"comment\">/* 36 */</span>      <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;\n<span class=\"comment\">/* 37 */</span>  }\n<span class=\"comment\">/* 38 */</span>\n<span class=\"comment\">/* 39 */</span>  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* StockItem::getName() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 40 */</span>  {\n<span class=\"comment\">/* 41 */</span>      <span class=\"keyword\">return</span> m_name;\n<span class=\"comment\">/* 42 */</span>  }\n<span class=\"comment\">/* 43 */</span>\n<span class=\"comment\">/* 44 */</span>  <span class=\"keyword\">void</span> StockItem::setValue( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 45 */</span>  {\n<span class=\"comment\">/* 46 */</span>      m_value = val;\n<span class=\"comment\">/* 47 */</span>  }\n<span class=\"comment\">/* 48 */</span>\n<span class=\"comment\">/* 49 */</span>  <span class=\"keyword\">void</span> StockItem::setValue( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* val)\n<span class=\"comment\">/* 50 */</span>  {\n<span class=\"comment\">/* 51 */</span>      m_value = atof( val);\n<span class=\"comment\">/* 52 */</span>  }\n<span class=\"comment\">/* 53 */</span>\n<span class=\"comment\">/* 54 */</span>  <span class=\"keyword\">double</span> StockItem::getValue() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 55 */</span>  {\n<span class=\"comment\">/* 56 */</span>      <span class=\"keyword\">return</span> m_value;\n<span class=\"comment\">/* 57 */</span>  } \n</pre>\n\n<p>Die Implementierung der &ouml;ffentlichen Methoden f&uuml;r das Setzen und Auslesen der Werte der Attribute in den Zeilen 39 bis 57 enth&auml;lt nichts besonderes, der Code d&uuml;rfte f&uuml;r sich sprechen.</p>\n\n<p>Interessanter ist der Konstruktor (Zeilen 5 bis 10): Da wir den Namen des <tt>StockItem</tt> in einer C-Zeichenkette vom Typ <tt><span class=\"keyword\">char</span>*</tt> speichern wollen, mu&szlig; zuerst der hierf&uuml;r notwendige Speicherplatz allokiert werden (Zeile 7). Da wir in C++ programmieren, verwenden wir nicht das aus der C-Welt vertraute <tt>malloc</tt>, sondern den C++-Operator <tt><span class=\"keyword\">new</span>[]</tt>.</p>\n\n<p>&Auml;hnlich verh&auml;lt sich die Sache beim Copy Konstruktor (Zeilen 12 bis 19): Hier ist das einzige Argument immer eine Referenz auf ein Objekt des gleichen Typs. Dessen Membervariablen m&uuml;ssen in die eigenen Variablen <em>kopiert</em> werden, damit eine 1:1 Kopie des Objektes entsteht. Wir erinnern uns: Der Copy Konstruktor wird bei &Uuml;bergabe von Objekten per Value an oder aus Funktionen oder beim expliziten Kopieren verwendet.</p>\n\n<p>Noch interessanter gestaltet sich die Sache beim Assignment Operator (Zeilen 26 bis 37): Hier existiert ja schon ein Objekt x, in das ein zweites Objekt y hineinkopiert wird! Also mu&szlig; <em>zuerst</em> der von x belegte Speicherplatz freigegeben werden (Zeile 30), bevor die Variablen kopiert werden k&ouml;nnen. In der C++-Sprache bezeichnet man &uuml;brigens unser Objekt x als <tt class=\"keyword\">this</tt>. Der Bezug auf das eigene Objekt <tt class=\"keyword\">this</tt> ist so wichtig, da&szlig; <tt class=\"keyword\">this</tt> sogar ein reserviertes Wort in C++ ist und immer innerhalb von Objektfunktionen zur Verf&uuml;gung steht. Der Assignment Operator gibt einen Zeiger auf das Objekt selbst (also auf <tt class=\"keyword\">this</tt>) zur&uuml;ck, schlie&szlig;lich wird er ja in Zuweisungen wie</p>\n\n<pre class=\"cplus\">\nStockItem x;\nStockItem y( <span class=\"quotedstring\">&quot;ABC&quot;</span>, 22);\n\nx = y;\n</pre>\n\n<p>verwendet.</p>\n\n<p>&Uuml;brigens hindert niemand den Programmierer, statt x = y die Zuweisung x = x hinzuschreiben! Dann haben wir den Fall des <em>Self Assignments</em> vorliegen: Ein Objekt wird sich selbst zugewiesen. Dann darf der Assignment Operator auch nichts weiter tun. Die Abfrage, ob Self Assignment vorliegt, findet in Zeile 29 statt.</p>\n\n<p>Der mittels <tt><span class=\"keyword\">new</span>[]</tt> vom Betriebssystem w&auml;hrend der Objektkonstruktion explizit angeforderte Speicherplatz mu&szlig; beim Zerst&ouml;ren des Objektes auch wieder ausdr&uuml;cklich freigegeben werden. Wir erinnern uns: Beim Zerst&ouml;ren des Objektes wird automatisch sein Destruktor ausgef&uuml;hrt. Deswegen wird im Destruktor (Zeilen 21 bis 24) der f&uuml;r m_name angeforderte Speicherbereich mittels <tt><span class=\"keyword\">delete</span>[]</tt> freigegeben.</p>\n"
          ]
        },
        {
          "tag_line": "Vererbung",
          "details": [
            "<h2>Vererbung C++</h2>\n\n<h3 id=\"konzept\">Konzept</h3>\n\n<p>Vererbung erlaubt die Definition neuer Klassen auf der Basis von bestehenden Klassen. Dies ist ein grundlegendes Konzept objektorientierten Designs. <img align=\"left\" alt=\"Vererbung\" height=\"107\" src=\"https://www.kompf.de/cplus/images/c++-part6.gif\" width=\"173\" /> Weiter oben wurde der Begriff der <em>Klasse</em> als eine Art Bauplan f&uuml;r Objekte erkl&auml;rt. Anhand des dort verwendeten Beispiels &quot;Fahrrad&quot; lassen sich weitere Parallelen zur realen Welt ziehen: Es f&auml;llt auf, da&szlig; es hier <em>verschiedene Arten</em> von Fahrr&auml;dern gibt: Rennr&auml;der, Montainbikes, Treckingr&auml;der und das gute alte Hollandrad. Warum sind alle diese verschiedenen R&auml;der f&uuml;r uns als F&auml;hrr&auml;der erkennbar? Weil sie gewisse gemeinsame Eigenschaften haben: Alle haben zwei R&auml;der, einen Lenker und lassen sich durch Tritt auf die Pedale fortbewegen. Zus&auml;tzlich zu diesen Gemeinsamkeiten bringen sie aber auch neue Eigenschaften ein: Montainbikes und Rennr&auml;der haben jeweils eine Gangschaltung, unterscheiden sich aber durch die Art der Bereifung.</p>\n\n<p>In objektorientierter Sprache k&ouml;nnte man also sagen: Die Klassen Montainbikes, Rennr&auml;der und Hollandr&auml;der <em>erben</em> von der Klasse Fahrr&auml;der gemeinsame Eigenschaften und f&uuml;gen zus&auml;tzliche hinzu. Allgemein gilt:</p>\n\n<ul>\n\t<li>Klassen k&ouml;nnen definiert werden in Abh&auml;ngigkeit von anderen Klassen: &quot;A ist eine Art von B&quot;. In diesem Fall ist B die <em>Basisklasse</em> von A.</li>\n\t<li>Eine Klasse kann auch von mehreren Klassen erben: A ist eine Art von B und C (Mehrfachvererbung).</li>\n\t<li>Jede Klasse erbt die (&ouml;ffentlichen) Attribute und Methoden ihrer Basisklasse(n).</li>\n\t<li>Jedoch kann jede Klasse eigene Variablen und Methoden hinzuf&uuml;gen.</li>\n</ul>\n\n<p>Es ist wichtig zu verstehen, da&szlig; Vererbung nur in eine Richtung l&auml;uft: Ein Rennrad ist zwar immer auch ein Fahrrad, aber nicht jedes Fahrrad ist automatisch ein Rennrad. Wenn in C++ ein Objekt a der Klasse A definiert wird und die Klasse A von B abgeleitet ist, dann kann a jederzeit per Cast in ein Objekt vom Typ B umgewandelt werden. Die Umkehrung gilt nicht: Ein Objekt b der Klasse B kann in diesem Fall nicht in den Typ A umgewandelt werden!</p>\n\n<h3 id=\"vererbung_in_c__\">Vererbung in C++</h3>\n\n<p>Die von uns bereits definierte und benutzte Klasse <em>StockItem</em> erlaubt die Speicherung eines Namens und eines dazugeh&ouml;renden Wertes und ist zur Darstellung von Aktienkursen gedacht. Wer sich mit dieser Materie schon besch&auml;ftigt hat, der wei&szlig;, da&szlig; zu einer Aktie noch viele Informationen mehr gespeichert werden k&ouml;nnen. So gibt es neben dem (Tages- oder Wochen-)Schlusskurs (<em>Close</em>) noch Er&ouml;ffnungs- (<em>Open</em>), H&ouml;chst- (<em>High</em>) und Tiefstkurs (<em>Low</em>). Wir wollen daher nun StockItem um die M&ouml;glichkeit erweitern, zus&auml;tzlich auch den Er&ouml;ffnungskurs abfragen und setzen zu k&ouml;nnen.</p>\n\n<p>Diese Erweiterung soll jedoch nicht durch Ver&auml;ndern der existierenden Klasse StockItem erfolgen - diese Klasse wird bereits in vielen Softwareprojekten benutzt und eine &Auml;nderung ihrer Funktionalit&auml;t k&ouml;nnte unter Umst&auml;nden b&ouml;se Auswirkungen haben. Auch wollen wir das Rad nicht v&ouml;llig neu erfinden - vorhandener Code soll so weit wie m&ouml;glich wiederverwendet werden. Dies alles erreichen wir dadurch, da&szlig; wir eine neue Klasse <em>StockItemOC</em> definieren, die von der vorhandenen Klasse StockItem <em>abgeleitet</em> ist:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#ifndef StockItemOC_h</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#define StockItemOC_h 1</span>\n<span class=\"comment\">/*  3 */</span>\n<span class=\"comment\">/*  4 */</span>  <span class=\"keyword\">class</span> StockItemOC : <span class=\"keyword\">public</span> StockItem {\n<span class=\"comment\">/*  5 */</span>\n<span class=\"comment\">/*  6 */</span>  <span class=\"keyword\">public</span>:\n<span class=\"comment\">/*  7 */</span>      <span class=\"slashslashcomment\">// ctor</span>\n<span class=\"comment\">/*  8 */</span>      StockItemOC( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name = <span class=\"quotedstring\">&quot;&quot;</span>, <span class=\"keyword\">double</span> open = 0.0, <span class=\"keyword\">double</span> close = 0.0);\n<span class=\"comment\">/*  9 */</span>\n<span class=\"comment\">/* 10 */</span>      <span class=\"slashslashcomment\">// copy ctor</span>\n<span class=\"comment\">/* 11 */</span>      StockItemOC( <span class=\"keyword\">const</span> StockItemOC &amp;right);\n<span class=\"comment\">/* 12 */</span>      <span class=\"slashslashcomment\">// dtor</span>\n<span class=\"comment\">/* 13 */</span>      <span class=\"keyword\">virtual</span> ~StockItemOC();\n<span class=\"comment\">/* 14 */</span>      <span class=\"slashslashcomment\">// assignment operator</span>\n<span class=\"comment\">/* 15 */</span>      <span class=\"keyword\">const</span> StockItemOC&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItemOC &amp;right);\n<span class=\"comment\">/* 16 */</span>\n<span class=\"comment\">/* 17 */</span>      <span class=\"slashslashcomment\">// public member functions</span>\n<span class=\"comment\">/* 18 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setValue( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 19 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getValue() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 20 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setOpen( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 21 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getOpen() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 22 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> setClose( <span class=\"keyword\">double</span> val);\n<span class=\"comment\">/* 23 */</span>      <span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> getClose() <span class=\"keyword\">const</span>;\n<span class=\"comment\">/* 24 */</span>\n<span class=\"comment\">/* 25 */</span>  <span class=\"keyword\">private</span>:\n<span class=\"comment\">/* 26 */</span>      <span class=\"slashslashcomment\">// private member variables</span>\n<span class=\"comment\">/* 27 */</span>      <span class=\"keyword\">double</span> m_open;\n<span class=\"comment\">/* 28 */</span>      <span class=\"keyword\">double</span> m_close;\n<span class=\"comment\">/* 29 */</span>  };\n<span class=\"comment\">/* 30 */</span>\n<span class=\"comment\">/* 31 */</span>  <span class=\"preprocessor\">#endif</span>\n</pre>\n\n<p>Die einzige Erweiterung gegen&uuml;ber der uns bekannten Klassendefinition ist, da&szlig; zu Beginn in Zeile 4 die Basisklasse nach dem Doppelpunkt und dem Schl&uuml;sselwort <tt class=\"keyword\">public</tt> angegeben wird.</p>\n\n<p>Welche Auswirkung hat diese Vererbungsbeziehung nun auf das Verhalten unserer neuen Klasse StockItemOC? Schauen wir uns dazu das UML-Diagramm an: <img align=\"left\" alt=\"class StockItemOC\" height=\"291\" src=\"https://www.kompf.de/cplus/images/c++-part7.gif\" width=\"173\" /></p>\n\n<ul>\n\t<li>StockItemOC <em>erbt</em> die Methode getName() von StockItem. Diese Methode braucht also nicht noch einmal implementiert zu werden.</li>\n\t<li>StockItemOC <em>&uuml;berschreibt</em> die Methoden setValue() und getValue() von StockItem. Diese Methoden m&uuml;ssen anders implementiert sein, da StockItemOC ja zwei Kurswerte statt einem zur Auswahl hat.</li>\n\t<li>StockItemOC hat die <em>zus&auml;tzlichen</em> Methoden getOpen(), setOpen(), getClose() und setClose(), um die zus&auml;tzliche gew&uuml;nschte Funktionalit&auml;t abbilden zu k&ouml;nnen.</li>\n\t<li>StockItemOC <em>erbt</em> die Variablen m_name und m_value von StockItem. Da diese Variablen dort aber als <em>private</em> deklariert sind, haben die Methoden von StockItemOC keinen Zugriff auf diese Variable - au&szlig;er nat&uuml;rlich getName(), denn diese ist ja auch von StockItem geerbt.</li>\n\t<li>StockItemOC deklariert die <em>zus&auml;tzlichen</em> privaten Variablen m_open und m_close.</li>\n</ul>\n\n<h3 id=\"implementierung_der_abgeleiteten_klasse\">Implementierung der abgeleiteten Klasse</h3>\n\n<p>Zun&auml;chst wollen wir einen Blick auf die Implementierung der abgeleiteten Klasse in <b>StockItemOC.cpp</b> werfen:</p>\n\n<pre class=\"cplus\">\n<span class=\"comment\">/*  1 */</span>  <span class=\"preprocessor\">#include &lt;cstdlib&gt;</span>\n<span class=\"comment\">/*  2 */</span>  <span class=\"preprocessor\">#include &quot;StockItem.h&quot;</span>\n<span class=\"comment\">/*  3 */</span>  <span class=\"preprocessor\">#include &quot;StockItemOC.h&quot;</span>\n<span class=\"comment\">/*  4 */</span>\n<span class=\"comment\">/*  5 */</span>  StockItemOC::StockItemOC( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">double</span> open, <span class=\"keyword\">double</span> close)\n<span class=\"comment\">/*  6 */</span>   : StockItem(name), m_open(open), m_close(close)\n<span class=\"comment\">/*  7 */</span>  { }\n<span class=\"comment\">/*  8 */</span>\n<span class=\"comment\">/*  9 */</span>  StockItemOC::StockItemOC( <span class=\"keyword\">const</span> StockItemOC &amp;right)\n<span class=\"comment\">/* 10 */</span>   : StockItem(right), m_open(right.m_open), m_close(right.m_close)\n<span class=\"comment\">/* 11 */</span>  { }\n<span class=\"comment\">/* 12 */</span>\n<span class=\"comment\">/* 13 */</span>  StockItemOC::~StockItemOC()\n<span class=\"comment\">/* 14 */</span>  { }\n<span class=\"comment\">/* 15 */</span>\n<span class=\"comment\">/* 16 */</span>  <span class=\"keyword\">const</span> StockItemOC&amp; StockItemOC::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> StockItemOC &amp;right)\n<span class=\"comment\">/* 17 */</span>  {\n<span class=\"comment\">/* 18 */</span>      <span class=\"slashslashcomment\">// handle self assignment</span>\n<span class=\"comment\">/* 19 */</span>      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;right) {\n<span class=\"comment\">/* 20 */</span>          StockItem::<span class=\"keyword\">operator</span>=(right);\n<span class=\"comment\">/* 21 */</span>          m_open = right.m_open;\n<span class=\"comment\">/* 22 */</span>          m_close = right.m_close;\n<span class=\"comment\">/* 23 */</span>      }\n<span class=\"comment\">/* 24 */</span>\n<span class=\"comment\">/* 25 */</span>      <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;\n<span class=\"comment\">/* 26 */</span>  }\n<span class=\"comment\">/* 27 */</span>\n<span class=\"comment\">/* 28 */</span>  <span class=\"keyword\">void</span> StockItemOC::setValue( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 29 */</span>  {\n<span class=\"comment\">/* 30 */</span>      m_close = val;\n<span class=\"comment\">/* 31 */</span>  }\n<span class=\"comment\">/* 32 */</span>\n<span class=\"comment\">/* 33 */</span>  <span class=\"keyword\">double</span> StockItemOC::getValue() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 34 */</span>  {\n<span class=\"comment\">/* 35 */</span>      <span class=\"keyword\">return</span> m_close;\n<span class=\"comment\">/* 36 */</span>  }\n<span class=\"comment\">/* 37 */</span>\n<span class=\"comment\">/* 38 */</span>  <span class=\"keyword\">void</span> StockItemOC::setOpen( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 39 */</span>  {\n<span class=\"comment\">/* 40 */</span>      m_open = val;\n<span class=\"comment\">/* 41 */</span>  }\n<span class=\"comment\">/* 42 */</span>\n<span class=\"comment\">/* 43 */</span>  <span class=\"keyword\">double</span> StockItemOC::getOpen() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 44 */</span>  {\n<span class=\"comment\">/* 45 */</span>      <span class=\"keyword\">return</span> m_open;\n<span class=\"comment\">/* 46 */</span>  }\n<span class=\"comment\">/* 47 */</span>\n<span class=\"comment\">/* 48 */</span>  <span class=\"keyword\">void</span> StockItemOC::setClose( <span class=\"keyword\">double</span> val)\n<span class=\"comment\">/* 49 */</span>  {\n<span class=\"comment\">/* 50 */</span>      m_close = val;\n<span class=\"comment\">/* 51 */</span>  }\n<span class=\"comment\">/* 52 */</span>\n<span class=\"comment\">/* 53 */</span>  <span class=\"keyword\">double</span> StockItemOC::getClose() <span class=\"keyword\">const</span>\n<span class=\"comment\">/* 54 */</span>  {\n<span class=\"comment\">/* 55 */</span>      <span class=\"keyword\">return</span> m_close;\n<span class=\"comment\">/* 56 */</span>  }\n</pre>\n\n<p>Interessant ist hier zun&auml;chst wieder der Konstruktor (Zeilen 5 bis 7): Im Gegensatz zum Konstruktor von StockItem weiter oben erfolgt die Initialisierung der Variablen (m_open und m_close) hier nicht im Funktionsrumpf, sondern in einer <em>Initialisierungsliste</em>. Dies schafft vor allem Performancevorteile bei der Konstruktion der Objekte. Ferner m&uuml;ssen wir bedenken, da&szlig; die in der Basisklasse als privat deklarierten Variablen (wie m_name) hier nicht direkt angesprochen werden k&ouml;nnen. Um diese trotzdem korrekt zu initialisieren, wird der Konstruktor der Basisklasse in der Initialisierungsliste aufgerufen (Zeile 6).</p>\n\n<p>Gleiches gilt f&uuml;r den Copy Konstruktor (Zeilen 9 bis 11), der den Copy Konstruktor der Basisklasse in seiner Initialisierungsliste auff&uuml;hrt. Und auch der Assignment Operator muss den der Basisklasse explizit aufrufen (Zeile 20). Lediglich beim Destruktor (Zeilen 13 und 14) ist das Verhalten anders. Hier stellt die C++ Laufzeitumgebung sicher, da&szlig; alle Destruktoren voneinander abgeleiteter Klassen in der richtigen Reihenfolge aufgerufen werden. Da in StockItemOC kein dynamisch allozierter Speicher verwendet wird, braucht der Destruktor auch nichts weiter zu tun.</p>\n\n<p>Die restlichen Methoden von StockItemOC dienen dem Setzen und Auslesen der privaten Variablen und bieten nichts Neues.</p>\n\n<h3 id=\"verwendung_abgeleiteter_klassen\">Verwendung abgeleiteter Klassen</h3>\n\n<p>Die Verwendung von abgeleiteten Klassen soll nun anhand der Klasse StockItemOC in einem kleinen Testprogramm demonstriert werden.</p>\n\n<p>Am Anfang der Programmdatei m&uuml;ssen die ben&ouml;tigten Headerfiles inkludiert werden:</p>\n\n<pre class=\"cplus\">\n<span class=\"preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"preprocessor\">#include &lt;vector&gt;</span>\n<span class=\"preprocessor\">#include &lt;algorithm&gt;</span>\n<span class=\"preprocessor\">#include &lt;iterator&gt;</span>\n<span class=\"preprocessor\">#include &quot;StockItem.h&quot;</span>\n<span class=\"preprocessor\">#include &quot;StockItemOC.h&quot;</span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> main( <span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)\n{\n</pre>\n\n<p>Als erste &Uuml;bung werden wir zwei StockItem Objekte und ein StockItemOC Objekt statisch anlegen und diese dann zur Ausgabe einiger Werte benutzen:</p>\n\n<pre class=\"cplus\">\n    StockItem a( <span class=\"quotedstring\">&quot;BAY&quot;</span>, 34.9);\n    StockItem b( <span class=\"quotedstring\">&quot;BAS&quot;</span>);\n    StockItemOC c( <span class=\"quotedstring\">&quot;DTE&quot;</span>, 57.0, 59.4);\n\n    b.setValue( 24.2);\n\n    cout &lt;&lt; a.getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; a.getValue() &lt;&lt; endl;\n    cout &lt;&lt; b.getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; b.getValue() &lt;&lt; endl;\n    cout &lt;&lt; c.getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; c.getValue() &lt;&lt; <span class=\"quotedstring\">&quot; (&quot;</span>\n         &lt;&lt; c.getOpen() &lt;&lt; <span class=\"quotedstring\">&quot; -&gt; &quot;</span> &lt;&lt; c.getClose() &lt;&lt; <span class=\"quotedstring\">&quot;)\\n&quot;</span>;\n</pre>\n\n<p>Dies bietet auf den ersten Blick nichts neues. Beim zweiten Hinsehen erkennen wir, da&szlig; in der letzten Zeile die Methode getName() des Objektes c, welches vom Typ StockItemOC ist, aufgerufen wird. Die Klasse StockItemOC hat aber gar keine Methode getName() definiert! Mit dem neu erworbenen Wissen &uuml;ber Vererbung ist jedoch klar, was passiert: Es wird einfach die von der Klasse StockItem <em>geerbte</em> Methode verwendet!</p>\n\n<p>Interessant ist auch die Verwendung der Methode getValue(). Diese gibt es sowohl in StockItem als auch in StockItemOC. In diesem Beispiel ist jedoch relativ einfach zu verstehen, was passiert - sowohl f&uuml;r uns als auch f&uuml;r den C++-Compiler: In der letzten Zeile wird StockItemOC::getValue() aufgerufen, in den beiden Zeilen davor StockItem::getValue(). Das ist deshalb klar, weil der Typ der Objekte a, b und c bereits zur &Uuml;bersetzungszeit bekannt ist und der Compiler entscheiden kann, welchen Methodenaufruf er verwenden mu&szlig;. Dies wird auch als <em>statische</em> oder <em>fr&uuml;he Bindung</em> bezeichnet.</p>\n\n<p>Was passiert jedoch, wenn der Compiler beim &Uuml;bersetzen den genauen Typ des Objektes noch nicht kennt? Sehen wir uns die Fortsetzung des Programmes an:</p>\n\n<pre class=\"cplus\">\n    StockItem *astocks[3];\n    astocks[0] = &amp;a;\n    astocks[1] = &amp;b;\n    astocks[2] = &amp;c;      <span class=\"slashslashcomment\">// cast from StockItemOC* to StockItem*</span>\n    \n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = 0; i &lt; 3; ++i) {\n        cout &lt;&lt; astocks[i]-&gt;getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; astocks[i]-&gt;getValue() &lt;&lt; endl;\n    }\n</pre>\n\n<p>Beim Aufruf astocks[i]-&gt;getValue() mu&szlig; je nachdem, ob der in astocks stehende Pointer auf ein Objekt vom Typ StockItem (bei Index 0 und 1) oder vom Typ StockItemOC (Index 2) zeigt, eine andere Methode aufgerufen werden. Dies kann erst zur Laufzeit entschieden werden, man spricht dann von <em>dynamischer</em> oder <em>sp&auml;ter Bindung</em>. Wie kann nun aber das Laufzeitsystem entscheiden, welchen Typ das Objekt hat? Der Schl&uuml;ssel hierzu ist die sogenannte vtable, in der die spezifischen Funktionssignaturen f&uuml;r jedes Objekt abgelegt sind. Eine Funktionssignatur wird jedoch nur dann richtig in die vtable eingetragen, wenn die Funktionen in der Klassendefinitionen als <tt class=\"keyword\">virtual</tt> deklariert sind. Dies haben wir zum Gl&uuml;ck in unseren Definitionen schon getan, so da&szlig; das Programm wie erwartet arbeitet. Folgende Regel sollte man sich beim Umgang mit C++ jedoch verinnerlichen:</p>\n\n<p class=\"definition\">Deklariere alle Memberfunktionen - inklusive des Destruktors - als virtual, wenn Du die Absicht hast, Vererbungsmechanismen zu verwenden!</p>\n\n<p>Zum Schlu&szlig; noch eine fortgeschrittene Anwendung unserer Objekte. Statt in ein Array werden sie in einen STL-Vektor gepackt. Anschlie&szlig;end werden die Objekte nach ihrem Wert (getValue()) sortiert und ausgegeben. Das alles funktioniert auch dann, wenn der Vektor sowohl Objekte vom Typ StockItem* als auch StockItemOC* enth&auml;lt, weil wieder dynamische Bindung zum Einsatz kommt:</p>\n\n<pre class=\"cplus\">\n    <span class=\"slashslashcomment\">// get the stock items odered by price</span>\n    vector&lt;StockItem*&gt; stocks;\n\n    stocks.push_back(&amp;a);\n    stocks.push_back(&amp;b);\n    stocks.push_back(&amp;c); <span class=\"slashslashcomment\">// cast from StockItemOC* to StockItem*</span>\n\n    sort(stocks.begin(), stocks.end(), CompareStockPrice());\n\n    cout &lt;&lt; endl &lt;&lt; <span class=\"quotedstring\">&quot;stock items odered by price\\n&quot;</span>;\n    reverse_copy( stocks.begin(), stocks.end(), ostream_iterator&lt;StockItem*&gt;(cout));\n}\n</pre>\n\n<p>F&uuml;r die richtige Sortierung und die Ausgabe sind noch zwei Hilfsfunktionen notwendig, die vor main() in die Programmdatei eingef&uuml;gt werden k&ouml;nnen: CompareStockPrice ist ein sogenannter <em>functor</em>. Er wird als Parameter an den Sortieralgorithmus <em>sort</em> &uuml;bergeben und dient zum Vergleich zweier Objekte vom Typ StockItem. Die zweite Funktion ist der Ausgabeoperator f&uuml;r ein StockItem Objekt. Dieser wird im Alorithmus <em>reverse_copy</em> &uuml;ber den <em>ostream_iterator</em> verwendet.</p>\n\n<pre class=\"cplus\">\n<span class=\"slashslashcomment\">// compare two stock prices</span>\n<span class=\"keyword\">class</span> CompareStockPrice {\n<span class=\"keyword\">public</span>:\n    <span class=\"keyword\">int</span> <span class=\"keyword\">operator</span>()( <span class=\"keyword\">const</span> StockItem* s1, <span class=\"keyword\">const</span> StockItem* s2)\n    { <span class=\"keyword\">return</span> s1-&gt;getValue() &lt; s2-&gt;getValue(); }\n};\n\n<span class=\"slashslashcomment\">// operator&lt;&lt; for class StockItem</span>\n<span class=\"slashslashcomment\">// write name and value to output stream ost</span>\nostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;( ostream&amp; ost, <span class=\"keyword\">const</span> StockItem* item) {\n    ost &lt;&lt; item-&gt;getName() &lt;&lt; <span class=\"quotedstring\">&quot;: &quot;</span> &lt;&lt; item-&gt;getValue() &lt;&lt; endl;\n    <span class=\"keyword\">return</span> ost;\n}\n</pre>\n\n<p>Wie man sieht, reicht es v&ouml;llig aus, die Hilfsfunktionen f&uuml;r die Klasse StockItem zu implementieren. Es ist beim Aufruf der Funktion dann egal, ob der aktuelle Parameter auf ein Objekt vom Typ StockItem oder StockItemOC zeigt. Dies ist ein Resultat (und Vorteil) der von uns implementierten Vererbungshierarchie.</p>\n"
          ]
        }
      ]
    },
    {
      "title": "Grundlagen der Betriebsysteme",
      "content": [
        {
          "tag_line": "Kapitel 1 - Einleitung Betriebsysteme",
          "details": [
            "<h1 id=\"anchor0\">Kapitel 1 - Einleitung Betriebsysteme</h1>\n\n<h2>Einleitung - BS Definition</h2>\n\n<p>Ein Betriebsystem stellt <strong>Dienste</strong> und <strong>Infrastrukturen</strong> (Metasteuerungen) bereit. Daten oder Virtuelle Maschinen sind kein Teil des Betriebssystems sondern des Dienstleistungssystems. Die Metasteuerungen sind entscheidend beim Entwurf. (z.B. in Bezug auf Uni- oder Mehrbenutzersystem)</p>\n\n<p>Grob gesagt ist ein Betriebssystem eine erweiterte Maschine (Top-Down-Sicht), um durch Abstraktionen eine f&uuml;r den Menschen (Programmierer) &uuml;berschaubare Form als Programmiergrundlage zu bieten.</p>\n\n<p><img alt=\"Organisation eines Betriebssystem\" src=\"http://www.kreissl.info/pics/images/bs_08.gif\" /></p>\n\n<h3>Eine Definition f&uuml;r Betriebsysteme</h3>\n\n<p>Das Betriebssystem ist die <strong>Gesamtheit der Programme</strong> eines Rechensystems, welche die Betriebssteuerung erledigen und die Benutzerauftr&auml;gen eine zug&auml;ngliche Umgebung bereitstellen. Betriebsmittel sind Komponenten sowohl der Hardware als auch der Software (System und Anwendersoftware), wie z.B. Prozessor, Speicher, Ein-Ausgabe-Ger&auml;te, Dateien, Programme etc.</p>\n\n<p>Das Betriebssystem erm&ouml;glicht es z.B. dem Anwender, Programme auf unterschiedlicher Hardware laufen zu lassen. D.h. das Betriebssystem bietet dem Anwender eine <strong>virtuelle Maschine</strong>, welche die reale Hardware &quot;unsichtbar&quot; f&uuml;r den Programmierer macht.</p>\n\n<div class=\"well\">\n<h1 id=\"anchor1\">Definition Betriebssysteme</h1>\nAbstrahiert den Rechner auf eine f&uuml;r Menschen leichter durchschaubare virtuelle Maschine, steuert und koordiniert Prozessabl&auml;ufe und verwaltet die Ressourcen</div>\n\n<h2>Wie sieht das Ebenen- oder Schichtenmodell eines Rechners aus?</h2>\n\n<ol>\n\t<li>Gatter Ebene</li>\n\t<li>Mikroprogrammebene</li>\n\t<li>konventionelle Maschinenebene</li>\n\t<li>Betriebssystemebene API</li>\n\t<li>Assemblerebene</li>\n\t<li>Anwendungsebene</li>\n</ol>\n\n<h3>Worin Unterscheiden sich Betriebssysteme?</h3>\n\n<ul>\n\t<li>universal oder dezidiert (Multi-Task / Single-Task)</li>\n\t<li>eine oder mehrere Sitzungen (Windows &lt; XP, Linux)</li>\n\t<li>Kommunikation mit der Umwelt (Batch, interaktiv oder in Echtzeit)</li>\n</ul>\n\n<h3>Die dreei Welten des Betriebsystems</h3>\n\n<ul>\n\t<li>Betriebssystem selbst</li>\n\t<li>Komplexe Werkzeuge, wie aufgesetzte Dienste oder Virtuelle Maschinen</li>\n\t<li>Programmiersysteme zur Entwicklung von Erweiterungen</li>\n</ul>\n\n<h3>Aufgaben eines Betriebsystems</h3>\n\n<ol>\n\t<li>Abstraktion der Hardware, d.h. Schlie&szlig;en der so genannten &#39;Semantischen L&uuml;cke&#39; zwischen Mikroprogrammebene und der Anwendungsebene</li>\n\t<li>Betriebsmittelverwaltung</li>\n\t<li>Steuerung von Peripherieger&auml;ten (I/O, Festplatten...)</li>\n\t<li>Steuerung des Betriebsablaufs durch Prozessverwaltung und -Kommunikation und Organisation des Mehrprogrammbetriebes</li>\n\t<li>Protokollierung, Schutz und Sicherheit</li>\n\t<li>Behandlung von Ausnahmesituationen, wie Page Faults, Division by Zero u.s.w.</li>\n\t<li>Bereitstellung einer Kommandosprache</li>\n\t<li>Unterst&uuml;tzung von Administrationsaufgaben (Datensicherung, Systemkonfigurierung, Benutzerrechte)</li>\n</ol>\n\n<h2>Was ist ein Modell?</h2>\n\n<p>Ein Modell eines Rechnersystems ist eine <strong>Abbildung eines realen Systems</strong> unter Abstrahierung bestimmter Kriterien, in dem eine formale Beschreibung durch eine Theorie in Gesetzen formuliert werden kann.</p>\n\n<h3>Welche drei Punkte sind bei der Realisierung eines BS grundlegend?</h3>\n\n<h4>Prozessor-Modes (Betriebszust&auml;nde)</h4>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Supervisor Mode<br />\n\t\t\t(Kernel Mode)</td>\n\t\t\t<td>Ist ein privilegierter Modus f&uuml;r Betriebssystemfunktionen im Kern des Systems, welches Sicherheit des Systems erh&ouml;ht, da diese gesch&uuml;tzt von Andwenderprogrammen laufen.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>User Mode<br />\n\t\t\t(Anwendungsmodus)</td>\n\t\t\t<td>Die Betriebsart wird &uuml;ber ein &quot;Mode&quot;-Bit angezeigt. Privilegierte Funktionen (wie I/O Funktionen) sind aber nur im Kernelmode ausf&uuml;hrbar. Diese k&ouml;nnen &uuml;ber bestimmte Methoden gerufen werden.</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h4>Kernel</h4>\n\n<p>Im Kern laufen die Systemkritischen Funktionen, wie z.B. I/O-Aktionen ab. Der Kern muss korrekt, sicher und gesch&uuml;tzt vor Anwendungen sein.</p>\n\n<h4>Methoden des Aufrufs von Betriebssystemsdiensten</h4>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>System Calls</td>\n\t\t\t<td>Durch <strong>System Calls</strong> k&ouml;nnen BS-Funktionen gerufen werden. Die Schnittstelle zwischen Usermode und Kernel sind sogenannte Traps (Einstiegspunkte). Ger&auml;te k&ouml;nnen Traps nicht nutzen, sondern k&ouml;nnen die BS-Dienste durch spezielle Interruptsmechanismen erreichen.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Nachrichtenversand</td>\n\t\t\t<td>&Uuml;ber eine <strong>Send/Receive-Schnittstelle</strong> k&ouml;nnen sich User-Mode und Kernel-Mode Nachrichten zuschicken.</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Sinn und zweck ist eine Entkopplung von System und Anwendung! Windows NT bietet eine API mit mehr als 10.000 Systemaufrufen, Unix dagegen ca. 300.</p>\n\n<p><img alt=\"System-Call am Beispiel Windows NT\" src=\"http://www.kreissl.info/pics/images/bs_09.gif\" /></p>\n"
          ]
        },
        {
          "tag_line": "Kapitel 2 - Modelle",
          "details": [
            "<h1 id=\"anchor2\">Kapitel 2 - Modelle</h1>\n\n<h2>Vor- und Nachteile von Schalen- und Modulmodellen</h2>\n\n<h3>Das Schalenmodell</h3>\n\n<ul>\n\t<li>Relationen der einzelnen Schalen sind zur Umwelt nicht sichtbar</li>\n\t<li>System ist aber gut strukturiert</li>\n\t<li>Innere Schalen sind sehr gut abgeschirmt von den &Auml;u&szlig;eren</li>\n</ul>\n\n<h3>Das Modulmodell:</h3>\n\n<ul>\n\t<li>Das Modell wird in Modulen durch Programmcode beschrieben</li>\n\t<li>die Relationen werden daher extrem komplex (quatradisch)</li>\n\t<li>Daher ist es nur bei kleinen Modellen umsetzbar</li>\n</ul>\n\n<h2>Aufbau des hierarchischen Schichtenmodells</h2>\n\n<p>Jede Schicht stellt Betriebsmittel und Dienste f&uuml;r den Zugriff auf die jeweilige &uuml;bergeordnete Schicht bereit. Somit kann jede Schicht auch die Betriebsmittel und Dienste darunterliegender Schichten nutzen. Eine Schicht steuert die unmittelbare Schicht &uuml;ber ihr. (<strong>Steuerungshierarchie</strong>)</p>\n\n<h3>Bestandteile</h3>\n\n<ul>\n\t<li>Schichten</li>\n\t<li>Iterative Ordnungsrelation der Schichten (Dienste, Steuerungen bzw. Instanzen)</li>\n\t<li>Betriebsmittel</li>\n\t<li>Funktionen zum Erzeugen von Betriebsmitteln und Steuerungen</li>\n</ul>\n\n<h3>Welche Vorteile hat das hierarchisch Schichtenmodell?</h3>\n\n<ul>\n\t<li>obwohl modularisiert, ist die Zahl der Relationen gering</li>\n\t<li>Kommunikation mit der Umwelt ist m&ouml;glich</li>\n\t<li>Es bietet eine Infrastruktur f&uuml;r Instanzen (Steuerung, BM-Transformationen)</li>\n</ul>\n\n<h2>Was ist ein Betriebsmittel?</h2>\n\n<p>Ein Betriebsmittel ist eine abstrakte Ressource, welche &uuml;ber eine Adresse und einen Wert verf&uuml;gt. Sie wird definiert &uuml;ber</p>\n\n<ul>\n\t<li>ID (eindeutiger Identifikator)</li>\n\t<li>Adressbereich (f&uuml;r alle m&ouml;glichen Adressen des Betriebsmittels)</li>\n\t<li>Wertebereicht (aller m&ouml;glichen Werte f&uuml;r einen Wert des BM)</li>\n\t<li>Funktion (verkn&uuml;pft die abstrakten Elemente miteinander)</li>\n</ul>\n\n<p><em>Der Zustand eines Betriebsmittels ergibt sich aus Wert x Adresse.</em></p>\n\n<h3>Welche Klassen von Betriebsmitteln gibt es?</h3>\n\n<ul>\n\t<li>Entziehbarkeit (entziehbar wie Prozessor oder nicht wie Dateideskriptor)</li>\n\t<li>Zuteilbarkeit (gleichzeitig wie Speicher oder exklusiv wie Prozessor oder Drucker)</li>\n\t<li>Wiederverwendbarkeit (einmalig Nutzbar wie Interrupt oder mehrfach wie Prozessor oder Speicher)</li>\n\t<li>Hardware / Software (logisches oder physikalisches Betriebsmittel)</li>\n</ul>\n\n<h3>Vorgehensweise beim Erstellen eines Betriebsmittels</h3>\n\n<ol>\n\t<li>ID bestimmen</li>\n\t<li>abstrakte Elemente bestimmen, welche einen Wert und eine Adresse besitzen</li>\n\t<li>Wert und Adresse festlegen</li>\n\t<li>Funktionen definieren, welche Zugriff auf alle Elemente erm&ouml;glichen</li>\n</ol>\n\n<h3>Die Betriebsmittelerstellung am Beispiel des Hauptspeichers</h3>\n\n<ol>\n\t<li>Eine ID ist hier nicht sinnvoll, da ein von-Neumann Rechner nur einen Hauptspeicher hat.</li>\n\t<li>die abstrakten Elemente sind die ansprechbaren Speicherzellen mit Adresse und Wert.</li>\n\t<li>Der Wertebereich betr&auml;gt 0 bist 255 bei einem Byte-Orientierten Speicher</li>\n\t<li>Funktionen sind Read und Write eines Elementes zum Speicher</li>\n</ol>\n\n<h2>Definition Instanz</h2>\n\n<p>Eine Instanz ist ein Tupel aus id (Betriebsmittel) und einem Aktivit&auml;tstoken, welches die einzelnen Dienste ruft. Zwischen Betriebsmitteln untereinander und zwischen Instanzen untereinander bestehen Relationen.</p>\n\n<h3>Klassen von Instanzen</h3>\n\n<ul>\n\t<li>Applikationen</li>\n\t<li>Betriebsmittel-Transformatoren</li>\n\t<li>Metasteuerungen wie PUM</li>\n</ul>\n\n<h3>Wie k&ouml;nnen Relationen zwischen Instanzen technisch hergestellt werden?</h3>\n\n<p>Protokolle und Schnittstellen verbinden sich Instanzen. Dabei treten beide immer zusammen auf. Eine Schnittstelle kennzeichnet das statische Verhalten einer Relation und ein Protokoll das dynamische, d.h. die Semantik der Relation.</p>\n\n<p>Als Beispiel nehmen wir einen Spooler. Hier ist die Schnittstelle ein Betriebsmittel (Speicherbuffer) und das Protokoll (Verhalten) ist als Dienst implementiert.</p>\n\n<p><em>Spool = Simultanously Periphal Output On Line</em></p>\n\n<p>Es gibt datenorientierte und steuerungsorientierte Schnittstellen. Datenorientierte Schnittstellen arbeiten ohne Synchronisation und verbrauchen viel Ressourcen (Busy Waiting). Steurerungsorientierte Schnittstellen sind z.B. Systemcalls und Interrupts.</p>\n"
          ]
        },
        {
          "tag_line": "Kapitel 3 - Aktivitäten ",
          "details": [
            "<h1 id=\"anchor3\">Kapitel 3 - Aktivit&auml;ten</h1>\n\n<h2>Was ist ein Aktivit&auml;tstoken?</h2>\n\n<ul>\n\t<li>Ist sehr abstrakt zu sehen</li>\n\t<li>Ein Aktivit&auml;tstoken haucht dem Programm erst &quot;Leben&quot; ein</li>\n\t<li>Beschreibt ein aktiven oder wartenden Prozess</li>\n\t<li>Es muss eine Art virtuellen Programmcounter im eigenen virtuellen Steuerwerk des Prozesses geben</li>\n</ul>\n\n<h2>Definition Multitasking</h2>\n\n<p>Ist die F&auml;higkeit Prozesse parallel laufen zu lassen. Bei Einprozessormaschinen (kooperativ oder preemtiv) wird die Leistungsf&auml;higkeit damit optimal ausgenutzt. Die verschiedenen Betriebsmittel k&ouml;nnen von mehreren Prozessen mehrfach bzw. parallel genutzt werden.</p>\n\n<h2>Arten von Aktivit&auml;ten</h2>\n\n<table class=\"table table-striped\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>&nbsp;</th>\n\t\t\t<th>Token</th>\n\t\t\t<th>Verteilung</th>\n\t\t\t<th>Protokoll</th>\n\t\t\t<th>BM-Zuteilung</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Prozedur</td>\n\t\t\t<td>Eins f&uuml;r alle</td>\n\t\t\t<td>-</td>\n\t\t\t<td>Call Return</td>\n\t\t\t<td>Exclusiv</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Coroutine</td>\n\t\t\t<td>Eins f&uuml;r alle</td>\n\t\t\t<td>-</td>\n\t\t\t<td>Resume, aber dynamischer Eintrittspunkt (kooperatives Multitasking)</td>\n\t\t\t<td>Exclusiv</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Prozess</td>\n\t\t\t<td>Pro Prozess</td>\n\t\t\t<td>Pro Prozess</td>\n\t\t\t<td>Keine &Uuml;bergabe, da Prozess Token beh&auml;lt</td>\n\t\t\t<td>Exclusiv</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Thread</td>\n\t\t\t<td>Pro Prozess</td>\n\t\t\t<td>Pro Thread Eins</td>\n\t\t\t<td>Keine &Uuml;bergabe, da Prozess Token beh&auml;lt</td>\n\t\t\t<td>Threads sind in Prozessen gruppiert und teilen sich dort die Betriebsmittel</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2>Welche Betriebsmittel ben&ouml;tigt eine Aktivit&auml;t mindestens?</h2>\n\n<ul>\n\t<li>Programmcode</li>\n\t<li>Hauptspeicher</li>\n\t<li>Steuerwerk</li>\n</ul>\n\n<h3>Wodurch wird ein Prozess beschrieben?</h3>\n\n<ul>\n\t<li>ein im System eindeutiger Identifikator (PID)</li>\n\t<li>Liste mit Betriebsmittel-Forderungen</li>\n\t<li>Liste mit zugeteilten Betriebsmitteln</li>\n\t<li>Ein Folge der bisherigen Anweisungen</li>\n\t<li>Die Anfangswertbelegungen der zugeteilten Betriebsmittel</li>\n</ul>\n\n<h3>Welche Probleme treten mit Prozessen auf?</h3>\n\n<ul>\n\t<li>Determiniertheit (Durch Mehrfachverwendung von Betriebsmitteln ist diese so nicht mehr gegeben und Synchronisation wird notwendig)</li>\n\t<li>Mutual Exclusion</li>\n\t<li>Synchronisation (Abstimmung zwischen Threads)</li>\n\t<li>Kommunikation (Synchronisation und Austausch von Daten zwischen Prozessen)</li>\n\t<li>Lebendigkeit</li>\n</ul>\n\n<h3>Welche Zust&auml;nde kann ein Prozess einnehmen?</h3>\n\n<ul>\n\t<li>nicht existent (Prozess noch nicht definiert)</li>\n\t<li>bereit (besitzt alle angeforderten Betriebsmittel au&szlig;er den Prozessor)</li>\n\t<li>aktiv (besitzt mindestens die angeforderten Betriebsmittel)</li>\n\t<li>wartend (wartet noch auf noch nicht zugeteilte Betriebsmittel)</li>\n</ul>\n\n<p><img alt=\"Prozess\" src=\"http://www.kreissl.info/pics/images/bs_01.gif\" /></p>\n\n<h2>Wie wird ein Prozess im Unix erstellt?</h2>\n\n<ul>\n\t<li>mit Systemaufruf fork() wird ein komplettes Speicherabbild eines schon bestehenden Prozesses erzeugt (bei NT wird Prozess mit einem Initialzustand erstellt)</li>\n\t<li>Deshalb erben neue Prozesse eventuelle Variablen des Vaterprozesses</li>\n</ul>\n\n<p>Deshalb terminiert folgende Schleife nicht unter NT aber unter Unix:</p>\n\n<div>\n<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_503739\">\n<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td class=\"gutter\">\n\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\t\t\t</td>\n\t\t\t<td class=\"code\">\n\t\t\t<div class=\"container\">\n\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">For ( i=1; i&lt;3; i++) fork();</code></div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n</div>\n\n<h3>Einige Unix-Systembefehle zur Prozesserzeugung:</h3>\n\n<ul>\n\t<li>fork(), vfork() zum Prozesserstellen mit Speicherabbild des Vaters</li>\n\t<li>clone() erstellt einen Prozess der der den Speicher und Deskriptoren mit Vater teilt</li>\n\t<li>execl(), execv(), execle(), execlp(), execvp() zum Kopieren eines Programms in den Speicher</li>\n\t<li>wait(), waitpid() zum Warten auf Ende des Sohnprozesses</li>\n\t<li>exit() zum Beenden eines Prozesses</li>\n</ul>\n\n<p>http://unixhelp.ed.ac.uk/CGI/man-cgi</p>\n\n<h3>Ein Beispielcode f&uuml;r eine Einfache Unix-Shell</h3>\n\n<div>\n<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_735766\">\n<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td class=\"gutter\">\n\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\n\t\t\t<div class=\"line number7 index6 alt2\">7</div>\n\n\t\t\t<div class=\"line number8 index7 alt1\">8</div>\n\n\t\t\t<div class=\"line number9 index8 alt2\">9</div>\n\n\t\t\t<div class=\"line number10 index9 alt1\">10</div>\n\n\t\t\t<div class=\"line number11 index10 alt2\">11</div>\n\n\t\t\t<div class=\"line number12 index11 alt1\">12</div>\n\n\t\t\t<div class=\"line number13 index12 alt2\">13</div>\n\n\t\t\t<div class=\"line number14 index13 alt1\">14</div>\n\n\t\t\t<div class=\"line number15 index14 alt2\">15</div>\n\n\t\t\t<div class=\"line number16 index15 alt1\">16</div>\n\n\t\t\t<div class=\"line number17 index16 alt2\">17</div>\n\n\t\t\t<div class=\"line number18 index17 alt1\">18</div>\n\n\t\t\t<div class=\"line number19 index18 alt2\">19</div>\n\n\t\t\t<div class=\"line number20 index19 alt1\">20</div>\n\n\t\t\t<div class=\"line number21 index20 alt2\">21</div>\n\n\t\t\t<div class=\"line number22 index21 alt1\">22</div>\n\n\t\t\t<div class=\"line number23 index22 alt2\">23</div>\n\n\t\t\t<div class=\"line number24 index23 alt1\">24</div>\n\n\t\t\t<div class=\"line number25 index24 alt2\">25</div>\n\n\t\t\t<div class=\"line number26 index25 alt1\">26</div>\n\n\t\t\t<div class=\"line number27 index26 alt2\">27</div>\n\n\t\t\t<div class=\"line number28 index27 alt1\">28</div>\n\n\t\t\t<div class=\"line number29 index28 alt2\">29</div>\n\n\t\t\t<div class=\"line number30 index29 alt1\">30</div>\n\n\t\t\t<div class=\"line number31 index30 alt2\">31</div>\n\n\t\t\t<div class=\"line number32 index31 alt1\">32</div>\n\n\t\t\t<div class=\"line number33 index32 alt2\">33</div>\n\n\t\t\t<div class=\"line number34 index33 alt1\">34</div>\n\n\t\t\t<div class=\"line number35 index34 alt2\">35</div>\n\n\t\t\t<div class=\"line number36 index35 alt1\">36</div>\n\n\t\t\t<div class=\"line number37 index36 alt2\">37</div>\n\n\t\t\t<div class=\"line number38 index37 alt1\">38</div>\n\n\t\t\t<div class=\"line number39 index38 alt2\">39</div>\n\n\t\t\t<div class=\"line number40 index39 alt1\">40</div>\n\n\t\t\t<div class=\"line number41 index40 alt2\">41</div>\n\n\t\t\t<div class=\"line number42 index41 alt1\">42</div>\n\t\t\t</td>\n\t\t\t<td class=\"code\">\n\t\t\t<div class=\"container\">\n\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp preprocessor\">#include sys/types.h</code></div>\n\n\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp preprocessor\">#include sys/wait.h</code></div>\n\n\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp preprocessor\">#include unistd.h</code></div>\n\n\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp preprocessor\">#include stdlib.h</code></div>\n\n\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp preprocessor\">#include stdio.h</code></div>\n\n\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp preprocessor\">#include string.h</code></div>\n\n\t\t\t<div class=\"line number7 index6 alt2\">&nbsp;</div>\n\n\t\t\t<div class=\"line number8 index7 alt1\"><code class=\"csharp keyword\">using</code> <code class=\"csharp keyword\">namespace</code> <code class=\"csharp plain\">std;</code></div>\n\n\t\t\t<div class=\"line number9 index8 alt2\">&nbsp;</div>\n\n\t\t\t<div class=\"line number10 index9 alt1\"><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">main(</code><code class=\"csharp keyword\">void</code><code class=\"csharp plain\">){</code></div>\n\n\t\t\t<div class=\"line number11 index10 alt2\">&nbsp;</div>\n\n\t\t\t<div class=\"line number12 index11 alt1\"><code class=\"csharp plain\">pid_t pid; </code><code class=\"csharp comments\">//f&uuml;r PID des Sohnes </code></div>\n\n\t\t\t<div class=\"line number13 index12 alt2\"><code class=\"csharp keyword\">char</code> <code class=\"csharp plain\">str1[1000]; </code><code class=\"csharp comments\">//Befehlsbuffer</code></div>\n\n\t\t\t<div class=\"line number14 index13 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number15 index14 alt2\"><code class=\"csharp keyword\">while</code><code class=\"csharp plain\">(1){</code></div>\n\n\t\t\t<div class=\"line number16 index15 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number17 index16 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">printf(</code><code class=\"csharp string\">&quot;\\nDiggs mini bash. (PID=%d)\\n\\n&quot;</code><code class=\"csharp plain\">,getpid());</code></div>\n\n\t\t\t<div class=\"line number18 index17 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">printf(</code><code class=\"csharp string\">&quot;&gt; &quot;</code><code class=\"csharp plain\">);</code></div>\n\n\t\t\t<div class=\"line number19 index18 alt2\">&nbsp;</div>\n\n\t\t\t<div class=\"line number20 index19 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">scanf(</code><code class=\"csharp string\">&quot;%s&quot;</code><code class=\"csharp plain\">,str1); </code><code class=\"csharp comments\">//Befehl lesen</code></div>\n\n\t\t\t<div class=\"line number21 index20 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">if</code> <code class=\"csharp plain\">(strcmp(str1,</code><code class=\"csharp string\">&quot;exit&quot;</code><code class=\"csharp plain\">)==0) </code><code class=\"csharp keyword\">break</code><code class=\"csharp plain\">; </code><code class=\"csharp comments\">//exit beendet</code></div>\n\n\t\t\t<div class=\"line number22 index21 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number23 index22 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">if</code> <code class=\"csharp plain\">((pid=fork())&lt;0) </code><code class=\"csharp comments\">//Prozess kopieren</code></div>\n\n\t\t\t<div class=\"line number24 index23 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number25 index24 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">printf(</code><code class=\"csharp string\">&quot;EXEC Operation failed!\\n\\n&quot;</code><code class=\"csharp plain\">);</code></div>\n\n\t\t\t<div class=\"line number26 index25 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">exit(0);</code></div>\n\n\t\t\t<div class=\"line number27 index26 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">}</code></div>\n\n\t\t\t<div class=\"line number28 index27 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number29 index28 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">if</code> <code class=\"csharp plain\">(pid==0) </code><code class=\"csharp comments\">//im Sohnprozess exec</code></div>\n\n\t\t\t<div class=\"line number30 index29 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>\n\n\t\t\t<div class=\"line number31 index30 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">char</code> <code class=\"csharp plain\">*cmd=strtok(str1,</code><code class=\"csharp string\">&quot; &quot;</code><code class=\"csharp plain\">);</code></div>\n\n\t\t\t<div class=\"line number32 index31 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">execlp (cmd,cmd,0); </code><code class=\"csharp comments\">//Speicher &uuml;berschreiben</code></div>\n\n\t\t\t<div class=\"line number33 index32 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div>\n\n\t\t\t<div class=\"line number34 index33 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">printf(</code><code class=\"csharp string\">&quot;command not found!\\n&quot;</code><code class=\"csharp plain\">);</code></div>\n\n\t\t\t<div class=\"line number35 index34 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">exit(0); </code><code class=\"csharp comments\">//manuell terminieren</code></div>\n\n\t\t\t<div class=\"line number36 index35 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">} </code><code class=\"csharp comments\">//Vaterprozess muss warten</code></div>\n\n\t\t\t<div class=\"line number37 index36 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">else</code></div>\n\n\t\t\t<div class=\"line number38 index37 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">waitpid(pid,0,0); </code></div>\n\n\t\t\t<div class=\"line number39 index38 alt2\"><code class=\"csharp plain\">}</code></div>\n\n\t\t\t<div class=\"line number40 index39 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number41 index40 alt2\"><code class=\"csharp keyword\">return</code> <code class=\"csharp plain\">0; </code></div>\n\n\t\t\t<div class=\"line number42 index41 alt1\"><code class=\"csharp plain\">}</code></div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n</div>\n\n<p>Der Vaterprozess liest einen Befehl (hier nur ohne Parameter) und startet danach einen Sohnprozess mit fork() in welchem mit dem Befehl exec das aufzurufende Programm in den Speicher kopiert wird. Schl&auml;gt exec fehl muss mit exit der Sohnprozess manuell beendet werden, da dieser sonst nicht terminieren w&uuml;rde.</p>\n\n<p>Am Besten einfach ausprobieren. Den Quellcode eingeben oder kopieren und mit dem gcc compilieren:</p>\n\n<div>\n<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_160524\">\n<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td class=\"gutter\">\n\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\t\t\t</td>\n\t\t\t<td class=\"code\">\n\t\t\t<div class=\"container\">\n\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">gcc minishell.cc -o minishell </code></div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n</div>\n\n<p><em>Aufruf in einer bash via ./minishell</em></p>\n\n<h2>Wie werden Prozesse verwaltet?</h2>\n\n<p>Das Betriebssystem verwaltet alle Prozesse. Die Prozesse besitzen einen PCB (<strong>Process Controll Block</strong>, in welchem alle zum Prozess geh&ouml;rigen Informationen gespeichert werden. Das Betriebssystem hat nun die Aufgabe alle n Prozesse auf einen oder mehr Prozessoren abzubilden.</p>\n\n<h2>Timesharing</h2>\n\n<p>Timesharing ist die <strong>gemeinsame Benutzung des Betriebsmittels Prozessor</strong> von mehreren Prozessen. Dabei ermittelt ein Scheduler den n&auml;chst auszuf&uuml;hrenden Prozess. Ein Task-Switch bzw. Context-Switch bezeichnet eine solche Umschaltung zwischen den Prozessen.</p>\n\n<h2>Virtuelle Ger&auml;te bzw. Betriebsmittel?</h2>\n\n<p>Virtuelle Ger&auml;te stellen durch das Betriebssystem <strong>simulierte Ger&auml;te</strong> mit idealisierten Eigenschaften dar. Bewerkstelligt wird damit die Abstraktion von den Eigenschaften realer Ger&auml;te mit dem Ziel der Ger&auml;teunabh&auml;ngigkeit. In der Regel stellen virtuelle Ger&auml;te jedem Proze&szlig; eine synchrone Operation zur Verf&uuml;gung. Dabei kann es erheblich mehr virtuelle als reale Ger&auml;te geben. Beispiele f&uuml;r virtuelle Betriebsmittel sind Druckerspooler oder Dateien.</p>\n"
          ]
        },
        {
          "tag_line": "Kapitel 4 - Kritischer Abschnitt",
          "details": [
            "<h1 id=\"anchor4\">Kapitel 4 - Kritischer Abschnitt</h1>\n\n<h2>Definition</h2>\n\n<p>Ein Kritischer Abschnitt ist ein zeitlicher Bereich, in welchem mindestens zwei Prozesse auf das gleiche Betriebsmittel zugreifen und mindestens eines davon schreibt. (Zeitkritischer Ablauf)</p>\n\n<h3>Der Druckerspooler als Beispiel einer Critical Section</h3>\n\n<ol>\n\t<li>in Spooler ist der Platz 4 frei</li>\n\t<li>Prozess A will drucken und liest die Platznummer</li>\n\t<li>PUM aktiviert Prozess B, welcher ebenfalls diese Platznummer liest</li>\n\t<li>Prozess B schreibt den Auftrag nach Platz 4</li>\n\t<li>PUM schaltet zu A zur&uuml;ck und A &uuml;berschreibt nun den Druckauftrag von B!</li>\n</ol>\n\n<p><em><strong>Deshalb notwendig:</strong> Wechselseitiger Ausschluss!</em></p>\n\n<h2>Warum werden keine Interrupt Unterbrechungen zur Synchronisation verwendet?</h2>\n\n<p>Ein Proze&szlig; der auf gemeinsame Daten und Ressourcen zugreift, kann nicht einfach alle Interrupts abschalten. Dies w&uuml;rde zu keinem optimalen Scheduling f&uuml;hren, weil dann jeder Proze&szlig; solange die Kontrolle behalten darf wie er will. D.h. die wartenden Prozesse sind auf die Kooperation des gerade laufenden Prozesses angewiesen (kooperatives Multitasking wie Win 3.11)</p>\n\n<h2>Was ist wechselseitiger Ausschluss?</h2>\n\n<p>Es muss gew&auml;hrleistet werden, da&szlig; niemals sich mehr als ein Prozess in einem kritischen Abschnitt befinden darf. Die Anwendung einer einfachen Sperrvariable ist hier nicht m&ouml;glich, da der Zugriff und das Setzen dieser, selbst einen kritischen Abschnitt darstellt. Es m&uuml;ssen Algorithmen gefunden werden, welche die Funktionalit&auml;t gefahrlos implementieren.</p>\n\n<h3>Welche Anforderungen muss eine Steuerung f&uuml;r kritische Abschnitte erf&uuml;llen?</h3>\n\n<ol>\n\t<li>exklusive Nutzung durch verschiedene Teilprozesse &uuml;ber mutual exclusion</li>\n\t<li>Ein Prozess darf einen anderen nur behindern, wenn beide im kritischen Abschnitt</li>\n\t<li>Der Eintritt in einen kritischen Abschnitt darf nicht lang dauern</li>\n\t<li>Alle Prozesse m&uuml;ssen in endlicher Zeit ihre Betriebsmittel zugewiesen bekommen</li>\n\t<li>globale Unabh&auml;ngigkeit von allgemeinen Fortschreiten der Prozesse</li>\n</ol>\n\n<h2>Arten dezentraler Steuerungen (aktives Warten)</h2>\n\n<ul>\n\t<li>Test and Set Lock</li>\n\t<li>Ping-Pong (Striktes Alternieren)</li>\n\t<li>Decker Algorithmus</li>\n\t<li>Peterson Algorithmus</li>\n</ul>\n\n<h3>Striktes Alternieren (Ping Pong)</h3>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Prozess A</td>\n\t\t\t<td>Prozess B</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>\n\t\t\t<div>\n\t\t\t<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_496985\">\n\t\t\t<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n\t\t\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"gutter\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\n\t\t\t\t\t\t<div class=\"line number7 index6 alt2\">7</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"code\">\n\t\t\t\t\t\t<div class=\"container\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">While (1)</code></div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">while</code> <code class=\"csharp plain\">(turn!=FALSE);</code></div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">criticalsection();</code></div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">turn = TRUE;</code></div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">notcriticalstuff();</code></div>\n\n\t\t\t\t\t\t<div class=\"line number7 index6 alt2\"><code class=\"csharp plain\">}</code></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t<div>\n\t\t\t<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_829810\">\n\t\t\t<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n\t\t\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"gutter\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\n\t\t\t\t\t\t<div class=\"line number7 index6 alt2\">7</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"code\">\n\t\t\t\t\t\t<div class=\"container\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">While (1)</code></div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">while</code> <code class=\"csharp plain\">(turn!=TRUE);</code></div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">criticalsection();</code></div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">turn = FALSE;</code></div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">notcriticalstuff();</code></div>\n\n\t\t\t\t\t\t<div class=\"line number7 index6 alt2\"><code class=\"csharp plain\">}</code></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td colspan=\"2\">Hier wird nur mit einer TURN Variable zwischen den Prozessen hin und her geschalten. Nachteil ist das die Abl&auml;ufe nur abwechselnd in die kritischen Abschnitte eintreten k&ouml;nnen und das ein nicht im kritischen Abschnitt arbeitender Prozess trotzdem warten muss, bis der andere diesen wieder verlassen hat.</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h3>Der Peterson Algorithmus</h3>\n\n<div>\n<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_844012\">\n<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td class=\"gutter\">\n\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\n\t\t\t<div class=\"line number7 index6 alt2\">7</div>\n\n\t\t\t<div class=\"line number8 index7 alt1\">8</div>\n\n\t\t\t<div class=\"line number9 index8 alt2\">9</div>\n\n\t\t\t<div class=\"line number10 index9 alt1\">10</div>\n\n\t\t\t<div class=\"line number11 index10 alt2\">11</div>\n\n\t\t\t<div class=\"line number12 index11 alt1\">12</div>\n\n\t\t\t<div class=\"line number13 index12 alt2\">13</div>\n\n\t\t\t<div class=\"line number14 index13 alt1\">14</div>\n\n\t\t\t<div class=\"line number15 index14 alt2\">15</div>\n\t\t\t</td>\n\t\t\t<td class=\"code\">\n\t\t\t<div class=\"container\">\n\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">CONST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N = 2;&nbsp; </code><code class=\"csharp comments\">//konkurrierende Prozesse</code></div>\n\n\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp plain\">INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn; </code><code class=\"csharp comments\">//Container f&uuml;r aktiven Prozess</code></div>\n\n\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp plain\">INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interested[N];</code></div>\n\n\t\t\t<div class=\"line number4 index3 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp keyword\">void</code> <code class=\"csharp plain\">P(</code><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">process)&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//Eintreten</code></div>\n\n\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number7 index6 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">other = 1-process; </code><code class=\"csharp comments\">//Gegenteil des Prozesses</code></div>\n\n\t\t\t<div class=\"line number8 index7 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">interested[process] = TRUE;&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//Interesse bekunden</code></div>\n\n\t\t\t<div class=\"line number9 index8 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">turn = process;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//Flag setzen</code></div>\n\n\t\t\t<div class=\"line number10 index9 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">while</code><code class=\"csharp plain\">(( turn==process ) AND (interested[other]==TRUE));</code></div>\n\n\t\t\t<div class=\"line number11 index10 alt2\"><code class=\"csharp plain\">}</code></div>\n\n\t\t\t<div class=\"line number12 index11 alt1\"><code class=\"csharp keyword\">void</code> <code class=\"csharp plain\">V(</code><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">process)&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//Welcher Prozess verl&auml;&szlig;t K.A.</code></div>\n\n\t\t\t<div class=\"line number13 index12 alt2\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number14 index13 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">interested[process]= FALSE;&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//Kein Interesse mehr</code></div>\n\n\t\t\t<div class=\"line number15 index14 alt2\"><code class=\"csharp plain\">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n</div>\n\n<p>Das turn erzwingt ein Warten des interessierten Prozesses, solange ein andere Prozess im K.A. ist. Der Hauptnachteil von dezentralen Steuerungen f&uuml;r kritische Abschnitte ist das Aktive Warten (Spin Locks), was bedeutet, dass die Blockierzeit anderer Prozesse nicht genutzt werden kann.</p>\n\n<h2>Semaphore - zentrale Steuerung</h2>\n\n<p>Ein Semaphor ist ein allgemeiner Mechanismus zur Synchronisation, ohne aktiv warten zu m&uuml;ssen. Das Verfahren wurde von Dijkstra (1965) entwickelt und hat sich durchgesetzt. Ein Semaphor arbeitet auf einer priviligierten Schicht des Betriebssystems und ist somit nicht Teil der Prozesse.</p>\n\n<p>Ein Bin&auml;rer Semaphor kann einen Kritischen Abschnitt f&uuml;r zwei Prozesse verwalten. Falls mehrere Prozesse gleichzeitig auf ein Betriebsmittel zugreifen d&uuml;rfen, reicht der bin&auml;re Semaphor nich aus. Der Semaphor wird dann als Z&auml;hler implementiert. Falls er 0 ist, ist das Betriebsmittel voll ausgelastet. Ist er gr&ouml;&szlig;er als 0, so sind noch Ressourcen vorhanden, d.h. andere Prozesse d&uuml;rfen in den Kritischen Abschnitt eintreten, solange der Semaphor nicht Null ist. Dabei dekrementieren sie diesen und blockieren ihn f&uuml;r andere Prozesse, falls der Semaphor nun Null ist. Verl&auml;&szlig;t ein Prozess den Kritischen Abschnitt, inkrementiert der Prozess den Semaphor wieder und signalisiert damit, dass er seine Arbeit getan hat und nun ein anderer eintreten darf. Daher werden die beiden Operationen vor und nach dem Kritischen Abschnitt oft als Down(sem) und Up(sem) definiert.</p>\n\n<h3>Das Grundprinzip von Semaphoren</h3>\n\n<p>Es wird nicht mehr eine Art Sperrvariable verwendet, sondern ein Z&auml;hler. F&uuml;r dieses Z&auml;hler gibt es die Operationen up(s) bzw. V und down(s) bzw. P zum Erh&ouml;hen bzw. Dekrementieren des Z&auml;hlers. Ist nach einem down(s) der Z&auml;hler null, wird gewartet. Ist er irgendwann wieder gr&ouml;&szlig;er als null werden die Anweisungen ausgef&uuml;hrt. Der Semaphor ist nun nichts weiter als dieser Z&auml;hler, welcher nur durch up und down ansprechbar ist! Die beiden Operationen P und V stellen nat&uuml;rlich auch kleine kritische Abschnitte dar, welche &uuml;ber aktives Warten synchronisiert werden.</p>\n\n<div>\n<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_942869\">\n<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td class=\"gutter\">\n\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\n\t\t\t<div class=\"line number7 index6 alt2\">7</div>\n\n\t\t\t<div class=\"line number8 index7 alt1\">8</div>\n\n\t\t\t<div class=\"line number9 index8 alt2\">9</div>\n\n\t\t\t<div class=\"line number10 index9 alt1\">10</div>\n\n\t\t\t<div class=\"line number11 index10 alt2\">11</div>\n\t\t\t</td>\n\t\t\t<td class=\"code\">\n\t\t\t<div class=\"container\">\n\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">P(sem) </code><code class=\"csharp comments\">//Probiere in kritischen Abschnitt einzutreten</code></div>\n\n\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">if</code> <code class=\"csharp plain\">(sem == 0)</code></div>\n\n\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">sleep(sem); </code><code class=\"csharp comments\">//Prozess auf wartend setzen</code></div>\n\n\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">sem--;</code></div>\n\n\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp plain\">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>\n\n\t\t\t<div class=\"line number7 index6 alt2\"><code class=\"csharp plain\">V(sem) </code><code class=\"csharp comments\">//Verlasse kritischen Abschnitt</code></div>\n\n\t\t\t<div class=\"line number8 index7 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number9 index8 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">sem++; </code><code class=\"csharp comments\">//Zugang wieder freigeben</code></div>\n\n\t\t\t<div class=\"line number10 index9 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">wakeup(sem);</code></div>\n\n\t\t\t<div class=\"line number11 index10 alt2\"><code class=\"csharp plain\">}</code></div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n</div>\n\n<p>sleep und wakup sind Systembefehle, welche einen Prozess Schlafenlegen oder Aufwecken.</p>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Prozess A</td>\n\t\t\t<td>Prozess B</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td colspan=\"2\">\n\t\t\t<div>\n\t\t\t<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_908059\">\n\t\t\t<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n\t\t\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"gutter\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"code\">\n\t\t\t\t\t\t<div class=\"container\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">sem = 1; </code><code class=\"csharp comments\">//zwei Prozesse</code></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>\n\t\t\t<div>\n\t\t\t<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_726176\">\n\t\t\t<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n\t\t\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"gutter\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"code\">\n\t\t\t\t\t\t<div class=\"container\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">While (1)</code></div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">P(sem);</code></div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp comments\">// kritischer Abschnitt</code></div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">V(sem);</code></div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp plain\">}</code></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t<div>\n\t\t\t<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_952724\">\n\t\t\t<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n\t\t\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"gutter\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"code\">\n\t\t\t\t\t\t<div class=\"container\">\n\t\t\t\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp plain\">While (1)&nbsp; </code></div>\n\n\t\t\t\t\t\t<div class=\"line number2 index1 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">P(sem);</code></div>\n\n\t\t\t\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp comments\">// kritischer Abschnitt</code></div>\n\n\t\t\t\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">V(sem);&nbsp;&nbsp;&nbsp; </code></div>\n\n\t\t\t\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp plain\">}</code></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td colspan=\"2\">&nbsp;</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h3>Events</h3>\n\n<p>Betriebssysteme wie z.B. Unix benutzen Events als Abstraktion von Semaphoren zum <strong>Koordinieren</strong> von Prozessabl&auml;ufen (im Gegensatz zu kritischen Abschnitten). Ein Ereignis stellt nichts weiter als eine f&uuml;r Software erkennbare <strong>Bedingung</strong> dar. Ein Prozess kann sich Schlafen legen, bis eine bestimmte Bedingung eintreten.</p>\n\n<ul>\n\t<li>Ein Prozess setzt einen wait()-Aufruf auf ein Ereignis ab. Er wird dann an dem Event-Deskriptor wartend gesetzt.</li>\n\t<li>Wenn an dem Event-Deskriptor das Ereignis signalisiert wird, so wird ein dort wartender Prozess bereit gesetzt.</li>\n\t<li>Der wesentliche Unterschied zu den Semaphor-Operationen ergibt sich daraus, dass die Signale nicht gespeichert werden, bei Semaphoren wird dagegen der Wert bei signal() um 1 erh&ouml;ht.</li>\n</ul>\n\n<h4>Semaphore</h4>\n\n<p>Wert 0. Kommt das signal() vor dem wait(): der wait()-aufrufende Prozess wird nicht blockiert.</p>\n\n<h4>Event</h4>\n\n<p>Ein Wert ist nicht vorhanden, kein Prozess wartet. Das Ereignis wird vor dem wait()-Aufruf signalisiert: der wait()-aufrufende Prozess wird blockiert, bis ein weiteres Ereignis eintrifft. Das erste Ereignis wird nicht gemerkt.</p>\n\n<h3>Monitor</h3>\n\n<p>Ein Monitor besteht aus einigen Prozeduren, Variablen und Datenstrukturen die zu einer besonderen Art Modul zusammengefasst werden. Dieses Monitormodul verkapselt Semaphore und die Operationen auf diesen Semaphoren. N&uuml;tzlichste Eigenschaft eines Monitors ist, da&szlig; jeweils nur ein Proze&szlig; zu einer Zeit einen Monitor benutzen kann. Ein Monitor ist zwar vielen Prozessen zug&auml;nglich, aber nur jeweils ein Proze&szlig; kann den Monitor zu einem gegebenen Zeitpunkt benutzen. Monitore werden h&auml;ufig zur Verwaltung von Puffern und Ger&auml;ten eingesetzt.</p>\n\n<div class=\"well\">\n<h1 id=\"anchor5\">Synchronisationsm&ouml;glichkeiten</h1>\n\n<ul>\n\t<li>Es gibt dezentrale und zentrale Steuerungen f&uuml;r kritische Abschnitte</li>\n\t<li>Dezentrale Steuerungen ist das aktives Warten</li>\n\t<li>Zentrale Steuerungen sind Semaphore (passives Warten)</li>\n\t<li>Beim passiven Warten werden Prozesse schlafengelegt</li>\n\t<li>Ereignisse dienen der Koordination</li>\n</ul>\n</div>\n\n<h2>Was ist das Erzeuger-Verbraucher-Problem?</h2>\n\n<p>Zwei Prozesse nutzen einen Puffer mit N Pl&auml;tzen zum Datenaustausch. W&auml;hrend Prozess A Daten sequentiell in den Puffer schreibt, entnimmt Prozess B ein Datum aus dem Puffer.</p>\n\n<p><br />\nNun stellen sich die Fragen</p>\n\n<ol>\n\t<li>Wie soll man das gleichzeitige Einf&uuml;gen und Entnehmen synchronisieren?</li>\n\t<li>Ein Datum darf nur eingef&uuml;gt werden wenn der Puffer nicht voll ist.</li>\n\t<li>Ein Datum darf nur eingef&uuml;gt werden, wenn noch Platz im Buffer ist.</li>\n</ol>\n\n<p>Gel&ouml;st werden, kann das Problem mit mehreren Semaphoren.</p>\n\n<ul>\n\t<li>Ein Semaphor f&uuml;r die Kontrolle des kritischen Abschnittes</li>\n\t<li>Ein Semaphor, welcher die freien Pl&auml;tze z&auml;hlt</li>\n\t<li>Ein Semaphor, welcher die vergebenen Pl&auml;tze z&auml;hlt</li>\n</ul>\n\n<div>\n<div class=\"syntaxhighlighter  csharp\" id=\"highlighter_764603\">\n<div class=\"toolbar\"><span><a class=\"toolbar_item command_help help\" href=\"http://www.kreissl.info/bs#\">?</a></span></div>\n\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td class=\"gutter\">\n\t\t\t<div class=\"line number1 index0 alt2\">1</div>\n\n\t\t\t<div class=\"line number2 index1 alt1\">2</div>\n\n\t\t\t<div class=\"line number3 index2 alt2\">3</div>\n\n\t\t\t<div class=\"line number4 index3 alt1\">4</div>\n\n\t\t\t<div class=\"line number5 index4 alt2\">5</div>\n\n\t\t\t<div class=\"line number6 index5 alt1\">6</div>\n\n\t\t\t<div class=\"line number7 index6 alt2\">7</div>\n\n\t\t\t<div class=\"line number8 index7 alt1\">8</div>\n\n\t\t\t<div class=\"line number9 index8 alt2\">9</div>\n\n\t\t\t<div class=\"line number10 index9 alt1\">10</div>\n\n\t\t\t<div class=\"line number11 index10 alt2\">11</div>\n\n\t\t\t<div class=\"line number12 index11 alt1\">12</div>\n\n\t\t\t<div class=\"line number13 index12 alt2\">13</div>\n\n\t\t\t<div class=\"line number14 index13 alt1\">14</div>\n\n\t\t\t<div class=\"line number15 index14 alt2\">15</div>\n\n\t\t\t<div class=\"line number16 index15 alt1\">16</div>\n\n\t\t\t<div class=\"line number17 index16 alt2\">17</div>\n\n\t\t\t<div class=\"line number18 index17 alt1\">18</div>\n\n\t\t\t<div class=\"line number19 index18 alt2\">19</div>\n\n\t\t\t<div class=\"line number20 index19 alt1\">20</div>\n\n\t\t\t<div class=\"line number21 index20 alt2\">21</div>\n\n\t\t\t<div class=\"line number22 index21 alt1\">22</div>\n\n\t\t\t<div class=\"line number23 index22 alt2\">23</div>\n\n\t\t\t<div class=\"line number24 index23 alt1\">24</div>\n\n\t\t\t<div class=\"line number25 index24 alt2\">25</div>\n\n\t\t\t<div class=\"line number26 index25 alt1\">26</div>\n\n\t\t\t<div class=\"line number27 index26 alt2\">27</div>\n\n\t\t\t<div class=\"line number28 index27 alt1\">28</div>\n\n\t\t\t<div class=\"line number29 index28 alt2\">29</div>\n\n\t\t\t<div class=\"line number30 index29 alt1\">30</div>\n\n\t\t\t<div class=\"line number31 index30 alt2\">31</div>\n\t\t\t</td>\n\t\t\t<td class=\"code\">\n\t\t\t<div class=\"container\">\n\t\t\t<div class=\"line number1 index0 alt2\"><code class=\"csharp keyword\">const</code> <code class=\"csharp plain\">N 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//buffer size</code></div>\n\n\t\t\t<div class=\"line number2 index1 alt1\">&nbsp;</div>\n\n\t\t\t<div class=\"line number3 index2 alt2\"><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">mutex = 1 </code><code class=\"csharp comments\">//F&uuml;r Kritischen Abschnitt</code></div>\n\n\t\t\t<div class=\"line number4 index3 alt1\"><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">empty = N </code><code class=\"csharp comments\">//Anfangs leerer Buffer</code></div>\n\n\t\t\t<div class=\"line number5 index4 alt2\"><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">full&nbsp; = 0 </code><code class=\"csharp comments\">//noch keine Daten im Buffer</code></div>\n\n\t\t\t<div class=\"line number6 index5 alt1\"><code class=\"csharp keyword\">void</code> <code class=\"csharp plain\">ErzeugerProzess()</code></div>\n\n\t\t\t<div class=\"line number7 index6 alt2\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number8 index7 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">item;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>\n\n\t\t\t<div class=\"line number9 index8 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">while</code><code class=\"csharp plain\">(1)</code></div>\n\n\t\t\t<div class=\"line number10 index9 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number11 index10 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">iNode = CreateItem();</code></div>\n\n\t\t\t<div class=\"line number12 index11 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">P(empty);</code></div>\n\n\t\t\t<div class=\"line number13 index12 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">P(mutex);</code></div>\n\n\t\t\t<div class=\"line number14 index13 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">Insert(item) </code><code class=\"csharp comments\">//Critical Section</code></div>\n\n\t\t\t<div class=\"line number15 index14 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">V(mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//Mutex wieder erh&ouml;hen</code></div>\n\n\t\t\t<div class=\"line number16 index15 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">V(full);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class=\"csharp comments\">//full=full+1</code></div>\n\n\t\t\t<div class=\"line number17 index16 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">}</code></div>\n\n\t\t\t<div class=\"line number18 index17 alt1\"><code class=\"csharp plain\">}</code></div>\n\n\t\t\t<div class=\"line number19 index18 alt2\"><code class=\"csharp keyword\">void</code> <code class=\"csharp plain\">VerbraucherProzess()</code></div>\n\n\t\t\t<div class=\"line number20 index19 alt1\"><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number21 index20 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">int</code> <code class=\"csharp plain\">item;</code></div>\n\n\t\t\t<div class=\"line number22 index21 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp keyword\">while</code><code class=\"csharp plain\">(1)</code></div>\n\n\t\t\t<div class=\"line number23 index22 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">{</code></div>\n\n\t\t\t<div class=\"line number24 index23 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">P(full);</code></div>\n\n\t\t\t<div class=\"line number25 index24 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">P(mutex);</code></div>\n\n\t\t\t<div class=\"line number26 index25 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">Item = RemoveItem(); </code><code class=\"csharp comments\">//Critical Section</code></div>\n\n\t\t\t<div class=\"line number27 index26 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">V(mutex);</code></div>\n\n\t\t\t<div class=\"line number28 index27 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">V(empty);</code></div>\n\n\t\t\t<div class=\"line number29 index28 alt2\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">MakeSomething(Item);</code></div>\n\n\t\t\t<div class=\"line number30 index29 alt1\"><code class=\"csharp spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"csharp plain\">}</code></div>\n\n\t\t\t<div class=\"line number31 index30 alt2\"><code class=\"csharp plain\">}</code></div>\n\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n</div>\n\n<p>Der Semaphor mutex verhindert, da&szlig; gleichzeitig Verbraucher und Erzeuger im kritischen Abschnitt sind. Denn falls der Erzeuger gerade eingetreten ist, ist der Semaphore mutex null. Versucht nun der Verbraucher in den kritischen Abschnitt einzutreten, muss er bei P(mutex) warten, da der mutex noch null ist. Um nun zu Verhindern das aus einer leeren Liste gelesen oder in eine volle geschrieben wird, werden hier elegant zwei weitere Semaphoren verwendet, welche das Vorhandensein von freien Pl&auml;tzen (empty) und belegten P l&auml;tzen (full) z&auml;hlen.</p>\n\n<h2>Das Philosophenproblem</h2>\n\n<p>Beim Philosophenproblem geht es nicht um Kommunikation sondern um Synchronisation. Abstrakt gesehen, gibt es N Prozesse und N Betriebsmittel. Ein Prozess ben&ouml;tigt mindestens zwei der Betriebsmittel um fortschreiten zu k&ouml;nnen. Ohne Synchronisation, w&uuml;rden im schlimmsten Fall alle 5 Prozesse je ein Betriebsmittel bekommen und dann unendlich darauf warten, da&szlig; ein anderer Prozess eins freigibt.</p>\n\n<p>Es sitzen f&uuml;nf Personen an einem runden Tisch. Sie k&ouml;nnen entweder Denken oder Essen. Es gibt zwar f&uuml;r jeden einen Teller, aber nur f&uuml;nf St&auml;bchen. Um Essen zu k&ouml;nnen braucht man aber bekannterma&szlig;en zwei.</p>\n\n<h3>Wie kann das Philosophenproblem gel&ouml;st werden?</h3>\n\n<p>Nat&uuml;rlich denkt man zuerst an Semaphoren. Nur funktioniert die triviale L&ouml;sung mit einem Semaphor pro St&auml;bchen nicht. Es k&ouml;nnen immer noch alle Philosophen je ein St&auml;bchen gleichzeitig aufnehmen und die Prozesse w&auml;ren allesamt verklemmt. Es muss also irgendwie m&ouml;glich sein, mehr als ein St&auml;bchen gleichzeitig aufzunehmen. Bei den verschiedenen Implementationen ist vor allem darauf zu achten, da&szlig; dieses Aufnehmen der beiden St&auml;be eine Atomare Funktion ist.</p>\n\n<h2>Unix-Signale</h2>\n\n<p>Ein Ereignis wird hier als Signal bezeichnet. Unter Unix gibt es vorgegebene durchnummerierte Signale. Unter Unix kann mit <em>kill(Prozessnummer, Signalnummer)</em> einem Prozess ein Ereignis signalisiert werden.</p>\n\n<p>Die Reaktion eines Prozesses auf ein Signal kann verschieden ausfallen:</p>\n\n<ul>\n\t<li>Aktivierung einer Prozessfunktion, die der Prozess vorher f&uuml;r dieses Signal mit der Funktion <strong>signal( Signalnummer, Funktionsadresse)</strong> angemeldet hat</li>\n\t<li>Er kann das Signal mit <strong>signal(Signalnummer, SIG_IGN);</strong> ignorieren</li>\n\t<li>Der Prozess kann beendet werden.</li>\n\t<li>Hat der Prozess f&uuml;r eine Signalnummer nichts festgelegt, dann gibt es Voreinstellungen:</li>\n</ul>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>&nbsp;&nbsp;&nbsp;</td>\n\t\t\t<td>#define SIGFPE</td>\n\t\t\t<td>8</td>\n\t\t\t<td>/* Floating point trap */</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&nbsp;&nbsp;&nbsp;</td>\n\t\t\t<td>#define SIGILL</td>\n\t\t\t<td>4</td>\n\t\t\t<td>/* Illegal instruction */</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&nbsp;&nbsp;&nbsp;</td>\n\t\t\t<td>#define SIGINT</td>\n\t\t\t<td>2</td>\n\t\t\t<td>/* voreingestelle Interrupttaste z.B. Ctl -c*/</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&nbsp;&nbsp;&nbsp;</td>\n\t\t\t<td>#define SIGSEGV</td>\n\t\t\t<td>11</td>\n\t\t\t<td>/* Memory access violation */</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&nbsp;&nbsp;&nbsp;</td>\n\t\t\t<td>#define SIGTERM</td>\n\t\t\t<td>15</td>\n\t\t\t<td>/* Kill -Kommando ohne Angabe*/</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&nbsp;&nbsp;&nbsp;</td>\n\t\t\t<td>#define SIGKILL</td>\n\t\t\t<td>9</td>\n\t\t\t<td>/* unbedingter Prozessabbruch*/</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2>Was unterscheidet Pipes und Named Pipes?</h2>\n\n<p>Pipes sind nur innerhalb von Prozessgruppen (UNIX) oder zwischen Threads eines Prozesses verwendbar, da diese nur dort bekannt ist (und eindeutig identifizierbar). Diese Einschr&auml;nkung kann mit der <strong>Named Pipe</strong> umgangen werden. Eine Named Pipe ist ein mit einem <strong>eindeutigen Namen versehenes Objekt</strong> des Betriebssystems. Ein Prozess kann die Pipe erstellen, ein anderer kann eine Verbindung zu der Pipe herstellen. Im UNIX erh&auml;lt eine Named Pipe einen Pfadnamen, wie eine Datei.</p>\n\n<p><img alt=\"Pipe Schema\" src=\"http://www.kreissl.info/pics/images/bs_12.gif\" /></p>\n\n<h2>Sockets</h2>\n\n<p>Sockets sind im Grunde Pipe-Erweiterungen f&uuml;r Internet und andere Netzdienste. Dabei werden ein Socket A und ein Socket B zu einer bidirektionalen Pipe verbunden. Identifiziert wird ein Socket &uuml;ber Rechneradresse und Portnummer. So erm&ouml;glichen Sie eine Client-Server-Kommunikation:</p>\n\n<p>Ein Serverprozess erstellt einen Socket mit <em>create</em> und wartet dann auf Verbindungsw&uuml;nsche (<em>listen</em>).</p>\n\n<h2>M&ouml;glichkeiten zur Kommunikation und Synchronistation</h2>\n\n<h4>Kommunikation</h4>\n\n<ul>\n\t<li>Pipes (FIFO-Puffer - Senden (Schreiben) ist asynchron, Empfangen (Lesen) blockierend)</li>\n\t<li>Named Pipes</li>\n\t<li>Mailboxen (Tool zum Senden und Empfangen von Nachrichten)</li>\n\t<li>Send - Receive (BS Unterst&uuml;tzung f&uuml;r Mailboxen - synchron oder asynchron)</li>\n\t<li>Queues</li>\n\t<li>Sockets</li>\n\t<li>RPC</li>\n\t<li>Shared Memory</li>\n</ul>\n\n<h4>Synchronisation</h4>\n\n<ul>\n\t<li>Monitore</li>\n\t<li>Events</li>\n\t<li>Semaphore</li>\n\t<li>Barierren (oft zur Threadsynchronisation verwendet)</li>\n</ul>\n"
          ]
        },
        {
          "tag_line": "Kapitel 5 - Scheduling",
          "details": [
            "<h1 id=\"anchor6\">Kapitel 5 - Scheduling</h1>\n\n<p>Scheduling wird notwendig, wenn die Anzahl der gleichzeitig laufenden Prozesse die Anzahl der physikalischen Prozessoren &uuml;bersteigt. Die Verwaltung kann dezentral (Prozesse selbst) oder zentral erfolgen. Es gibt zwei grundlegende Modelle f&uuml;r zentrale Scheduling-Verwaltung:</p>\n\n<ul>\n\t<li>Deterministisches Modell - alle Informationen bekannt (Anzahl Prozesse/Betriebsmittel/Zeitdauer)</li>\n\t<li>Probabilistisches Modell - offen (Anzahl Prozesse nicht bekannt) oder geschlossen (Anzahl Prozesse bekannt, aber Bedienzeiten nicht)</li>\n</ul>\n\n<h2>Strategien zur Prozessorzuteilung</h2>\n\n<ul>\n\t<li><strong>Durchsatz</strong> (Anzahl bearbeiteter Prozesse pro Zeiteinheit maximieren)</li>\n\t<li><strong>Verweilzeit</strong> (Prozess soll so schnell wie m&ouml;glich abgearbeitet sein)</li>\n\t<li><strong>Wartezeit</strong> (Dauer im Zustand &quot;wartend&quot; minimieren)</li>\n\t<li><strong>Effizienz</strong> (Prozessorleistung maximal ausnutzen)</li>\n\t<li><strong>Antwortzeit</strong> (m&ouml;glichst kurze Reaktionszeiten f&uuml;r den Benutzer)</li>\n\t<li><strong>Fairness</strong> (gerechte Verteilung der Prozessorzeit)</li>\n</ul>\n\n<p>Es ist nicht m&ouml;glich CPU-Auslastung und Durchsatz zu maximieren und gleichzeitig Warte- und Antwortzeit zu minimieren. Deshalb m&uuml;ssen alle Scheduling Algorithmen Kompromisse eingehen.</p>\n\n<h2>Nach welchen Kriterium richtet sich das Scheduling Verfahren?</h2>\n\n<p>Dies h&auml;ngt in erster Linie vom Einsatzgebiet des Systems ab:</p>\n\n<ul>\n\t<li>Echzeitbetrieb</li>\n\t<li>Dialogbetrieb</li>\n\t<li>Stabel- bzw. Batchbetrieb</li>\n\t<li>Hintergrundbetrieb</li>\n</ul>\n\n<h2>Das deterministische Scheduling-Modell</h2>\n\n<p>Bei diesem Modell werden die Schedules <strong>vor der Ausf&uuml;hrung berechnet</strong>. Dies funktioniert nat&uuml;rlich nicht in interaktiven offenen Systemen, sondern nur in geschlossenen Systemen mit fester Prozessanahl und vordefinierter Betriebsmittelnutzung mit statischen Ablauf. In Dialogsystemen wird deshalb das offene probabilistische System verwendet, da hier Anzahl der Prozesse und Betriebsmittelnutzung dynamisch erfolgen...</p>\n\n<h2>Das probabilistisches Scheduling-Modell?</h2>\n\n<p>Die Entscheidung welcher Prozess den Prozessor bekommt, wird dynamisch w&auml;rend der Prozessabarbeitung gef&auml;llt. Hierbei gibt es einige wichtige Gr&ouml;&szlig;en, welche als stochastische Variablen zur Berechnung herangezogen werden k&ouml;nnen. Die Warteschlangentheorie ist wichtiges Mittel f&uuml;r Untersuchungen. (Alle Prozesse welche den Prozessor fordern werden in eine Warteschlange eingereiht).</p>\n\n<p><img alt=\"Prozess\" src=\"http://www.kreissl.info/pics/images/bs_02.gif\" /></p>\n\n<p>Die Abbildung entspricht einem Scheduling ohne Priorit&auml;ten und ohne Entzug.</p>\n\n<h3>Das Single-Server-Modell</h3>\n\n<p>Eine Warteschlange nimmt Prozesse in einem bestimmten Abstand (A) auf. Der Scheduler entnimmt nach einer gewissen Wartezeit (W) im Pool einen Prozess und f&uuml;hrt diesen in einer bestimmten Zeit (B) aus .</p>\n\n<p><img alt=\"Singe-Server\" src=\"http://www.kreissl.info/pics/images/bs_06.gif\" /></p>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>mittlere Verweildauer in Warteschlange</td>\n\t\t\t<td>W</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Zwischenankunftsabstand</td>\n\t\t\t<td>A</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Prozessorzeit der Teilprozesse</td>\n\t\t\t<td>B</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Anzahl von Prozessen in Warteschlange</td>\n\t\t\t<td>Nq (N=Nq+p)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Verkehrswert</td>\n\t\t\t<td>p=B/A <em>(Poisson-Prozesse)</em></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Verweildauer im System</td>\n\t\t\t<td>V=A*N (Littles Theroem)</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Weiter Gr&ouml;&szlig;en wie durchschnittliche Warteschlangell&auml;nge oder die Wahrscheinlichkeit das sich n Prozesse im System befinden, lassen sich mit Poissen-Verteilungen genauso wie die oben erw&auml;hnte mittlere Verweildauer ermitteln.</p>\n\n<h3>Wahrscheinlichkeiten f&uuml;r Prozessgr&ouml;&szlig;en</h3>\n\n<p>Durch Poisson-Prozesse (Markow) k&ouml;nnen Erwartungswerte, Mittelwerte und Varianzen f&uuml;r Zwischenankunftsabst&auml;nde, Bedienw&uuml;nsche und Auslastung berechnet werden. Die Betrachtungen beziehen sich hier auf den station&auml;ren Fall (t-&gt;unendlich, also FiFo).</p>\n\n<h3>First Come First Serve - FCFS</h3>\n\n<p>Ankommende Prozesse werden in eine FIFO Liste eingereiht und sequentiell abgearbeitet. Somit ist dieses Modell nicht f&uuml;r Timesharing geeignet, da es eher eine Batchverarbeitung ist.</p>\n\n<p>Kommt ein langer Prozess zuerst, m&uuml;ssen andere winzige Prozesse alle auf die Beendigung des gro&szlig;en Prozesses warten! Unfair. Bessere Implementationen k&ouml;nnen deshalb das Token entziehen.</p>\n\n<p><strong>Durchschnittliche Wartezeit W</strong> = (Wartezeit(P1) + Wartezeit(P2) + ... + Wartezeit(Pn)) / n</p>\n\n<p>Ist P1 ein vielfach gr&ouml;&szlig;erer Prozess als die restlichen, so m&uuml;ssen alle folgenden Prozesse auf die Beendigung von P1 warten. Dies l&auml;&szlig;t die durchschnittliche Wartezeit extrem steigen.</p>\n\n<p><strong>Bsp.:</strong></p>\n\n<pre>\nt(P1) = 24 t(P2) = 3 t(P3) = 3\n</pre>\n\n<p>Bei einer Abarbeitungsfolge von <strong>P1 -&gt; P2 -&gt; P3</strong> w&auml;re W = <em>17</em>. Bei einer Abarbeitungsfolge von <strong>P2 -&gt; P3 -&gt; P1</strong> nur <em>3</em>!</p>\n\n<h2>Was ist Priorit&auml;ts-Scheduling?</h2>\n\n<p>Hier wird jedem Prozess eine Priorit&auml;t zugewiesen. Ausgew&auml;hlt wird vom Scheduler der ausf&uuml;hrbereite Prozess mit der h&ouml;chsten Priorit&auml;t. Die Priorit&auml;ten k&ouml;nnen statisch definiert und dynamisch zugewiesen werden.</p>\n\n<p>Bsp: FEP (Fixed ExternalPriorities)</p>\n\n<p><img alt=\"Prioritätsscheduling\" src=\"http://www.kreissl.info/pics/images/bs_07.gif\" /></p>\n\n<h3>Das Grundproblem von Schedulern mit Priorit&auml;ten</h3>\n\n<p>Hauptproblem beim Arbeiten mit Priorit&auml;ten ist das <strong>Aushungern</strong> von Prozessen, welche m&ouml;glicherweise nie aktiv werden k&ouml;nnen, da es immer Prozesse h&ouml;herer Priorit&auml;t gibt.</p>\n\n<p>L&ouml;sung hierf&uuml;r ist das <strong>Aging</strong>. (dynamische Anhebung der Priorit&auml;t der &auml;lter werdenden Prozesse)</p>\n\n<p>Ein anderes Problem ist die Priorit&auml;tenumkehr. Ein hochpriorisierter Prozess wartet auf ein Betriebsmittel, welches ein niedrigpriorisierter Prozess reserviert hat.</p>\n\n<h3>Shortest Job First (dynamische Priorit&auml;t ohne Entzug)</h3>\n\n<p>Es wird der k&uuml;rzeste Job zur Verarbeitung ausgew&auml;hlt. Dabei werden die Durchlaufl&auml;ngen der einzelnen Prozesse protokolliert. Nach jedem Prozesswechsel wird die &quot;bereit&quot;-Warteschlange anhand der Wartezeiten absteigend neu sortiert.</p>\n\n<p>Deshalb optimiert Shortest Job First die mittlere Wartezeit. Problem ist hier auch das Aushungern von Prozessen, was auch durch Aging (Altern) verhindert werden kann.</p>\n\n<p><strong>SJF ist ohne Entzug</strong> (nonpreemtiv). Eine Variante mit Enzug ist <strong>SRTF</strong>. Dabei wird der Prozessor entzogen, falls ein Prozess in der Warteschlange ist, der k&uuml;rzer als der verbliebene Rest des aktiven Prozesses.</p>\n\n<h3>Wie arbeiten Shortest Remaining Time First und Shortest Elapsed Time (dynamisch mit Entzug)?</h3>\n\n<p>Diese beiden Verfahren sind mit Priorit&auml;ten und mit Entzug. Sie sind daher relativ aufwendig, da ein st&auml;ndiger Abgleich der Priorit&auml;tsdaten erfolgen muss. Bei SET wird Prozessen, welche schon viel Prozessorzeit zugesprochen bekamen, die die Prozessorzeit entzogen.</p>\n\n<h3>Highest Response Ratio Next - HRN</h3>\n\n<p>Umso l&auml;nger ein Prozess wartet, umso h&ouml;her steigt er in seiner Priorit&auml;t. So wird Aushungern verhindert.</p>\n\n<h2>Round-Robin Scheduling (ohne Priorit&auml;ten)</h2>\n\n<p>Das RR ist die verbreitetste Strategie, da sie fair ist und sich auch einfach implementieren l&auml;sst. Das Prinzip ist einfach. Jeder Prozess erh&auml;lt f&uuml;r eine konstante Zeit t (<strong>Quantum</strong>) die Prozessorzeit. Nach Ablauf des Zeitquantums wird der n&auml;chste Prozess aus der Warteschlange entnommen und bearbeitet. Der zuvor bearbeitete Prozess wird wieder am Anfang der Liste eingef&uuml;gt.</p>\n\n<p>Hauptproblem ist eine sinnvolle Zeitspanne f&uuml;r das Quantum zu finden. Da bei jedem Kontextwechsel Register umgeladen m&uuml;ssen, muss ein gewisser Zeitraum f&uuml;r Verwaltungsarbeiten eingerechnet werden. Dauert das Umladen der Register 5 ms macht ein Quantum von 10 ms wenig sinn, da 50% Prozessorzeit verschwendet werden w&uuml;rde.</p>\n\n<p>W&auml;hlt man das Quantum aber zu gro&szlig; (z.B. 500 ms) so ist im Mehrbenutzerbetrieb nur bedingte Interaktivit&auml;t m&ouml;glich. (RR n&auml;hert sich somit FCFS an) Sinnvoll erwiesen sich Quanten von 100 ms.</p>\n\n<div class=\"well\">\n<h1 id=\"anchor7\">Scheduling Algorithmen</h1>\n\n<ul>\n\t<li>Scheduling mit oder ohne Entzug</li>\n\t<li>Scheduling mit oder ohne Priorit&auml;ten</li>\n</ul>\n</div>\n\n<h2>Zweistufiges Scheduling</h2>\n\n<p>Angenommen der Arbeitsspeicher reicht nicht aus, um alle Prozesse abzubilden, m&uuml;ssen diese auf einen Terti&auml;rspeicher ausgelagert werden. Da das Auslagern bzw. Einlagern eines Prozesses sehr viel Zeit in Anspruch nimmt, werden zwei Stufen benutzt, um das Scheduling zu realisieren. Die erste Stufe arbeitet nur im Hauptspeicher, w&auml;hrend die zweite Stufe f&uuml;r das Ein- oder Auslagern von Prozessen verantwortlich ist. Kriterien sind hier dieselben wie oben schon erw&auml;hnt.</p>\n\n<ol>\n\t<li>Wie lange ist ein Prozess Aus- oder Eingelagert?</li>\n\t<li>Wieviel Prozessorzeit hat ein Prozess in Anspruch genommen?</li>\n\t<li>Wie gro&szlig; ist der Prozess im Speicher?</li>\n\t<li>Welche Priorit&auml;t hat der Prozess?</li>\n</ol>\n\n<h3>Was steht im Widerspruch zu hohem Durchsatz und guter Auslastung?</h3>\n\n<p>Im Widerspruch dazu stehen <strong>gutes Antwortzeitverhalten</strong> im Dialog- und Stapelbetrieb. Denn ein hoher Durchsatz und eine gute Auslastung bedingen viele Prozesse im Rechner, so da&szlig; jeder Proze&szlig; nur relativ selten aktiv werden kann, d.h. das Antwortzeitverhalten schlechter wird. Auch die Zuteilungsfairness wird dadurch zunehmend schlechter bzw. unfairer.</p>\n"
          ]
        },
        {
          "tag_line": "Kapitel 6 - Speichermanagment",
          "details": [
            "<h1 id=\"anchor8\">Kapitel 6 - Speichermanagment</h1>\n\n<h2>&Uuml;bersicht zur Freispeicherverwaltung</h2>\n\n<p>Es gibt drei grundlegende Ans&auml;tze zur Verwaltung des freien Speichers. Diese werden im folgendem Text erl&auml;utert.</p>\n\n<h3>Bitmaps?</h3>\n\n<p>Bitmaps teilen den Hauptspeicher in gleich gro&szlig;e Einheiten und assoziieren zu jedem Eintrag ein Bit in der Bitmap. Ist der Eintrag 0, so ist der Speicherbereich noch frei. Bei Nutzung eines Speicherbereiches wird in dem assoziierenden Bitmapplatz eine eins platziert. Umso kleiner die zusammengefassten Einheiten werden, umso gr&ouml;&szlig;er wird die Bitmap. Der gr&ouml;&szlig;te Nachteil von Bitmaps ist das Suchen von freien Speicherbereichen, was eine aufwendige Operation darstellt.</p>\n\n<h3>Suche in Freispeicherlisten</h3>\n\n<p>Bei dieser Variante werden Listen f&uuml;r L&ouml;cher und belegte Segmente durch Prozesse gef&uuml;hrt.</p>\n\n<table class=\"table\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>First Fit</th>\n\t\t\t<td>Der erste freie Block der gro&szlig; genug ist wird ausgew&auml;hlt, egal wieviel Speicher dadurch verschwendet wird (interne Fragmentierung).</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th>Next Fit</th>\n\t\t\t<td>Suche beginnt nicht vom Anfang der Liste, sondern vom zuletzt verwendeten Listenelement.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th>Best Fit</th>\n\t\t\t<td>Es wird der optimale Platz in Bezug auf Speicherausnutzung gesucht. Dadurch das immer Bl&ouml;cke mit der geringsten Speicherplatzverschwendung gesucht werden, werden die freien Bl&ouml;cke irgendwann zu klein.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th>Quick Fit</th>\n\t\t\t<td>Es gibt mehrere Listen f&uuml;r verschiedene Blockgr&ouml;&szlig;en.</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h3>Wie funktionieren Buddy Listen?</h3>\n\n<p>Listen haben den Nachteil, da&szlig; benachbarte freie oder belegte Speicherbereiche sich nicht zusammenlegen lassen. Abhilfe schafft hier das Buddy-System. Die Idee beruht darauf, dass mehrere Listen gef&uuml;hrt werden, welche aber nur Blockgr&ouml;&szlig;en von 2^n zulassen. Zweierpotenz deshalb, weil ein Rechner Bin&auml;rzahlen zur Adressierung benutzt.</p>\n\n<h4>Beispiel</h4>\n\n<p>Die maximale Blockgr&ouml;&szlig;e betr&auml;gt 64 Mbytes und die minimale Blockgr&ouml;&szlig;e 4 Kbyte. D.h. 226 - 212, also m&uuml;ssen Listen f&uuml;r N=12 bis N=26 verwaltet werden. Somit w&auml;ren f&uuml;r diese Blockgr&ouml;&szlig;enwahl mit dem Buddysystem 15 Listen notwendig.</p>\n\n<p>Anfragen werden nun immer zur n&auml;chsth&ouml;hren Zweierpotenz aufgerundet. D.h. wird eine Anfrage an einen 75 Kbyte Block gestellt, muss ein 128 Kbyte gro&szlig;er Slot verwendet werden. Anfangs gibt es eine Liste f&uuml;r in unserem Beispiel 64 Mbyte Speicher. Der Buddymanager w&uuml;rde die Liste rekursiv so oft teilen, bis ein 128 Kbyte gro&szlig;er Block in eine der anderen Listen frei ist.</p>\n\n<p>Falls die angeforderten Blockgr&ouml;&szlig;en aussschliesslich Zweierpotenzen w&auml;ren, w&uuml;rde es zu keiner Internen Fragmentierung kommen k&ouml;nnen. Da dies aber nie der Fall ist, wird viel Speicher durch interne Fragmentierung verschwendet.</p>\n\n<h3>Zusammenfassung Freispeicherverwaltung</h3>\n\n<p>Bitmaps unterteilen den Speicher in <strong>Allokationseinheiten</strong>. F&uuml;r jede Einheit gibt es ein Bit im Bitmap. Verkn&uuml;pfte Listen bieten Suchm&ouml;glichkeiten mit First Fit, Best Fit oder Quick Fit. Quick Fit setzt mehrere Listen bestimmter Lochg&ouml;&szlig;en voraus. Das Buddy System verwaltet n Listen von 1,2, 4, 8 bis zur Gr&ouml;&szlig;e des Speichers. D.h. ein 1 MByte gro&szlig;er Speicher ben&ouml;tigt 21 Listen und hat Initial nur einen einzigen Eintrag in der letzten Liste, der das 1 MByte gro&szlig;e Loch beschreibt. Alle anderen Listen sind leer. Speicher wird nun immer in Abh&auml;ngigkeit von einer Potenz von 2 vergeben, der gerade noch gro&szlig; genug ist, um die Daten aufzunehmen. Dies wird einfach implementiert, in dem der Gro&szlig;e block einfach solange geteilt wird, bis der Datenblock in den Freispeicherblock passt. Das Buddysystem ist zwar schnell, aber impliziert eine <strong>starke interne Fragmentation</strong>, da ja immer auf Zweierpotenzen gerundet werden muss.</p>\n\n<div class=\"well\">\n<h1 id=\"anchor9\">Methoden zur Freispeicherverwaltung</h1>\n\n<ul>\n\t<li>einfache verkettete Listen mit Best-,Next- oder First-Fit Suche</li>\n\t<li>Bitmap-System welches Speicher in gleichgro&szlig;e Einheiten teilt</li>\n\t<li>Buddy-Listen nach dem bin&auml;ren System</li>\n</ul>\n</div>\n\n<h2>Segmentierung (mehrdimensionale Adressr&auml;ume)</h2>\n\n<p>Eindimensionale Adressierung hat den Nachteil, da&szlig; Programme mit verschieden dynamisch wachsenden Programmteilen nur schlecht realisierbar sind. Code, Stack und Daten w&uuml;rden hintereinander im Speicher liegen. Ben&ouml;tigt ein Programm aber extrem viele Variablen, w&uuml;rde der Compiler mit der Fehlermeldung abbrechen, da&szlig; es nicht genug Speicher g&auml;be. Um nun mehrere Stack, Daten und Codebereiche getrennt voneinander adressieren zu k&ouml;nnen, ohne da&szlig; die verschiedenen Teile in Konflikt geraten, wurden die Segmente eingef&uuml;hrt.</p>\n\n<p>Segmentierte Speicherung wird oft als das Prinzip der <strong>gestreuten Speicherung</strong> benannt. Gestreut deshalb, weil die einzelnen Seiten nicht nacheinander im Speicher liegen m&uuml;ssen, sondern dort eingef&uuml;gt werden, wo Platz ist. Anders als z.B. bei Kontinuierlicher Allokation, wo viel Speicher durch externe Fragmentierung verlorengeht, tritt bei Segmentation dieses Problem nicht auf. Daf&uuml;r aber interne Fragmentierung...</p>\n\n<h3>Wie werden Segmenten adressiert?</h3>\n\n<p>Um mit Segmenten arbeiten zu k&ouml;nnen, sind zweiteilige Adressen notwendig, bestehend aus <strong>Segment</strong> und <strong>Offset</strong>. Die Segmentation muss also dem Programmierer bewusst sein, da ein Segment nur eine logische Einheit darstellt. Besonders einfach gestaltet sich das &uuml;bersetzen von Prozeduren. Angenommen jede Prozedur hat ihr eigenes Codesegment, ben&ouml;tigt man nur die Segmentnummer, um die Funktion aufzurufen, da der Eintrittspunkt bei der logischen Adresse 0 dieses Segmentes ist.</p>\n\n<p>Wird nun eine Prozedur neu kompiliert, m&uuml;ssen die restlichen Prozeduren nicht neu kompiliert werden, da der Eintrittspunkt immer noch der gleiche ist. Und zwar 0. Die Segmentnummern werden eh dynamisch vergeben.</p>\n\n<h3>Gemeinsam genutzte Segmente</h3>\n\n<p>Durch Segmentierung wird es sehr einfach, verschiedene Codesegmente gemeinsam zu nutzen. So genannte <strong>Shared Libraries</strong> sind in jedem modernen Betriebssystem notwendig, denn sie stellen f&uuml;r viele Programme Frameworks oder API&#39;s bereit, deren Funktionalit&auml;t sich jedes Programm bedienen kann, soweit es die daf&uuml;r notwendigen Zugriffsrechte hat. Ob ein Segment ausf&uuml;hrbar ist oder nicht, wird &uuml;ber die Schutzart des Segmentes definiert.</p>\n\n<h2>Das Prinzip des virtuellen Speichers durch Paging</h2>\n\n<p>Um mehr Speicher bereitzustellen werden statt echter physikalischer Adressen virtuelle benutzt, welche durch die MMU in reale Adressen bei Benutzung umgewandelt werden. Durch das Paging k&ouml;nnen Seiten aus- oder eingelagert (nach einem Page Fault) werden. Eine <strong>Page Table</strong> referenziert virtuelle auf physikalische Adressen. Swapping ist in Reinform sehr langsam. Sinnvollerweise werden Segmente in Seiten geteilt, welche durch Paging ein oder ausgelagert werden. (Protected Mode) Die MMU kann, muss aber nicht auf der CPU liegen. Jede Seitentabelleneintrag hat ein Present/Absent Bit, welches Auskunft dar&uuml;ber gibt, ob eine Seite sich im Speicher befindet oder nicht. Des Weiteren vermerkt eine Art <strong>Dirty Bit</strong>, ob eine Seite im Speicher ge&auml;ndert wurde, um entscheiden zu k&ouml;nnen, ob ein zur&uuml;ck schreiben notwendig wird.</p>\n\n<p>Die momentan verwendeten Seiten eines Programmablaufes wird <strong>Working Set</strong> genannt. Demand Paging bedeutet, dass Seiten erst dann abgefordert werden, wenn sie ben&ouml;tigt werden.</p>\n\n<p>Eine virtuelle Adresse besteht aus <strong>Seitenummer und Offset</strong>. Bei einem Contextswitch wird nach der entsprechenden Seitennummer in der Page Table gesucht und die zugeh&ouml;rige physikalische Adresse errechnet. Es wird meist ein n-stufiges Paging angewandt, um die Suche mach den Seiten zu beschleunigen (Unix) . Bei i386 gibt es ein so genanntes <strong>Seitenverzeichnis</strong> (DIR) mit 1024 Zeilen, welche wiederum je auf eine Seitentabelle verweisen. Somit enth&auml;lt eine lineare Adresse beim Intel DIR,PAGE und OFFSET Teil. (mehrstufiges Paging)</p>\n\n<p>Beim Swapping werden statt Seiten ganze Prozesse ausgelagert.</p>\n\n<div class=\"well\">\n<h1 id=\"anchor10\">Virtual Memory und Caching</h1>\n\n<ul>\n\t<li>Demand Paging und Caching basieren auf den gleichen Prinzip</li>\n\t<li>Sie arbeiten nur auf verschiedenen Ebenen</li>\n\t<li>Cache-Misses werden von der Hardware geregelt, Page Faults vom Betriebssystem</li>\n</ul>\n</div>\n\n<h3>Der TLB - Translation Lookaside Buffer</h3>\n\n<p>Um die Zeit der Adressumrechnung zu vermindern, wird in der MMU ein <strong>Assoziativspeicher</strong> mit meist nicht mehr als 32 Eintr&auml;gen verwaltet. Die Eintr&auml;ge enthalten die zuletzt verwendeten virtuellen Seiten mit der dazugeh&ouml;rigen Seitenrahmennummer im Speicher. Gleichzeitig wird dort vermerkt, welche Art von Lese/Schreibzugriff erlaubt ist und ob die Seite ver&auml;ndert wurde. Kommt eine Anforderung auf eine nicht im TLB vorhandene Seite, wird ein Eintrag aus dem TLB mit der neu dekodierten Adresse &uuml;berschrieben, so da&szlig; bei der n&auml;chsten Anfrage die Adressumrechnung entfallen kann.</p>\n\n<div class=\"well\">\n<h1 id=\"anchor11\">Translation Lookaside Buffer</h1>\n\n<ul>\n\t<li>TLB&#39;s werden verwendet, wenn Seitentabelle auf Grund eines zu gro&szlig;en Adressraumes nicht m&ouml;glich ist</li>\n\t<li>TLB bildet zuletzt genutzten (64 bei UltraSparc) virtuellen Seitennummern auf physikalische Seitenrahmen ab</li>\n\t<li>h&auml;ufig benutzte Seiten werden in einem Cache (Translation Storage Buffer) verwaltet</li>\n\t<li>Dieser Cache bildet Seiten direkt ab und wird bei TLB-Miss zuerst untersucht</li>\n\t<li>befindet sich die Seite nicht im Cache, muss sie in der Translation Table gesucht werden</li>\n</ul>\n</div>\n\n<h3>Invertierte Page Tables?</h3>\n\n<p>Eine Seitentabelle enth&auml;lt hier einen Eintrag f&uuml;r jeden Seitenrahmen des physikalischen Speichers. Der Eintrag enth&auml;lt Informationen &uuml;ber den besitzenden Prozess und die virtuelle Seite. So entspricht die Anzahl der Eintr&auml;ge der Anzahl der Seitenrahmen im Speicher. Die Tabelle verwaltet nur, welche Seite, von welchem Prozess in den Seitenrahmen des Arbeitsspeicher geladen wurden.</p>\n\n<h3>Paging D&auml;mons</h3>\n\n<p>Paging arbeitet nur effizient, wenn jederzeit gen&uuml;gend Seitenrahmen im Speicher frei sind, um diese bei einem Page Fault neuen Seiten belegen zu k&ouml;nnen. Doch wie wird sichergestellt, da&szlig; der Speicher komplett ausgef&uuml;llt werden muss und somit bei einem Page Fault erst eine Seite ausgelagert werden muss? Viele Betriebssysteme haben daf&uuml;r einen speziellen Dienst vorgesehen. Der Paging D&auml;mon wird in zyklischen Abst&auml;nden aktiviert. Dieser schaut nun nach ob gen&uuml;gend <strong>Frames</strong> im Speicher zur Verf&uuml;gung stehen. Ist dies nicht der Fall, werden so viele Seiten wie notwendig mit einem der <strong>Seitenersetzungsalgorithmen</strong> aus dem Speicher entfernt und auf die Platte zur&uuml;ckgeschrieben.</p>\n\n<h3>Das Zusammenspiel von Segmentierung und Paging</h3>\n\n<p>Um beide Vorteile (Mehrdimensionalit&auml;t und virtuellen Speicher) nutzen zu k&ouml;nnen, werden in fast allen modernen Betriebssystemen beide Techniken angewandt. Dabei wird das Paging <strong>transparent</strong>, also f&uuml;r den Programmierer nicht sichtbar, hinter die Segmentierung geschalten. Auf dieser Basis bauen sich auch die Adressen dieser Maschinen auf. Es gibt verschiedene Implementationen von Segmentierung und Paging. Aber letztendlich haben sie eines gemeinsam. Die logische Adresse besteht aus</p>\n\n<ol>\n\t<li>die Segmentnummer zur Auswahl des richtigen Segmentdeskriptors und</li>\n\t<li>den Offset zur Adressierung innerhalb des Segmentes.</li>\n</ol>\n\n<p>Die Implementierungen unterscheiden sich nun in der Verwaltung der <strong>Deskriptoren</strong> und der Art und Weise wie die aus Segment + Offset entstandene virtuelle Adresse &uuml;ber die Page Table auf den realen Speicher projiziert bzw. umgerechnet wird.</p>\n\n<p><img alt=\"Adressumsetzung\" src=\"http://www.kreissl.info/pics/images/bs_11.gif\" /></p>\n\n<h3>Was passiert wenn Sie ein Programm starten?</h3>\n\n<ul>\n\t<li>Der Virtual Memory Manager verwaltet den virtuellen Speicher.</li>\n\t<li>Bei Programmstart richtet das BS f&uuml;r den Prozess eine Seitentabelle ein.</li>\n\t<li>Eine definierte Anzahl Rahmen werden dem Prozess als Arbeitsmenge zugeteilt.</li>\n\t<li>Seiten aus dem Read-Only Bereich der EXE werden direkt geladen und brauchen nicht zur&uuml;ckgeschrieben werden.</li>\n\t<li>Read-Write Bereiche werden zuerst direkt aus der EXE geladen und im Speicher hinterlegt.</li>\n\t<li>Bei einem Schreib-Bezug wird sie als private Kopie in die Auslagerungsdatei geschrieben. So k&ouml;nnen mehrere Prozesse die selbe EXE im benutzen. (Copy On Write)</li>\n</ul>\n\n<p>Der VMM von Windows verwaltet mehrere Listen f&uuml;r:</p>\n\n<ul>\n\t<li>freie Seiten, welche mit 0 initialisiert wurden (zerofilled)</li>\n\t<li>uninitialisierte freie Seiten, die noch alten Inhalt haben</li>\n\t<li>wartende Seiten, die Prozess zugewiesen waren und nicht modifiziert wurden(standby pages)</li>\n\t<li>wartende, aber modifizierte Seiten (modified pages)</li>\n\t<li>belegte Seiten, welchen einem Prozess zugewiesen / referenziert sind (valid pages)</li>\n\t<li>unbenutzbare Seiten, durch z.B. Hardwarefehler (unusable pages)</li>\n</ul>\n\n<h3>Adressumrechnung der Multics</h3>\n\n<ol>\n\t<li>mit Segmentnummer wird Segmentdeskriptor festgestellt</li>\n\t<li>es wird gepr&uuml;ft, ob die Pagetable des Segmentes im Speicher ist</li>\n\t<li>ist sie nicht im Speicher tritt ein Segmentfehler auf und es erfolgt ein Trap</li>\n\t<li>ist sie im Speicher wird der Pagetableeintrag f&uuml;r die angefragte Seite &uuml;berpr&uuml;ft</li>\n\t<li>falls Seite nicht im Speicher entsteht Page Fault</li>\n\t<li>ist Seite im Speicher wird die physikalische Adresse des Seitenursprungs aus dem Pagetableeintrag entnommen</li>\n\t<li>Der Offset wird zur gewonnenen Adresse hinzuaddiert und die physikalische Adresse ist berechnet.</li>\n</ol>\n\n<p><em>(nach Tanenbaum)</em></p>\n\n<p>Meist wird ein Assoziativspeicher verwendet, um die letzten paar Umrechnungen ohne Verz&ouml;gerung ausgeben zu k&ouml;nnen. Ein TLB enth&auml;lt zwei Vergleichsfelder f&uuml;r Segmentnummer und korrespondierende virtuelle Seite und einige zus&auml;tzliche Attribute, wie Schutzattribute, Age oder Referenziert-Bits.</p>\n\n<h3>Adressumrechnung beim Pentium 2</h3>\n\n<p>Intel Prozessoren besitzen ab dem i386 eine <strong>LDT</strong> (local descriptor table) und eine <strong>GDT</strong> (global descriptor table). Die Local Descriptor Tables enthalten die programmeigenen Segmente, wie Stack-, Code- und Datensegment der verschiedenen Benutzerprogramme. Die Global Descriptor Table enth&auml;lt dagegen die Systemsegmente samt deren des Betriebssystems , welche erst geladen werden muss. Wird ein Segmentselektor in ein Segmentregister geladen, wird der entsprechende Bezeichner aus der LDT oder GDT geholt und in MMU Registern gespeichert. Ob L- oder GDT kann dem Selektor entnommen werden, da dort ein Bit f&uuml;r diese Auswahl reserviert ist. Der Deskriptor besteht nun aus der Basisadresse des Segmentes, der Gr&ouml;&szlig;e des Segmentes und verschiedenen Privilegbits. Es wird nun eine virtuelle Adresse &uuml;ber Segmenteselektor + Offset gebildet. Bei deaktiviertem Paging ist nun diese Adresse die lineare physikalische. Ist aber Paging aktiv wird die Adresse als virtuell interpretiert und &uuml;ber die Seitentabelle auf den realen Speicher abgebildet.</p>\n\n<h3>Sicherheit und Segmentverwaltung</h3>\n\n<p>Jeder Deskriptor in einer Deskriptortabelle ist mehrere Byte breit und enth&auml;lt Beschreibungsinformationen f&uuml;r ein Segment aus dem linearen Adressraum. Neben der Segment-Basisadresse (BASE) enth&auml;lt er das LIMIT, das die Segmentgr&ouml;&szlig;e angibt. Dabei wird durch ein Granularit&auml;tsbit festgelegt, ob das LIMIT direkt als L&auml;nge interpretiert wird (Segmentgr&ouml;&szlig;en bis 1 MB) oder mit dem Wert 4096 multipliziert wird und damit Segmentgr&ouml;&szlig;en bis 4 GB unterst&uuml;tzt. Der Descriptor-Privilege-Level gibt an, mit welcher Berechtigungsstufe der Zugriff auf das Segment erfolgen muss:</p>\n\n<ul>\n\t<li>Level 0: Betriebssystem</li>\n\t<li>Level 1, 2: Betriebssystemdienste, Treiber, Systemsoftware</li>\n\t<li>Level 3: Anwendungssoftware</li>\n</ul>\n\n<p>Weitere Informationen im Deskriptor zeigen an, ob auf das Segment lesend, schreibend oder ausf&uuml;hrend zugegriffen werden darf und ob es sich um ein System- oder Anwendungssegment handelt. Ein Present-Bit gibt an, ob das Segment sich derzeit &uuml;berhaupt im Hauptspeicher befindet.</p>\n\n<h2>Zusammenfassung von Freispeicherverwaltung, Segmentierung und Paging</h2>\n\n<p>Segmentierung wird genutzt, um statt einen linearen Adressraum (wie beim virtuellen Speicher), mehrere virtuelle Adressr&auml;ume nutzen zu k&ouml;nnen. Segmentierung wurde entworfen, um dynamisch wachsende Tabellen besser Handhaben zu k&ouml;nnen. Somit ist schafft Segmentierung einen mehrdimensionalen Adressraum.</p>\n\n<p>Unter Swapping versteht man das komplette Ein- und Auslagern von Prozessen. Das Swapping des segmentierten Speichers ist vergleichbar mit dem Demand-Paging des virtuellen Speichers. Nur das Segmente unterschiedlich gro&szlig; sein k&ouml;nnen. Aus diesem Grund tritt hier das Problem der externen Fragmentierung auf.</p>\n\n<p>Um die externe Fragmentierung zu minimieren, werden die L&ouml;cher als verkettete Liste im Speicher gehalten. Falls ein Segment geladen werden soll, sucht z.B. Best Fit, dass n&auml;chst gr&ouml;&szlig;ere Loch unter allen, wo das Segment passen w&uuml;rde. First Fit nimmt das N&auml;chste Loch, welches f&uuml;r das Segment gro&szlig; genug w&auml;re.</p>\n\n<p>Neben dem Swapping kann auch Paging zum Auslagern von Segmenten benutzt werden. Hierbei sind die auszulagernden Bl&ouml;cke gleich gro&szlig;, da die Segmente in gleich gro&szlig;e Seiten eingeteilt werden. Zur Auslagerung wird das bekannte Demand Paging benutzt. Meist wird eine Kombination aus Segmentierung und Paging angewandt, bei der die Adresse aus zwei Teilen besteht. (Segmentnummer und Offset innerhalb des Segments). Segmente werden also in Seiten unterteilt. Zur Leistungsverbesserung werden die zuletzt verwendeten Segment-Seiten- Kombinationen in einem Assoziativspeicher (TLB) gehalten. Im Gegensatz zum Paging ist es beim reinen Swapping nicht m&ouml;glich, Prozesse auszuf&uuml;hren, die alleine schon nicht in den Hauptspeicher passen.</p>\n\n<p>Bitmaps unterteilen den Speicher in Allokationseinheiten. F&uuml;r jede Einheit gibt es ein Bit im Bitmap. Verkn&uuml;pfte Listen bieten Suchm&ouml;glichkeiten mit First Fit, Best Fit oder Quick Fit. Quick Fit setzt mehrere Listen bestimmter Lochg&ouml;&szlig;en voraus. Das Buddy System verwaltet n Listen von 1,2, 4, 8 bis zur Gr&ouml;&szlig;e des Speichers. D.h. ein 1 MByte gro&szlig;er Speicher ben&ouml;tigt 21 Listen und hat Initial nur einen einzigen Eintrag in der letzten Liste, der das 1 MByte gro&szlig;e Loch beschreibt. Alle anderen Listen sind leer. Speicher wird nun immer in Abh&auml;ngigkeit von einer Potenz von 2 vergeben, der gerade noch gro&szlig; genug ist, um die Daten aufzunehmen. Dies wird einfach implementiert, in dem der Gro&szlig;e block einfach solange geteilt wird, bis der Datenblock in den Freispeicherblock passt. Das Buddysystem ist zwar schnell, aber impliziert eine starke interne Fragmentation, da ja immer auf Zweierpotenzen gerundet werden muss.</p>\n"
          ]
        },
        {
          "tag_line": "Kapitel 7 - Seitenersetzung",
          "details": [
            "<h1 id=\"anchor12\">Kapitel 7 - Seitenersetzung</h1>\n\n<h2>Seitenersetzungsalgorithmen</h2>\n\n<p>Falls eine Seite angefordert wird, aber kein Platz f&uuml;r deren Einlagerung im Speicher mehr vorhanden ist, so muss eine andere Seite entfernt werden. Aber welche? Es gibt nun verschiedene Ans&auml;tze f&uuml;r dieses Problem...</p>\n\n<h3>Welcher w&auml;re der beste Algorithmus zur Seitenersetzung?</h3>\n\n<p>Dieser ist theoretisch gegeben, aber <strong>nicht umsetzbar</strong>. Die Seite die am <strong>sp&auml;testen erst wieder verwendet</strong> wird, wird ausgelagert. Da in einem Echtzeitsystem nie vorhersagbar ist, welcher Prozess wann wie lange aktiv sein wird, ist diese Strategie nicht umsetzbar... In einem deterministischen Modell w&auml;re er aber durchaus denkbar, da dort jeder Schritt eindeutig definiert ist.</p>\n\n<h3>Seitenersetzung mit Not-Recently-Used - NRU</h3>\n\n<p>Jede Seite bekommt zwei Statusbits zugeordnet. R wird gesetzt, wenn die Seite lesend oder schreibend referenziert wurde. M wird gesetzt, falls die Seite ver&auml;ndert wird. Diese beiden Bits sind in jedem Seitentabelleneintrag enthalten und m&uuml;ssen bei jeder Seitenreferenzierung aktualisiert werden.</p>\n\n<p>Die zwei Bit stellen vier Klassen dar, welche genutzt werden um einen Paging-Algorithmus zu realisieren.</p>\n\n<ol>\n\t<li>nicht referenzierte und nicht modifizierte Seite</li>\n\t<li>nicht referenzierte und modifizierte Seite</li>\n\t<li>referenzierte und nicht modifizierte Seite</li>\n\t<li>referenzierte und modifizierte Seite</li>\n</ol>\n\n<p>LRU w&auml;hlt zuf&auml;llig eine Seite aus der kleinstnummerierten Klasse zum Entfernen aus.</p>\n\n<h3>Seitenersetzung mit Fifo - First In First Out</h3>\n\n<p>Es wird eine Liste gef&uuml;hrt, welche alle Seiten enth&auml;lt. Neue Seiten werden an das Ende der Liste angef&uuml;gt. So ist die Liste nach dem <strong>Alter der Seiten sortiert</strong>. Der FiFo Paging-Algorithmus macht nichts weiter, als bei einem Seitenfehler die &auml;lteste Seite zu entfernen, also die Seite, die am Anfang der Liste steht.</p>\n\n<p>Das Problem an Fifo ist, da&szlig; auch extrem h&auml;ufig referenzierte Seiten ausgelagert werden. Um dies zu umgehen wird das oben schon erw&auml;hnte R (Referenziert) Bit verwendet, um jeder Seite eine zweite Chance zu geben, falls das R-Bit nicht null ist.</p>\n\n<h3>Seitenersetzung mit Second Chance</h3>\n\n<p>Arbeitet wie Fifo, nur wird beim Entfernen des Kopfes nachgeschaut, ob das R Bit null ist. Wurde die Seite nie referenziert, so wird sie entfernt, wie f&uuml;r FiFo &uuml;blich. Wurde sie aber referenziert, wird sie zum Ende der Liste verschoben, als wurde sie neu geladen. Das R-Bit wird dabei auf Null gesetzt. So wird gew&auml;hrleistet, das h&auml;ufig benutzte Seiten weniger oft als nicht referenzierte Seiten ausgelagert werden. Second Chance ist ein durchaus guter Paging Algorithmus mit einem Nachteil. Es m&uuml;ssen st&auml;ndig konstante Seiten innerhalb der Liste von Anfang zum Ende verschoben werden. Diesen Nachteil b&uuml;gelt der Uhr Algorithmus aus.</p>\n\n<h3>Der Uhr-Seitenersetzungsalgorithmus</h3>\n\n<p>Der Clock-Algorithmus arbeitet im Prinzip wie Second Chance, nur das anstelle einer FiFo Liste eine <strong>Ringliste</strong> verwendet wird. Dabei wird in einem Pointer (Zeiger der Uhr) auf den aktuellen Anfang der Liste gezeigt. Bei einer Second Chance muss nun nicht die Seite verschoben werden, es wird einfach der Zeiger auf das n&auml;chste Element referenziert.</p>\n\n<p>Der Uhr Algorithmus ist also eine Implementation von Second Chance mit einer Ringliste.</p>\n\n<h3>Seitenersetzung mit Least-Recently-Used - LRU</h3>\n\n<p>Dieser Paging Algorithmus versucht den Optimalen zu approximieren, indem es versucht die Seiten zu entfernen, welche am L&auml;ngsten nicht mehr benutzt wurden.</p>\n\n<p>Die Implementation ist trotzdem nicht ganz einfach. Es m&uuml;sste theoretisch eine Liste gef&uuml;hrt werden, welche nach dem oben genannten Kriterium sortiert ist. Diese Liste m&uuml;sste nach jeder Seiteneinlagerung neu Sortiert werden. Da dies eine zu komplexe Operation darstellt, muss daf&uuml;r eine Softwarel&ouml;sung approximiert werden, welche wesentlich schneller arbeitet.</p>\n\n<h3>LRU mit Matrixumsetzung</h3>\n\n<p>Es wird eine globale N x N Matrix f&uuml;r alle N Seiten gef&uuml;hrt. Diese Matrix wird mit 0 initialisiert. Wird eine Seite x referenziert, so wird die Zeile x auf 1 gesetzt und danach die Spalte x auf 0. In jedem Moment ist die Zeile deren Summe am Kleinsten ist, die am wenigsten genutzte und die Zeile mit dem gr&ouml;&szlig;ten Wert, die am h&auml;ufigsten genutzte Seite.</p>\n\n<p>Wenn die notwendige Hardware (Matrix) nicht vorhanden ist, muss ein anderer effizienter Paging Algorithmus benutzt werden, der ohne jede Hardware auskommt.</p>\n\n<h3>Seitenersetzung NFU - Not Frequently Used</h3>\n\n<p>Bei jeder Uhrunterbrechung wird das <strong>Referenziert-Bit</strong> jeder Seite auf einen Softwarez&auml;hler, welcher mit null initialisiert wurde, hinzuaddiert. Es wird also versucht <strong>zu z&auml;hlen</strong>, wie oft eine Seite referenziert wird. Das Problem von NFU ist es, dass Spitzen in der Referenzierung starke Auswirkungen auf den Z&auml;hler haben. So kann es vorkommen, da&szlig; eine Seite, welche anfangs stark genutzt wurde und sp&auml;ter nicht mehr, einer zyklisch genutzten Seite nicht zur Auslagerung vorgezogen wird.</p>\n\n<p>Eine Modifikation von NFU versucht LRU zu simulieren und diesen Fehler aufzuheben.</p>\n\n<h3>Seitenersetzung mit Aging - LRU durch Softwareemulation</h3>\n\n<ol>\n\t<li>Vor der Addition es Referenziert-Bits werden alle Z&auml;hler um eins nach rechts geschoben</li>\n\t<li>das Refenziert-Bit wird auf das am weitesten links stehende Bit addiert</li>\n</ol>\n\n<p>Bei einem Seitenfehler wird auch hier die Seite mit dem kleinsten Fehler entfernt. Durch das Rechtsverschieben verkleinert sich der Wert eines Z&auml;hlers rapide und es wird verhindert, da&szlig; nur kurzeitig verwendete Seiten f&auml;lschlicherwei&szlig;e als oft referenziert angesehen werden...</p>\n\n<div class=\"well\">\n<h1 id=\"anchor13\">Seitenersetzungsalgorithmen</h1>\n\n<ul>\n\t<li>Not-Recently-Used (referenziert und modifiziert Bits - vier Zust&auml;nde)</li>\n\t<li>Least-Recently-Used (Seiten die lange nicht benutzt worden auslagern) und LRU mit Matrixumsetzung</li>\n\t<li>FiFo, Second Chance, Uhr-Seitenersetzungsalgorithmus</li>\n\t<li>Not Frequently Used (&uuml;ber Z&auml;hler f&uuml;r Referenzierungen)</li>\n\t<li>Aging - LRU durch Softwareemulation</li>\n</ul>\n</div>\n\n<h2>Die Belady&#39;s Anomalie</h2>\n\n<p>Eine Erh&ouml;hung der Seitenrahmen im Speicher, also mehr Speicher, hei&szlig;t nicht zwangsl&auml;ufig eine Verringerung von Seitenfehlern!</p>\n\n<h3>Was passiert beim Einsatz einer schnelleren Platte mit der Seitenfehlerrate?</h3>\n\n<p>Die Seitenfehlerrate steigt, da die &Uuml;bertragungszeit f&uuml;r Seiten sinkt. Die Anzahl der gleichzeitig ausf&uuml;hrbaren Prozesse steigt, da jeder Proze&szlig; nun mit weniger Seitenrahmen - und einer h&ouml;heren Fehlerrate - &quot;leben&quot; kann.</p>\n\n<h3>Working Sets - dynamisches Seitenaustauschverfahren</h3>\n\n<p>Prozess Arbeitsbereiche werden eingesetzt und die Zahl der Seitenfehler weiter zu minimieren. Ein Prozess unterliegt auch einer Art <strong>Lokalit&auml;t</strong>. Es werden im Mittel bestimmte Seiten h&auml;ufiger und Andere sogut wie nie oder gar nicht zur Prozessabarbeitung ben&ouml;tigt. Man nennt dies <strong>Referenzielle Lokalit&auml;t</strong>.</p>\n\n<p>Mit Arbeitsbereichen wird versucht Informationen vor dem Laden eines Prozesses auszunutzen, um h&auml;ufig verwendete Referenzen bevorzugt zu behandeln. Die Erfassung der f&uuml;r das Working Set notwendigen Daten wird auch &uuml;ber eine Art Aging Algorithmus umgesetzt. Jede Seite geh&ouml;rt zu einem bestimmten Working Set. Wird eine Seite l&auml;nger als N Ticks nicht mehr benutzt, wird sie aus dem Working Set entfernt.</p>\n\n<p>Die gewonnene Information des Working Sets kann verwendet werden, um den <strong>Clock Algorithmus</strong> zu verbessern. Und zwar wird nicht nur nach einer nichtreferenzierten Seite geschaut, sondern auch ob die Seite zu einem Working Set geh&ouml;rt oder nicht. Falls sie einem Arbeitsbereich angeh&ouml;rt, wird sie <strong>&uuml;bersprungen</strong>, egal ob im Moment referenziert oder nicht.</p>\n\n<h3>Welche Problematik tritt bei der Arbeitsmengenstrategie auf?</h3>\n\n<p>Das Hauptproblem ist die Seitenauslagerung durch Herausfallen von Seiten aus dem Working Set. Seiten k&ouml;nnen aus dem Working Set ausgelagert werden, ohne das ein Seitenfehler vorliegt und ohne das f&uuml;r diese Seite eine Neue eingelagert wurde. Die aktuelle Lokalit&auml;t wird eben nur approximiert. Die Arbeitsmenge enth&auml;lt m&ouml;glicherweise auch Seiten die nur einmal benutzt wurden. Der &Uuml;bergang zu einer neuen Lokalit&auml;t erfolgt nur allm&auml;hlich.</p>\n\n<h3>Gefahr bei Seitenaustauschverfahren</h3>\n\n<p>Gefahr des <strong>Seitenflatterns</strong> (Trashing). Bei &Uuml;berlastung mit zu vielen Prozessen die entweder zu viele Pagefaults produzieren und/oder zuwenig Seitenrahmen zur Verf&uuml;gung haben, ist der Rechner weitgehend mit dem Ein-/und Auslagern von Seiten besch&auml;ftigt und kann an den eigentlichen Aufgaben der Prozesse kaum noch weiterarbeiten. Effektive CPU Auslastung sinkt durch viele Seitenfehler. Weitere Gefahr besteht dann durch zu einfach konstruierte Scheduler, die bei sinkender CPU-Auslastung mit einer h&ouml;heren Prozessintensit&auml;t reagieren. <strong>Page Damons</strong> k&ouml;nnen dem Abhilfe schaffen, weil sie Prozesse auslagern, wenn nicht mehr ausreichend Seitenrahmen im Speicher zur Verf&uuml;gung stehen.</p>\n\n<h3>Was kann man gegen Trashing (Seitenflattern) tun?</h3>\n\n<p>Man sollte Page D&auml;mons benutzten, denn dadurch wird die Anzahl der gleichzeitig aktiven Prozesse verringert und jedem Prozess stehen mehr Seitenrahmen zur Verf&uuml;gung.</p>\n\n<h3>Wie wird die Seitengr&ouml;&szlig;e festgelegt?</h3>\n\n<p>Die Seitengr&ouml;&szlig;e ist normalerweise klein. Dies hat verschiedene Gr&uuml;nde sie klein zu halten, aber auch einen wichtigen Grund, die Gr&ouml;&szlig;e nicht zu klein zu definieren. Im Mittel ist die letzte Seite eines Codest&uuml;ckes nur <strong>halb gef&uuml;llt</strong>, da logischerweise nicht jedes Code, Stack oder Datensegment genau in eine Seite passen kann oder sich so auf mehrere verteilt, da&szlig; kein freier Speicher mehr verbleibt. Des Weiteren muss beachtet werden, dass es auch viele kleine Segment gibt. Angenommen man legt eine Seitengr&ouml;&szlig;e von 32 KB fest, so werden bei 4 KB gro&szlig;en Segmenten stets 28 KB verschwendet. Andersherum ben&ouml;tigt man mit kleinen Seiten eine gr&ouml;&szlig;ere Seitentabelle, deren Anzahl proportional zur Seitengr&ouml;&szlig;e ist. Des Weiteren muss man einkalkulieren, da&szlig; das Einladen einer Seite von Platte eine langwierige Operation ist. Es ist trivial das das Einlagern von vier 8K-Seiten schneller ist, als das Einlagern von 64 512 Byte gro&szlig;en Seiten. Es muss also ein Mittelweg gefunden werden, welcher einen optimalen Nutzen aus den oben genannten Kriterien zieht.</p>\n\n<pre>\nVerschwendung = Prozessgr&ouml;&szlig;e * Seitentabelleneintragsg&ouml;&szlig;e / Seitengr&ouml;&szlig;e +\nSeitengr&ouml;&szlig;e / 2\n</pre>\n\n<p>Die Nullstellenberechnung der ersten Ableitung in Abh&auml;ngigkeit der Seitengr&ouml;&szlig;e ergibt:</p>\n\n<pre>\n<strong>Optimale Seitengr&ouml;&szlig;e</strong> = Wurzel aus 2 * Prozessgr&ouml;&szlig;e *\nSeitentabelleneintragsg&ouml;&szlig;e\n</pre>\n"
          ]
        },
        {
          "tag_line": "Kapitel 8 - Deadlocks",
          "details": [
            "<h1 id=\"anchor14\">Kapitel 8 - Deadlocks</h1>\n\n<h2>Die notwendigen Bedingungen f&uuml;r Deadlocks</h2>\n\n<ol>\n\t<li>Mutual Exclusion (z.B. via Druckerspooler &uuml;ber Ersatz-BM Buffer aufgel&ouml;st)</li>\n\t<li>Belegungs- und Wartebedingung (Prozess kann weitere BM anfordern)</li>\n\t<li>Unterbrechbarkeitsbedingung (BM k&ouml;nnen nicht entzogen werden)</li>\n\t<li>zyklische Wartebedingung (Zyklus im Betriebsmittelgraph)</li>\n</ol>\n\n<h2>Was sind die hinreichende Bedingungen f&uuml;r Deadlocks?</h2>\n\n<p>Es darf keine externe Betriebsmittelinstanz bestehen.</p>\n\n<h2>Livelocks</h2>\n\n<p>Es wurde ein Betriebsmittel vergeben, es besteht aber keine Verhinderung. Das BM k&ouml;nnte irgendwann wieder freigegeben werden, aber der Zeitpunkt unbekannt.</p>\n\n<p>Z.B. <strong>Priotit&auml;tsscheduling</strong> (langwierige Prozesse verhungern da benachteiligt)</p>\n\n<h2>Wie kann man Deadlocks aufl&ouml;sen oder umgehen?</h2>\n\n<ol>\n\t<li>Vogel-Strau&szlig; Algorithmus (einfach Ignorieren)</li>\n\t<li>Versuchen zu Erkennen und zu beheben (Topologische Sortierung des BM-Graphs oder Vektoren-Matrix Variante)</li>\n\t<li>dynamisches Verhindern (vor Zuteilung auf Deadlock pr&uuml;fen)</li>\n\t<li>konzeptionelles Vermeiden (eine der notwendigen Bedingungen eliminieren)</li>\n</ol>\n\n<h3>Welche Prozesse sind an einem Deadlock beteiligt?</h3>\n\n<p>Prozesse die mehrere Betriebsmittel mit jeweils <strong>exklusiven Zugriff</strong> ben&ouml;tigen.</p>\n\n<h3>Wie kann man Deadlocks (im Voraus) erkennen?</h3>\n\n<p>Die zur Ausf&uuml;hrung eines Prozesses notwendigen Betriebsmittel m&uuml;ssten vor Ausf&uuml;hrung bekannt sein. Das ist aber in einem offenen System nicht m&ouml;glich. Das Prinzip ist das gleiche wie das <strong>Preclaiming</strong> im DBMS. Erst wenn alle angeforderten Betriebsmittel verf&uuml;gbar sind, f&uuml;hrt der Prozess den n&auml;chsten Schritt aus. Algorithmisch w&auml;re dies durch zyklische Pr&uuml;fung (f&uuml;r jeden Proze&szlig;) auf Vorhandensein der erforderlichen Betriebsmittel erreichbar.</p>\n\n<h3>Wie werden Deadlocks beseitigt?</h3>\n\n<p>Durch <strong>Abbruch</strong> der beteiligten Prozesse und Freigabe der belegten Betriebsmittel. Siehe <strong>optimistische Sperrverfahren</strong> bei DBMS.</p>\n\n<h3>Wie k&ouml;nnen Deadlocks vermieden werden?</h3>\n\n<h4>M&ouml;glichkeit 1</h4>\n\n<p>Es m&uuml;sste bei jeder Betriebsmittelanforderung gepr&uuml;ft werden, ob diese zu einem Deadlock f&uuml;hren w&uuml;rde. Da dies sehr aufwendig ist, wird so nicht verfahren.</p>\n\n<h4>M&ouml;glichkeit 2</h4>\n\n<p>Bei Anforderung zus&auml;tzlicher Betriebsmittel werden alle bisher reservierten Betriebsmittel freigegeben und dann zusammen mit den zus&auml;tzlichen Betriebsmitteln erneut angefordert (Form von Preclaiming).</p>\n\n<h4>M&ouml;glichkeit 3</h4>\n\n<p>Betriebsmitteltypen werden linear nach Priorit&auml;t angefordert . Falls schon Betriebsmittel reserviert sind, k&ouml;nnen keine Betriebsmittel, die wichtiger sind als die schon reservierten, angefordert werden. Damit wird zyklisches Warten unm&ouml;glich (&auml;hnelt dem 2-Phasen-Sperrprotokoll). Problem ist aber die Vergabe geeigneter Nummerierungen, da reale und abstrakte Betriebsmittel (z.B. Spoolbereiche auf Festplatten) sich nur schwer Ordnen lassen.</p>\n\n<h4>M&ouml;glichkeit 4</h4>\n\n<p>Der Banker Algorithmus als Verfahren zur Erkennung sicherer Systemzust&auml;nde bei der Verteilung von Ressourcen.</p>\n\n<h3>Der Bankieralgorithmus</h3>\n\n<p>Ein Banker hat einen bestimmte Menge einer Ressource. Jeder Kunde hat ein Limit, bis zu dem er Ressourcen vom Banker erhalten kann. Der Banker hat aber so viele Ressourcen, da&szlig; er das gr&ouml;&szlig;te vorhandene Limit gerade noch bedienen kann. Der Kunde bekommt die Ressource, falls der Banker danach noch gen&uuml;gend Ressourcen hat, um mindestens einem der Kunden sein komplettes Limit zuteilen zu k&ouml;nnen.</p>\n\n<h4>Beispiel Bankieralgorithmus</h4>\n\n<p>Der Banker habe 10 Einheiten eines Betriebsmittels verf&uuml;gbar.</p>\n\n<ol>\n\t<li>Das Limit von Kunde A betrage 8 Einheiten.</li>\n\t<li>Das Limit von Kunde B ist 7 Einheiten.</li>\n\t<li>A hat zur Zeit 5 Einheiten belegt</li>\n\t<li>und B hat 2 Einheiten reserviert</li>\n</ol>\n\n<p>Falls B nun eine weitere Einheit anfordert, so muss dies verweigert werden, da dann der Banker nur noch 2 Einheiten &uuml;brig h&auml;tte, diese aber nicht zur Befriedigung einer kompletten Reservierung von A oder B ausreichen w&uuml;rde und zu einem Deadlock f&uuml;hren w&uuml;rde. Solch ein Zustand hei&szlig;t unsicherer Zustand. Der Problem ist nun, da&szlig; jeder Proze&szlig; mu&szlig; im Voraus wissen muss, wieviele Einheiten eines Betriebsmittels er maximal w&auml;hrend seiner Abarbeitung ben&ouml;tigen wird.</p>\n\n<h3>Warum funktioniert die Deadlock-Vermeidung bei linearer Ordnung der Betriebsmittel?</h3>\n\n<p>Prozesse k&ouml;nnen zwar alle Betriebsmittel anfordern, aber alle Anforderungen m&uuml;ssen gem&auml;&szlig; der Nummerierungsreihenfolge geschehen. Somit ist es von vornherein ausgeschlossen, da&szlig; ein Proze&szlig; der ein Betriebsmittel h&ouml;herer Ordnung besitzt, ein Betriebsmittel niedrigerer Ordnung, das von einem anderen Proze&szlig; belegt ist, anfordern kann. Also werden Schlingen im Wartegraph und damit Deadlocks vermieden, da nun eine notwendige Voraussetzung f&uuml;r Deadlocks eliminiert wurde. Umgesetzt kann das Ganze durch eine Nummerierung der Betriebsmittel werden. Das Prinzip &auml;hnelt dem Zeitstempelverfahren bei DBMS.</p>\n"
          ]
        },
        {
          "tag_line": "Kapitel 9 - Dateisysteme",
          "details": [
            "<h1 id=\"anchor15\">Kapitel 9 - Dateisysteme</h1>\n\n<p>Hier geht es im Besonderem um Verwaltung, Zugriffsoptimierung und die Umsetzung einer f&uuml;r den Menschen vereinfacht nutzbaren Abstraktion. Der Zugriff auf Daten erfolgt nicht wie beim Hauptspeicher Byte-orientiert, sondern aus Effizienzgr&uuml;nden blockweise, da Platten um ein vielfaches langsamer als Arbeitspeicher sind. Des Weiteren sind bis auf einige Ausnahmen, wie CD ISO9660, die meisten Dateisysteme Betriebssystemspezifisch.</p>\n\n<h2>Was ist eine Datei?</h2>\n\n<p>Eine Datei ist ein logisches Betriebsmittel, welches eine endliche Menge zusammengeh&ouml;riger Daten beinhaltet. Verzeichnisse sind spezielle Dateien, welche zur Strukturierung von Dateisystemen eingef&uuml;hrt wurden.</p>\n\n<h2>Welche M&ouml;glichkeiten der Freispeicherverwaltung von File Systemem gibt es?</h2>\n\n<ol>\n\t<li>Kontinuierliche Allokation - schlecht wenn Datum angehangen werden soll</li>\n\t<li>Verkettete Listen - schlecht, da Wahlfreier Zugriff extrem langsam</li>\n\t<li>Listen mit Zuordnungstabellen - Zuordnungstabellen erlauben schnellen wahlfreien Zugriff (FAT)</li>\n\t<li>Indizierte Speicherung</li>\n\t<li>Indirekt indizierte Speicherung</li>\n</ol>\n\n<p>Ein leeres Dateisystem wird als lineares Medium betrachtet und nach und nach linear aufgef&uuml;llt. Vorteil dieser Variante ist schneller Zugriff. Nachteil ist die extreme externe Fragmentierung bei &Auml;nderungen von Dateigr&ouml;&szlig;en.</p>\n\n<h3>Das Prinzip der verketteten Listen</h3>\n\n<p>Listen sind langsamer als kontinuierliche Allokation, bieten nur wahlfreien Zugriff und besitzen nur geringe Fehlertoleranz. Daf&uuml;r werden aber nur sehr <strong>wenig Verwaltungsdaten</strong> ben&ouml;tigt. (Hier nur Pointer auf den n&auml;chsten belegten Block) Eine Verbesserung der Effizienz wird durch das Nutzen doppelt verketteter Listen erzielt, wobei sich aber auch der Zahl der Verwaltungsdaten verdoppelt.</p>\n\n<h3>Das Prinzip der Listen mit Zuordnungstabellen</h3>\n\n<p>Hier werden die Nutzdaten von den Zeigern in eine extra Tabelle ausgelagert. Die Dateizuordnungstabelle am Bsp. FAT enth&auml;lt f&uuml;r jeden Block einen Eintrag mit einem Verweis auf den Folgeblock oder einen bestimmten Eintrag f&uuml;r EOF. Die Effizient wird hier bei gro&szlig;en Tabellen eingeschr&auml;nkt.</p>\n\n<h3>Indizierte Speicherung</h3>\n\n<p>F&uuml;r jede Datei wird hier die Startadresse und die Indexl&auml;nge gemerkt. So ist zwar schneller wahlfreier Zugriff m&ouml;glich, aber es herrscht das gleiche Problem der externen Fragmentierung wie bei kontinuierlicher Allokation. Die Geschwindigkeitssteigerung gegen&uuml;ber Zuordnungstabellen kommt daher, dass Zusammenh&auml;ngende Bl&ouml;cke in Zuordnungstabellen nicht hintereinander liegen, sondern verstreut in der Tabelle. Die indizierte Speicherung f&uuml;hrt sogenannte Indexbl&ouml;cke ein, in welche hintereinander die zur Datei geh&ouml;rigen Blocknummern eingetragen werden. So muss bei einem Zugriff im Worst Case nicht die ganze Zuordnungstabelle nach den Blocknummern durchsucht werden.</p>\n\n<p>Wie gro&szlig; sollte nun aber so ein Indexblock gew&auml;hlt werden? Variable l&auml;ngen sind schlecht realisierbar. W&auml;hlt man sie zu gro&szlig;, geht Speicher durch interne Fragmentierung verloren. W&auml;hlt man sie zu klein, beschr&auml;nkt man die Dateigr&ouml;&szlig;e... Deshalb wurde die indirekt indizierte Speicherung eingef&uuml;hrt.</p>\n\n<h3>Indirekt indizierte Speicherung</h3>\n\n<p>Ein Eintrag im Verwaltungsblock (Indexblock) zeigt wieder auf einen oder mehrere Bl&ouml;cke, die nun die Verweise auf die wirklichen Datenbl&ouml;cke enthalten, oder wiederrum auf weitere Indexbl&ouml;cke. (Dreifach Indirekt) So ist auch auf gro&szlig;e Dateien der Zugriff gew&auml;hrleistet.</p>\n\n<h3>Was ist das Besondere an Unix FS Ext 2?</h3>\n\n<p>Es werden Inodes f&uuml;r den Zugriff auf Datenbl&ouml;cke verwendet. Die Dateinamen werden in einer extra Tabelle verwaltet, welche die Attribute (Eigent&uuml;mer, Zeiten, Gr&ouml;&szlig;e) und 12 direkte Zeiger auf Blockadressen (einfach, doppelt, dreifach indirekt) enth&auml;lt.</p>\n\n<h2>Festplatten-Scheduling-Algorithmen</h2>\n\n<ul>\n\t<li>First Come First Serve</li>\n\t<li>Shortest Seek Time First (Sektor mit k&uuml;rzesten Suchzeit suchen)</li>\n\t<li>Scan (Diskarm bewegt sich von einem Ende zum Anderen und bearbeitet Requests)</li>\n\t<li>C-Scan (Diskarm wird bei Erreichen des Endes wieder auf Anfang zur&uuml;ckgesetzt - kreisf&ouml;rmig)</li>\n\t<li>Look (Wie C-Scan, nur wird nur so weit wie notwendig zur&uuml;ckgesetzt)</li>\n\t<li>Look (Wie C-Look, nur kreisf&ouml;rmig)</li>\n</ul>\n\n<h3>Welche Bewertungskriterien f&uuml;r Festplattenalgorithmen gibt es?</h3>\n\n<ul>\n\t<li>Caching</li>\n\t<li>Demand Paging wichtiger als E/A der Anwendungen</li>\n\t<li>Robustheit nach Systemabst&uuml;rzen</li>\n\t<li>Ber&uuml;cksichtigung der hohen Rotationsgeschwindigkeiten moderner Platten</li>\n\t<li>Verzeichnisse und Indexbl&ouml;cke sollten in mittleren statt &auml;u&szlig;eren oder inneren Zylindern sein, da dort die mittlere Zugriffszeit am kleinsten ist (im Durchschnitt befindet sich der Lesekopf in der Mitte)</li>\n</ul>\n\n<h2>Die FAT - File Allocation Table</h2>\n\n<p>Die FAT Dateizuordnungstabelle liegt auf den ersten Spuren einer Platte. Sie wird aus Sicherheitsgr&uuml;nden oft gesichert. Alle Bl&ouml;cke einer Platte sind &uuml;ber die FAT miteinander verkettet (<strong>abgesetzte verkettete Allokation</strong>). Die Gr&ouml;&szlig;e einer Zuordnungseinheit ist f&uuml;r eine Partition statisch, kann sich aber zwischen den Partitionen unterscheiden (&uuml;blich sind 512, 1024 oder 4096 Bytes). FAT bietet weder Schutzmechanismen, noch unterst&uuml;tzt es lange Dateinamen (erst ab VFAT).</p>\n\n<h3>Welche Verzeichniseintr&auml;ge hat FAT?</h3>\n\n<ul>\n\t<li>Dateiname (8+3 Zeichen)</li>\n\t<li>Attribut-Byte</li>\n\t<li>Zeit und Datum der letzten Bearbeitung</li>\n\t<li>Erste Zuordnungseinheit der Datei</li>\n\t<li>Dateil&auml;nge</li>\n</ul>\n\n<p>Das Dateisystem assoziiert eine Baumstruktur. F&uuml;r jede Datei enth&auml;lt die Dateizuordnungstabelle eine lineare, gezeigerte Liste, mit der die Bl&ouml;cke der Datei bzw. des Unterverzeichnisses bestimmt werden k&ouml;nnen. Der Index der Tabelleneintr&auml;ge stellt die Blocknummer der Festplatte dar.</p>\n\n<h2>NTFS</h2>\n\n<p>NTFS hei&szlig;t New Technology File System. NTFS ist mit einem <strong>Zugriffsschutz</strong> ausgestattet und hat auch keine Gr&ouml;&szlig;enbegrenzung mehr. Ein Logfile wird verwendet, um nach einem Systemausfall Daten rekonstruieren zu k&ouml;nnen. NTFS besitzt nur Dateien. Analog zu den I-Nodes beim Unix gibt es beim NTFS eine <strong>Master File Table</strong>, in welcher jede Datei einen Eintrag besitzt. Zusammenh&auml;ngende Bereiche (extents) werden als <strong>B-Baum</strong> organisiert.</p>\n\n<h3>Was ist die MFT von NTFS?</h3>\n\n<p>Bei kleinen Dateien bzw. Verzeichnissen werden alle Attribute (incl. der Daten) innerhalb des MFT-Eintrages abgelegt (bis zu 1 bis 4 KB). Ein Eintrag in der MFT ben&ouml;tigt einen oder mehrere S&auml;tze der MFT (Satzl&auml;nge ist konfigurierbar). Bei gro&szlig;en Dateien enth&auml;lt der MFT-Eintrag den Wurzelknoten eines <strong>B-Baums</strong>, dessen &quot;Bl&auml;tter&quot; die Verweise auf die zusammenh&auml;ngenden Dateibereiche (Extent oder Lauf) enthalten.</p>\n\n<p>&Auml;hnlich wie die Inode-Tabelle beim UNIX-System stellt die MFT ein flaches Dateisystem dar. &Uuml;ber die Verzeichnisse wird darauf die bekannte Baumstruktur definiert.</p>\n\n<h3>Wie werden unter NTFS Dateien eindeutig identifiziert?</h3>\n\n<p>Jede Datei ist eindeutig &uuml;ber eine <strong>ID</strong> identifizierbar. Diese ID ist die Satznummer ihres Eintrages in der <strong>MasterFileTable</strong> (48 Bit). Zus&auml;tzlich wird eine Folgenummer (16 Bit) angeh&auml;ngt, die bei jedem Bezug auf den MFT-Eintrag (z.B. beim &Ouml;ffnen der Datei) um 1 erh&ouml;ht wird (f&uuml;r Konsistenz&uuml;berpr&uuml;fungen)</p>\n\n<h3>Wie werden unter NTFS Verzeichnisse umgesetzt?</h3>\n\n<p>Ein Verzeichniseintrag besteht aus dem Dateinamen, der ID-Nummer der Datei bzw. des Unterverzeichnisses, einer Kopie der Update-Zeit und der Dateil&auml;nge aus dem MFT-Eintrag. Verzeichnisse werden nicht wie bei FAT in einer linearen Liste verwaltet, sondern als <strong>B-Baum</strong>.</p>\n\n<h3>Spezialdateien von NTFS</h3>\n\n<ul>\n\t<li>MasterFileTable (MFT)</li>\n\t<li>MFT2: enth&auml;lt die ersten 16 Eintr&auml;ge der MFT als Backup</li>\n\t<li>Eine Logdatei (Daten &uuml;ber Transaktionen zum Wiederherstellen der Daten- bzw. der Dateisystemkonsistenz)</li>\n\t<li>Datentr&auml;gerdatei enth&auml;lt den Namen des Datentr&auml;gers, Versionsnummer des Dateisystems und eventuellen Verdacht auf Inkonsistenz</li>\n\t<li>Wurzelverzeichnis</li>\n\t<li>Cluster-Bitmap-Datei f&uuml;r belegte und freie Cluster des Datentr&auml;gers</li>\n\t<li>Bootdatei mit dem Startcode f&uuml;r NT</li>\n\t<li>BadClusterDatei, welche Verweise auf defekte Cluster enth&auml;lt</li>\n</ul>\n\n<h2>I-Nodes des Unix Dateisystems</h2>\n\n<p>Die ersten Adressen von Plattenbl&ouml;cken sind in dem I-Node gespeichert. Diese Adressen reichen aber nur f&uuml;r kleine Dateien aus. F&uuml;r gr&ouml;&szlig;ere Dateien, welche nicht durch ein I-Node adressierbar sind, gibt es Adressen in dem I-Node, die die Adresse eines Plattenblockes enthalten, welcher weitere Plattenadressen enth&auml;lt. Dieser Block wird &quot;<strong>einfach indirekter Block</strong>&quot; genannt. &quot;Einfach indirekte&quot; Bl&ouml;cke verweisen auf Bl&ouml;cke, die ihrerseits eine Reihe von direkten Blocknummern enthalten. Beim Zugriff auf Daten &uuml;ber einen indirekten Block mu&szlig; der Kern zuerst diesen indirekten Block lesen, den passenden direkten Blockeintrag ermitteln und dann diesen Block lesen. Es gibt auch Adressen, die auf Bl&ouml;cke zeigen, die die Adressen von einfach indirekten Bl&ouml;cken enthalten. Solche &quot;doppelt indirekten&quot; Bl&ouml;cke enthalten eine Liste indirekter Blocknummern. Bl&ouml;cke mit dem Kennzeichen &quot;dreifach indirekt&quot; enthalten eine Liste von doppelt indirekten Blocknummern u.s.w.</p>\n\n<p><img alt=\"I-Nodes\" src=\"http://www.kreissl.info/pics/images/bs_03.gif\" /></p>\n\n<h2>Dateideskriptoren</h2>\n\n<p>Jedem Prozess ist eine eigene Benutzer-Filedecriptor-Tabelle zugeordnet. Ruft ein Prozess <em>open</em> oder <em>create</em> holt der Systemkern einen freien Inode aus der Inode-Tabelle und &uuml;bergibt diesen an die globale Dateitabelle und erzeugt einen Eintrag in der Benutzer-Filedecriptor-Tabelle.</p>\n\n<h3>Was enth&auml;lt die globale Dateitabelle des Systems?</h3>\n\n<p>Den Offset in Byte zum Dateianfang f&uuml;r den n&auml;chsten <em>read-</em> bzw. <em>write-Befehl</em> des Benutzers und die <strong>Zugriffsberechtigungen</strong> f&uuml;r den Proze&szlig;, der die Datei er&ouml;ffnet hat. Die Benutzer-Filedecriptor-Tabellen enthalten dagegen nur die ge&ouml;ffneten Dateien eines Prozesses.</p>\n\n<p><img alt=\"Dateideskriptoren\" src=\"http://www.kreissl.info/pics/images/bs_04.gif\" /></p>\n\n<h3>Was beinhaltet ein I-Node?</h3>\n\n<ul>\n\t<li>Dateityp</li>\n\t<li>Eigent&uuml;mer</li>\n\t<li>Gruppe des Eigent&uuml;mers</li>\n\t<li>Zugriffsschutzbits</li>\n\t<li>Datumseintr&auml;ge</li>\n\t<li>Anzahl der Links f&uuml;r diesen I-Node</li>\n\t<li>Zeiger auf den Dateiinhalt</li>\n</ul>\n\n<h2>Ger&auml;te als I/O Dateien</h2>\n\n<p>Es gibt zwei Klassen solcher Dateien. Blockorientierte Spezialdateien und Zeichenorientierte Spezialdateien.</p>\n\n<h3>Blockorientierte Spezialdateien</h3>\n\n<p>Blockorientierte Spezialdateien werden benutzt, um Ger&auml;te zu modellieren, die aus frei adressierbaren Bl&ouml;cken bestehen. ( <strong>random access devices</strong> wie Festplatten). Wird eine blockorientierte Spezialdatei ge&ouml;ffnet, so kann ein Block gelesen werden, ohne da&szlig; man sich um die Struktur des Dateisystems, das dies erm&ouml;glicht, k&uuml;mmern zu m&uuml;ssen.</p>\n\n<h3>Zeichenorientierte Spezialdateien</h3>\n\n<p>Diese werden benutzt, um Ger&auml;te zu modellieren, die aus <strong>Zeichenstr&ouml;men</strong> bestehen. Beispiele hierf&uuml;r sind Terminals, Drucker, Netzschnittstellen. Ein Programm schreibt auf das entsprechende I/O-Ger&auml;t, indem es in die korrespondierende zeichenorientierte Spezialdatei schreibt. Analoges gilt f&uuml;r das Lesen.</p>\n\n<h2>Wie ist das Unix Dateisystems aufgebaut?</h2>\n\n<p><img alt=\"Unix\" src=\"http://www.kreissl.info/pics/images/bs_05.gif\" /></p>\n\n<p>Der Bootblock ist meistens im ersten Sektor einer Partition. Er enth&auml;lt den Bootstrap-Code, der beim Hochfahren eines UNIX-Rechners in den Speicher gelesen wird. Er l&auml;dt bzw. initialisiert das Betriebssystem.</p>\n\n<p>Der <strong>Superblock</strong> beschreibt den <strong>Aufbau des Dateisystems</strong>. Eine Kopie des Superblocks befindet sich permanent im Speicher. Der Kern schreibt periodisch den Superblock auf die Platte zur&uuml;ck, so da&szlig; er immer mit den aktuellen Daten im Dateisystem &uuml;bereinstimmt. Der Superblock enth&auml;lt folgende Felder:</p>\n\n<ul>\n\t<li>Gr&ouml;&szlig;e des Dateisystems</li>\n\t<li>Anzahl der freien Bl&ouml;cke</li>\n\t<li>Liste der freien Bl&ouml;cke</li>\n\t<li>Index auf den n&auml;chsten freien Block</li>\n</ul>\n\n<ul>\n\t<li>Gr&ouml;&szlig;e der I-Nodeliste</li>\n\t<li>Anzahl der freien Inodes im Dateisystem</li>\n\t<li>Liste der freien Inodes</li>\n\t<li>Index auf den n&auml;chsten freien Inode in dieser Liste</li>\n</ul>\n\n<ul>\n\t<li>Sperrkennzeichen f&uuml;r die Listen freier Bl&ouml;cke und Inodes</li>\n\t<li>Flag f&uuml;r durchgef&uuml;hrte &Auml;nderungen im Superblock</li>\n</ul>\n\n<h2>Wie kann ein Proze&szlig; auf Daten auf der Festplatte zugreifen?</h2>\n\n<ol>\n\t<li>Das virtuelle Ger&auml;t hinter dem die Festplatte verborgen wird, hei&szlig;t Datei.</li>\n\t<li>Der Proze&szlig; &ouml;ffnet die Datei und erh&auml;lt eine Datei-ID die auf eine Datei-Deskriptor-Tabelle verweist.</li>\n\t<li>Es folgt die Adressierung der Sektoren.</li>\n\t<li>&Uuml;ber die Sektoradresstabelle (FAT oder I-Node Tabelle) werden die Adressen der Bl&ouml;cke ermittelt</li>\n\t<li>Es folgt die &Uuml;bertragung der Bl&ouml;cke zum Hauptspeicher</li>\n\t<li>Zugriff erfolgt nach speziellem Prinzip, wie z.B. SSN</li>\n\t<li>zur Minimierung der Suchzeit muss Wahl einer effizienten Positionierungsstrategie</li>\n\t<li>Durch einen Interrupt oder ein spezielles Register teilt der Controller dem BS das Ende der &Uuml;bertragung mit.</li>\n</ol>\n\n<h3>Wie wird eine Datei unter Unix gesucht?</h3>\n\n<p>Linux identifiziert Dateien indirekt &uuml;ber den absoluten Pfadnamen, indem es durch diesen den dazugeh&ouml;rigen I-Node sucht. Jede Datei wird durch einen oder mehrere I-Nodes beschrieben. Die I-Nodes enthalten die Blockadressen der Datei. Ein Katalog (Verzeichnis) enth&auml;lt alle im Verzeichnis enthaltenen Datei- bzw. Verzeichnisnamen und die dazugeh&ouml;rigen I-Nodes.</p>\n\n<h4>Unix Beispielzugriff</h4>\n\n<ol>\n\t<li>Es soll die Datei <em>/var/log/messages</em> betrachtet werden</li>\n\t<li>Der I-Node des Wurzelverzeichnisses <strong>&quot;/&quot;</strong> steht an einer definierten Stelle auf der Platte</li>\n\t<li>Es wird das Verzeichnis <strong>&quot;var&quot;</strong> im Wurzelkatalog (auch eine Datei) gesucht</li>\n\t<li>In diesem Katalog steht der dazugeh&ouml;rige <strong>I-Node</strong> der auf das Verzeichnis bzw. den Katalog &quot;var&quot; verweist</li>\n\t<li>nun wird in der Katalogdatei &quot;var&quot; nach <strong>&quot;log&quot;</strong> gesucht und der dazugeh&ouml;rige <strong>I-Node</strong> gelesen</li>\n\t<li>Nun kann &uuml;ber den I-Node nach dem Eintrag <strong>&quot;messages&quot;</strong> in &quot;log&quot; gesucht werden</li>\n\t<li>Der I-Node der Datei &quot;messages&quot; wird nun in die globale <strong>Dateideskriptortabelle</strong> und die lokale Deskriptortabelle des Prozesses geladen</li>\n\t<li>Dieser Dateideskriptor ist das <strong>Handle</strong>, mit dem der Prozess auf die Datei zugreifen kann</li>\n\t<li>Nach eine <strong>Close()</strong> wird der I-Node aus der Dateideskriptorliste wieder entfernt.</li>\n</ol>\n"
          ]
        }
      ]
    },
    {
      "title": "TEMPLATE",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Rechnerarchitektur",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Datenbanken",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Künstliche Intelligenz",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Softwaretechnologie",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "Bildverstehen",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    },
    {
      "title": "TEMPLATE",
      "content": [
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        },
        {
          "tag_line": "",
          "details": [
            ""
          ]
        }
      ]
    }
  ]
}